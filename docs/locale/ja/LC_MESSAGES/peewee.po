# SOME DESCRIPTIVE TITLE.
# Copyright (C) charles leifer
# This file is distributed under the same license as the peewee package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: peewee 2.8.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-07 08:33+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../../peewee/api.rst:4
msgid "API Reference"
msgstr "APIリファレンス"

#: ../../peewee/api.rst:9 ../../peewee/example.rst:35
msgid "Models"
msgstr "モデル"

#: ../../peewee/api.rst:13
msgid ""
"Models provide a 1-to-1 mapping to database tables. Subclasses of "
"``Model`` declare any number of :py:class:`Field` instances as class "
"attributes. These fields correspond to columns on the table."
msgstr ""
"モデルはデータベーステーブルに1対1のマッピングを提供します。``Model`` のサブクラスは、任意の数の :py:class:`Field` "
"インスタンスをクラス属性として宣言します。これらのフィールドは、テーブルカラムに対応しています。"

#: ../../peewee/api.rst:17
msgid ""
"Table-level operations, such as :py:meth:`~Model.select`, "
":py:meth:`~Model.update`, :py:meth:`~Model.insert`, and "
":py:meth:`~Model.delete`, are implemented as classmethods. Row-level "
"operations such as :py:meth:`~Model.save` and "
":py:meth:`~Model.delete_instance` are implemented as instancemethods."
msgstr ""
":py:meth:`~Model.select`、:py:meth:`~Model.update`、:py:meth:`~Model.insert`、:py:meth:`~Model.delete`"
" などのテーブルレベルの操作はクラスメソッドとして実装されています。:py:meth:`~Model.save` や "
":py:meth:`~Model.delete_instance` などの行レベルの操作は、インスタンスメソッドとして実装されています。"

#: ../../peewee/api.rst ../../peewee/playhouse.rst
msgid "パラメータ"
msgstr ""

#: ../../peewee/api.rst:22
msgid ""
"Initialize the model, assigning the given key/values to the appropriate "
"fields."
msgstr "モデルを初期化し、与えられたキー/バリューを適切なフィールドに割り当てます。"

#: ../../peewee/api.rst:25 ../../peewee/api.rst:319 ../../peewee/api.rst:338
#: ../../peewee/api.rst:1141 ../../peewee/api.rst:1546
#: ../../peewee/api.rst:1672 ../../peewee/api.rst:1697
#: ../../peewee/api.rst:1762 ../../peewee/api.rst:2459
#: ../../peewee/api.rst:2620 ../../peewee/api.rst:2885
#: ../../peewee/api.rst:3019 ../../peewee/hacks.rst:79
#: ../../peewee/playhouse.rst:510 ../../peewee/playhouse.rst:535
#: ../../peewee/playhouse.rst:1260 ../../peewee/playhouse.rst:1476
#: ../../peewee/playhouse.rst:2004 ../../peewee/playhouse.rst:2091
#: ../../peewee/playhouse.rst:2488 ../../peewee/playhouse.rst:2744
#: ../../peewee/playhouse.rst:2826 ../../peewee/playhouse.rst:2938
#: ../../peewee/playhouse.rst:2974 ../../peewee/playhouse.rst:2997
#: ../../peewee/playhouse.rst:3121 ../../peewee/playhouse.rst:3141
#: ../../peewee/playhouse.rst:3158 ../../peewee/playhouse.rst:3233
#: ../../peewee/playhouse.rst:4146 ../../peewee/playhouse.rst:4416
#: ../../peewee/playhouse.rst:4440 ../../peewee/querying.rst:750
msgid "Example:"
msgstr "例:"

#: ../../peewee/api.rst:38
msgid ""
"A list of model classes, field instances, functions or expressions. If no"
" argument is provided, all columns for the given model will be selected."
msgstr "モデルクラス、フィールドインスタンス、関数、または式のリスト。引数が指定されていない場合は、指定されたモデルのすべての列が選択されます。"

#: ../../peewee/api.rst ../../peewee/playhouse.rst
msgid "戻り値の型"
msgstr ""

#: ../../peewee/api.rst:41
msgid "a :py:class:`SelectQuery` for the given :py:class:`Model`."
msgstr "指定された :py:class:`Model` の :py:class*`SelectQuery` 。"

#: ../../peewee/api.rst:43
msgid "Examples of selecting all columns (default):"
msgstr "すべてのカラムを選択する例（デフォルト）:"

#: ../../peewee/api.rst:49
msgid ""
"Example of selecting all columns on *Tweet* and the parent model, *User*."
" When the ``user`` foreign key is accessed on a *Tweet* instance no "
"additional query will be needed (see :ref:`N+1 <nplusone>` for more "
"details):"
msgstr "*Tweet* のすべてのカラムと親モデル *User* を選択する例"

#: ../../peewee/api.rst:63
msgid "mapping of field-name to expression"
msgstr "フィールド名から式へのマッピング"

#: ../../peewee/api.rst:64
msgid "an :py:class:`UpdateQuery` for the given :py:class:`Model`"
msgstr "指定された :py:class:`Model` の :py:class:`UpdateQuery`"

#: ../../peewee/api.rst:66
msgid "Example showing users being marked inactive if their registration expired:"
msgstr "ユーザーの登録が失効した場合に非アクティブとマークされていることを示す例:"

#: ../../peewee/api.rst:74
msgid "Example showing an atomic update:"
msgstr "アトミック更新を示す例:"

#: ../../peewee/api.rst:81
msgid ""
"When an update query is executed, the number of rows modified will be "
"returned."
msgstr "更新クエリが実行されると、変更された行の数が返されます。"

#: ../../peewee/api.rst:85
msgid ""
"Insert a new row into the database. If any fields on the model have "
"default values, these values will be used if the fields are not "
"explicitly set in the ``insert`` dictionary."
msgstr ""
"新しい行をデータベースに挿入します。モデルのいずれかのフィールドにデフォルト値がある場合、フィールドが ``insert`` "
"ディクショナリに明示的に設定されていなければデフォルト値が使用されます。"

#: ../../peewee/api.rst:89
msgid "mapping of field or field-name to expression."
msgstr "フィールドまたはフィールド名から式へのマッピング。"

#: ../../peewee/api.rst:90 ../../peewee/api.rst:139 ../../peewee/api.rst:184
msgid "an :py:class:`InsertQuery` for the given :py:class:`Model`."
msgstr "指定された :py:class:`Model`の :py:class:`InsertQuery`"

#: ../../peewee/api.rst:92
msgid "Example showing creation of a new user:"
msgstr "新しいユーザーの作成を示す例："

#: ../../peewee/api.rst:99
msgid "You can also use :py:class:`Field` objects as the keys:"
msgstr ":py:class:`Field` オブジェクトをキーとして使用することもできます:"

#: ../../peewee/api.rst:105
msgid ""
"If you have a model with a default value on one of the fields, and that "
"field is not specified in the ``insert`` parameter, the default will be "
"used:"
msgstr ""
"いずれかのフィールドにデフォルト値を持つモデルがあり、そのフィールドが ``insert`` "
"パラメーターで指定されていない場合は、デフォルトが使用されます:"

#: ../../peewee/api.rst:118
msgid ""
"When an insert query is executed on a table with an auto-incrementing "
"primary key, the primary key of the new row will be returned."
msgstr "オートインクリメントの主キーを持つテーブルで挿入クエリを実行すると、新しい行の主キーが返されます。"

#: ../../peewee/api.rst:122
msgid ""
"Insert multiple rows at once. The ``rows`` parameter must be an iterable "
"that yields dictionaries. As with :py:meth:`~Model.insert`, fields that "
"are not specified in the dictionary will use their default value, if one "
"exists."
msgstr ""
"一度に複数の行を挿入します。``rows`` パラメーターは、辞書でなければなりません。:py:meth:`Model.insert` "
"の場合と同様に、ディクショナリに指定されていないフィールドは、デフォルト値（存在する場合）を使用します。"

#: ../../peewee/api.rst:128
msgid ""
"Due to the nature of bulk inserts, each row must contain the same fields."
" The following will not work:"
msgstr "一括挿入の性質上、各行には同じフィールドが含まれている必要があります。以下は動作しません:"

#: ../../peewee/api.rst:138
msgid "An iterable containing dictionaries of field-name-to-value."
msgstr "フィールド名と値がセットのディクショナリを含むリスト。"

#: ../../peewee/api.rst:141
msgid "Example of inserting multiple Users:"
msgstr "複数のユーザーを挿入する例:"

#: ../../peewee/api.rst:151
msgid ""
"Because the ``rows`` parameter can be an arbitrary iterable, you can also"
" use a generator:"
msgstr "``rows`` パラメータは任意の反復可能なものにすることができるため、ジェネレータを使用することもできます:"

#: ../../peewee/api.rst:162
msgid ""
"If you are using SQLite, your SQLite library must be version 3.7.11 or "
"newer to take advantage of bulk inserts."
msgstr "SQLiteを使用している場合、一括挿入を利用するには、SQLiteライブラリのバージョンが3.7.11以降である必要があります。"

#: ../../peewee/api.rst:166
msgid ""
"SQLite has a default limit of 999 bound variables per statement. This "
"limit can be modified at compile-time or at run-time, **but** if "
"modifying at run-time, you can only specify a *lower* value than the "
"default limit."
msgstr "SQLiteには、ステートメントごとに999のバウンド変数のデフォルト制限があります。この制限はコンパイル時または実行時に変更できますが、実行時に変更する場合はデフォルトの制限よりも小さい値しか指定できません。"

#: ../../peewee/api.rst:171
msgid "For more information, check out the following SQLite documents:"
msgstr ""

#: ../../peewee/api.rst:173
msgid ""
"`Max variable number limit "
"<https://www.sqlite.org/limits.html#max_variable_number>`_"
msgstr ""

#: ../../peewee/api.rst:174
msgid "`Changing run-time limits <https://www.sqlite.org/c3ref/limit.html>`_"
msgstr ""

#: ../../peewee/api.rst:175
msgid "`SQLite compile-time flags <https://www.sqlite.org/compile.html>`_"
msgstr ""

#: ../../peewee/api.rst:179
msgid ""
"Insert rows into the table using a query as the data source. This API "
"should be used for *INSERT INTO...SELECT FROM* queries."
msgstr ""

#: ../../peewee/api.rst:182
msgid "The field objects to map the selected data into."
msgstr ""

#: ../../peewee/api.rst:183
msgid "The source of the new rows."
msgstr ""

#: ../../peewee/api.rst:186
msgid "Example of inserting data across tables for denormalization purposes:"
msgstr ""

#: ../../peewee/api.rst:200 ../../peewee/api.rst:1754
msgid "a :py:class:`DeleteQuery` for the given :py:class:`Model`."
msgstr ""

#: ../../peewee/api.rst:202
msgid "Example showing the deletion of all inactive users:"
msgstr ""

#: ../../peewee/api.rst:210
msgid ""
"This method performs a delete on the *entire table*. To delete a single "
"instance, see :py:meth:`Model.delete_instance`."
msgstr ""

#: ../../peewee/api.rst:215
msgid "a string SQL expression"
msgstr ""

#: ../../peewee/api.rst:216
msgid "any number of parameters to interpolate"
msgstr ""

#: ../../peewee/api.rst:217
msgid "a :py:class:`RawQuery` for the given ``Model``"
msgstr ""

#: ../../peewee/api.rst:219
msgid "Example selecting rows from the User table:"
msgstr ""

#: ../../peewee/api.rst:228
msgid ""
"Generally the use of ``raw`` is reserved for those cases where you can "
"significantly optimize a select query. It is useful for select queries "
"since it will return instances of the model."
msgstr ""

#: ../../peewee/api.rst:234
msgid "key/value pairs of model attributes"
msgstr ""

#: ../../peewee/api.rst:237
msgid ""
"Example showing the creation of a user (a row will be added to the "
"database):"
msgstr ""

#: ../../peewee/api.rst:245
msgid "The create() method is a shorthand for instantiate-then-save."
msgstr ""

#: ../../peewee/api.rst:249
msgid "a list of query expressions, e.g. ``User.username == 'foo'``"
msgstr ""

#: ../../peewee/api.rst:250 ../../peewee/api.rst:1351
msgid ":py:class:`Model` instance or raises ``DoesNotExist`` exception"
msgstr ""

#: ../../peewee/api.rst:252
msgid ""
"Get a single row from the database that matches the given query. Raises a"
" ``<model-class>.DoesNotExist`` if no rows are returned:"
msgstr ""

#: ../../peewee/api.rst:259
msgid ""
"This method is also exposed via the :py:class:`SelectQuery`, though it "
"takes no parameters:"
msgstr ""

#: ../../peewee/api.rst:274
msgid ""
"The :py:meth:`~Model.get` method is shorthand for selecting with a limit "
"of 1. It has the added behavior of raising an exception when no matching "
"row is found. If more than one row is found, the first row returned by "
"the database cursor will be used."
msgstr ""

#: ../../peewee/api.rst:281
msgid "A dictionary of values to set on newly-created model instances."
msgstr ""

#: ../../peewee/api.rst:282
msgid ""
"Django-style filters specifying which model to get, and what values to "
"apply to new instances."
msgstr ""

#: ../../peewee/api.rst ../../peewee/playhouse.rst
msgid "戻り値"
msgstr ""

#: ../../peewee/api.rst:283
msgid ""
"A 2-tuple containing the model instance and a boolean indicating whether "
"the instance was created."
msgstr ""

#: ../../peewee/api.rst:285
msgid ""
"This function attempts to retrieve a model instance based on the provided"
" filters. If no matching model can be found, a new model is created using"
" the parameters specified by the filters and any values in the "
"``defaults`` dictionary."
msgstr ""

#: ../../peewee/api.rst:287
msgid ""
"Use care when calling ``get_or_create`` with ``autocommit=False``, as the"
" ``get_or_create()`` method will call :py:meth:`Database.atomic` to "
"create either a transaction or savepoint."
msgstr ""

#: ../../peewee/api.rst:289
msgid "Example **without** ``get_or_create``:"
msgstr ""

#: ../../peewee/api.rst:304
msgid "Equivalent code using ``get_or_create``:"
msgstr ""

#: ../../peewee/api.rst:315
msgid ":py:class:`ModelAlias` instance"
msgstr ""

#: ../../peewee/api.rst:317
msgid "The :py:meth:`alias` method is used to create self-joins."
msgstr ""

#: ../../peewee/api.rst:329
msgid ""
"When using a :py:class:`ModelAlias` in a join, you must explicitly "
"specify the join condition."
msgstr ""

#: ../../peewee/api.rst:333
msgid ""
"If set to ``True``, the method will check for the existence of the table "
"before attempting to create."
msgstr ""

#: ../../peewee/api.rst:336
msgid ""
"Create the table for the given model, along with any constraints and "
"indexes."
msgstr ""

#: ../../peewee/api.rst:347
msgid ""
"If set to ``True``, the query will check for the existence of the table "
"before attempting to remove."
msgstr ""

#: ../../peewee/api.rst:349
msgid "Drop table with ``CASCADE`` option."
msgstr ""

#: ../../peewee/api.rst:351
msgid "Drop the table for the given model."
msgstr ""

#: ../../peewee/api.rst:359
msgid "A list of queries required to create the table and indexes."
msgstr ""

#: ../../peewee/api.rst:363
msgid "Whether to force execution of an insert"
msgstr ""

#: ../../peewee/api.rst:364
msgid ""
"A list of fields to persist -- when supplied, only the given fields will "
"be persisted."
msgstr ""

#: ../../peewee/api.rst:367
msgid ""
"Save the given instance, creating or updating depending on whether it has"
" a primary key.  If ``force_insert=True`` an *INSERT* will be issued "
"regardless of whether or not the primary key exists."
msgstr ""

#: ../../peewee/api.rst:371
msgid "Example showing saving a model instance:"
msgstr ""

#: ../../peewee/api.rst:381
msgid ""
"Delete this instance and anything that depends on it, optionally updating"
" those that have nullable dependencies"
msgstr ""

#: ../../peewee/api.rst:383
msgid ""
"If doing a recursive delete, delete all dependent objects regardless of "
"whether it could be updated to NULL"
msgstr ""

#: ../../peewee/api.rst:386
msgid ""
"Delete the given instance.  Any foreign keys set to cascade on delete "
"will be deleted automatically.  For more programmatic control, you can "
"call with recursive=True, which will delete any non-nullable related "
"models (those that *are* nullable will be set to NULL).  If you wish to "
"delete all dependencies regardless of whether they are nullable, set "
"``delete_nullable=True``."
msgstr ""

#: ../../peewee/api.rst:393
msgid "example:"
msgstr ""

#: ../../peewee/api.rst:401
msgid "Search models related via a nullable foreign key"
msgstr ""

#: ../../peewee/api.rst:404
msgid ""
"Generate a list of queries of dependent models.  Yields a 2-tuple "
"containing the query and corresponding foreign key field.  Useful for "
"searching dependencies of a model, i.e. things that would be orphaned in "
"the event of a delete."
msgstr ""

#: ../../peewee/api.rst:410
msgid "Return a list of fields that were manually set."
msgstr ""

#: ../../peewee/api.rst:415
msgid ""
"If you just want to persist modified fields, you can call "
"``model.save(only=model.dirty_fields)``."
msgstr ""

#: ../../peewee/api.rst:418
msgid ""
"If you **always** want to only save a model's dirty fields, you can use "
"the Meta option ``only_save_dirty = True``. Then, any time you call "
":py:meth:`Model.save()`, by default only the dirty fields will be saved, "
"e.g."
msgstr ""

#: ../../peewee/api.rst:435
msgid "Return whether any fields were manually set."
msgstr ""

#: ../../peewee/api.rst:441
msgid ""
"This method provides a hook for performing model initialization *after* "
"the row data has been populated."
msgstr ""

#: ../../peewee/api.rst:448 ../../peewee/models.rst:76
#: ../../peewee/playhouse.rst:2549
msgid "Fields"
msgstr "フィールド"

#: ../../peewee/api.rst:452
msgid "The base class from which all other field types extend."
msgstr ""

#: ../../peewee/api.rst:454
msgid "whether this column can accept ``None`` or ``NULL`` values"
msgstr ""

#: ../../peewee/api.rst:455
msgid "whether to create an index for this column when creating the table"
msgstr ""

#: ../../peewee/api.rst:456
msgid "whether to create a unique index for this column when creating the table"
msgstr ""

#: ../../peewee/api.rst:457
msgid "specify a \"verbose name\" for this field, useful for metadata purposes"
msgstr ""

#: ../../peewee/api.rst:458
msgid "specify some instruction text for the usage/meaning of this field"
msgstr ""

#: ../../peewee/api.rst:459
msgid ""
"column name to use for underlying storage, useful for compatibility with "
"legacy databases"
msgstr ""

#: ../../peewee/api.rst:460
msgid "a value to use as an uninitialized default"
msgstr ""

#: ../../peewee/api.rst:461
msgid "an iterable of 2-tuples mapping ``value`` to ``display``"
msgstr ""

#: ../../peewee/api.rst:462
msgid "whether to use this as the primary key for the table"
msgstr ""

#: ../../peewee/api.rst:463
msgid "name of sequence (if backend supports it)"
msgstr ""

#: ../../peewee/api.rst:464
msgid "a list of constraints, e.g. ``[Check('price > 0')]``."
msgstr ""

#: ../../peewee/api.rst:465
msgid "name of schema (if backend supports it)"
msgstr ""

#: ../../peewee/api.rst:466
msgid ""
"named attributes containing values that may pertain to specific field "
"subclasses, such as \"max_length\" or \"decimal_places\""
msgstr ""

#: ../../peewee/api.rst:470
msgid ""
"Attribute used to map this field to a column type, e.g. \"string\" or "
"\"datetime\""
msgstr ""

#: ../../peewee/api.rst:474
msgid "Boolean flag indicating if the field is attached to a model class."
msgstr ""

#: ../../peewee/api.rst:478
msgid "The model the field belongs to. *Only applies to bound fields.*"
msgstr ""

#: ../../peewee/api.rst:482
msgid "The name of the field. *Only applies to bound fields.*"
msgstr ""

#: ../../peewee/api.rst:486
msgid "python data type to prep for storage in the database"
msgstr ""

#: ../../peewee/api.rst:491
msgid "data coming from the backend storage"
msgstr ""

#: ../../peewee/api.rst:496
msgid ""
"This method is a shorthand that is used, by default, by both ``db_value``"
" and ``python_value``.  You can usually get away with just implementing "
"this."
msgstr ""

#: ../../peewee/api.rst:499
msgid "arbitrary data from app or backend"
msgstr ""

#: ../../peewee/api.rst:504
msgid "Stores: integers"
msgstr ""

#: ../../peewee/api.rst:510
msgid "Stores: big integers"
msgstr ""

#: ../../peewee/api.rst:516
msgid "Stores: auto-incrementing integer fields suitable for use as primary key."
msgstr ""

#: ../../peewee/api.rst:522
msgid "Stores: floating-point numbers"
msgstr ""

#: ../../peewee/api.rst:528
msgid "Stores: double-precision floating-point numbers"
msgstr ""

#: ../../peewee/api.rst:534
msgid "Stores: decimal numbers, using python standard library ``Decimal`` objects"
msgstr ""

#: ../../peewee/api.rst:536 ../../peewee/api.rst:551
msgid "Additional attributes and values:"
msgstr ""

#: ../../peewee/api.rst:539
msgid "``max_digits``"
msgstr ""

#: ../../peewee/api.rst:539
msgid "``10``"
msgstr ""

#: ../../peewee/api.rst:540
msgid "``decimal_places``"
msgstr ""

#: ../../peewee/api.rst:540
msgid "``5``"
msgstr ""

#: ../../peewee/api.rst:541
msgid "``auto_round``"
msgstr ""

#: ../../peewee/api.rst:541
msgid "``False``"
msgstr ""

#: ../../peewee/api.rst:542
msgid "``rounding``"
msgstr ""

#: ../../peewee/api.rst:542
msgid "``decimal.DefaultContext.rounding``"
msgstr ""

#: ../../peewee/api.rst:549
msgid "Stores: small strings (0-255 bytes)"
msgstr ""

#: ../../peewee/api.rst:554 ../../peewee/models.rst:173
#: ../../peewee/models.rst:175
msgid "``max_length``"
msgstr ""

#: ../../peewee/api.rst:554
msgid "``255``"
msgstr ""

#: ../../peewee/api.rst:561
msgid "Stores: arbitrarily large strings"
msgstr ""

#: ../../peewee/api.rst:567
msgid "Stores: python ``datetime.datetime`` instances"
msgstr ""

#: ../../peewee/api.rst:569
msgid ""
"Accepts a special parameter ``formats``, which contains a list of formats"
" the datetime can be encoded with.  The default behavior is:"
msgstr ""

#: ../../peewee/api.rst:579 ../../peewee/api.rst:626 ../../peewee/api.rst:663
msgid "If the incoming value does not match a format, it will be returned as-is"
msgstr ""

#: ../../peewee/api.rst:585
msgid ""
"An expression suitable for extracting the year, for example to retrieve "
"all blog posts from 2013:"
msgstr ""

#: ../../peewee/api.rst:594
msgid "An expression suitable for extracting the month from a stored date."
msgstr ""

#: ../../peewee/api.rst:598
msgid "An expression suitable for extracting the day from a stored date."
msgstr ""

#: ../../peewee/api.rst:602
msgid "An expression suitable for extracting the hour from a stored time."
msgstr ""

#: ../../peewee/api.rst:606
msgid "An expression suitable for extracting the minute from a stored time."
msgstr ""

#: ../../peewee/api.rst:610
msgid "An expression suitable for extracting the second from a stored time."
msgstr ""

#: ../../peewee/api.rst:614
msgid "Stores: python ``datetime.date`` instances"
msgstr ""

#: ../../peewee/api.rst:616
msgid ""
"Accepts a special parameter ``formats``, which contains a list of formats"
" the date can be encoded with.  The default behavior is:"
msgstr ""

#: ../../peewee/api.rst:632
msgid ""
"An expression suitable for extracting the year, for example to retrieve "
"all people born in 1980:"
msgstr ""

#: ../../peewee/api.rst:641
msgid "Same as :py:attr:`~DateField.year`, except extract month."
msgstr ""

#: ../../peewee/api.rst:645
msgid "Same as :py:attr:`~DateField.year`, except extract day."
msgstr ""

#: ../../peewee/api.rst:649
msgid "Stores: python ``datetime.time`` instances"
msgstr ""

#: ../../peewee/api.rst:651
msgid ""
"Accepts a special parameter ``formats``, which contains a list of formats"
" the time can be encoded with.  The default behavior is:"
msgstr ""

#: ../../peewee/api.rst:669
msgid ""
"Extract the hour from a time, for example to retreive all events "
"occurring in the evening:"
msgstr ""

#: ../../peewee/api.rst:678
msgid "Same as :py:attr:`~TimeField.hour`, except extract minute."
msgstr ""

#: ../../peewee/api.rst:682
msgid "Same as :py:attr:`~TimeField.hour`, except extract second.."
msgstr ""

#: ../../peewee/api.rst:686
msgid "Stores: python ``datetime.datetime`` instances (stored as integers)"
msgstr ""

#: ../../peewee/api.rst:688
msgid ""
"Accepts a special parameter ``resolution``, which is a power-of-10 up to "
"``10^6``. This allows sub-second precision while still using an "
":py:class:`IntegerField` for storage. Default is ``1`` (second "
"precision)."
msgstr ""

#: ../../peewee/api.rst:692
msgid ""
"Also accepts a boolean parameter ``utc``, used to indicate whether the "
"timestamps should be UTC. Default is ``False``."
msgstr ""

#: ../../peewee/api.rst:695
msgid ""
"Finally, the field ``default`` is the current timestamp. If you do not "
"want this behavior, then explicitly pass in ``default=None``."
msgstr ""

#: ../../peewee/api.rst:700
msgid "Stores: ``True`` / ``False``"
msgstr ""

#: ../../peewee/api.rst:706
msgid "Store arbitrary binary data."
msgstr ""

#: ../../peewee/api.rst:710
msgid "Store ``UUID`` values."
msgstr ""

#: ../../peewee/api.rst:712
msgid "Currently this field is only supported by :py:class:`PostgresqlDatabase`."
msgstr ""

#: ../../peewee/api.rst:716
msgid ""
"Intended to be used only with SQLite. Since data-types are not enforced, "
"you can declare fields without *any* data-type. It is also common for "
"SQLite virtual tables to use meta-columns or untyped columns, so for "
"those cases as well you may wish to use an untyped field."
msgstr ""

#: ../../peewee/api.rst:718
msgid ""
"Accepts a special ``coerce`` parameter, a function that takes a value "
"coming from the database and converts it into the appropriate Python "
"type."
msgstr ""

#: ../../peewee/api.rst:720
msgid "Currently this field is only supported by :py:class:`SqliteDatabase`."
msgstr ""

#: ../../peewee/api.rst:724
msgid "Stores: relationship to another model"
msgstr ""

#: ../../peewee/api.rst:726
msgid ""
"related :py:class:`Model` class or the string 'self' if declaring a self-"
"referential foreign key"
msgstr ""

#: ../../peewee/api.rst:727
msgid "attribute to expose on related model"
msgstr ""

#: ../../peewee/api.rst:728
msgid "on delete behavior, e.g. ``on_delete='CASCADE'``."
msgstr ""

#: ../../peewee/api.rst:729
msgid "on update behavior."
msgstr ""

#: ../../peewee/api.rst:730
msgid ""
"the field (or field name) on ``rel_model`` the foreign key references. "
"Defaults to the primary key field for ``rel_model``."
msgstr ""

#: ../../peewee/api.rst:753
msgid ""
"Foreign keys do not have a particular ``db_field`` as they will take "
"their field type depending on the type of primary key on the model they "
"are related to."
msgstr ""

#: ../../peewee/api.rst:757
msgid ""
"If you manually specify a ``to_field``, that field must be either a "
"primary key or have a unique constraint."
msgstr ""

#: ../../peewee/api.rst:762
msgid ""
"Specify a composite primary key for a model.  Unlike the other fields, a "
"composite key is defined in the model's ``Meta`` class after the fields "
"have been defined.  It takes as parameters the string names of the fields"
" to use as the primary key:"
msgstr ""

#: ../../peewee/api.rst:780
msgid "Query Types"
msgstr "クエリの種類"

#: ../../peewee/api.rst:784
msgid ""
"The parent class from which all other query classes are derived. While "
"you will not deal with :py:class:`Query` directly in your code, it "
"implements some methods that are common across all query types."
msgstr ""

#: ../../peewee/api.rst:790 ../../peewee/api.rst:997
msgid "a list of one or more expressions"
msgstr ""

#: ../../peewee/api.rst:791 ../../peewee/api.rst:829
msgid "a :py:class:`Query` instance"
msgstr ""

#: ../../peewee/api.rst:793
msgid "Example selection users where the username is equal to 'somebody':"
msgstr ""

#: ../../peewee/api.rst:799
msgid ""
"Example selecting tweets made by users who are either editors or "
"administrators:"
msgstr ""

#: ../../peewee/api.rst:807
msgid "Example of deleting tweets by users who are no longer active:"
msgstr ""

#: ../../peewee/api.rst:817
msgid ""
":py:meth:`~SelectQuery.where` calls are chainable.  Multiple calls will "
"be \"AND\"-ed together."
msgstr ""

#: ../../peewee/api.rst:822
msgid ""
"the model to join on.  there must be a :py:class:`ForeignKeyField` "
"between the current ``query context`` and the model passed in."
msgstr ""

#: ../../peewee/api.rst:824
msgid ""
"allows the type of ``JOIN`` used to be specified explicitly, one of "
"``JOIN.INNER``, ``JOIN.LEFT_OUTER``, ``JOIN.FULL``, ``JOIN.RIGHT_OUTER``,"
" or ``JOIN.CROSS``."
msgstr ""

#: ../../peewee/api.rst:827
msgid ""
"if multiple foreign keys exist between two models, this parameter is the "
"ForeignKeyField to join on."
msgstr ""

#: ../../peewee/api.rst:831
msgid ""
"Generate a ``JOIN`` clause from the current ``query context`` to the "
"``model`` passed in, and establishes ``model`` as the new ``query "
"context``."
msgstr ""

#: ../../peewee/api.rst:834
msgid ""
"Example selecting tweets and joining on user in order to restrict to only"
" those tweets made by \"admin\" users:"
msgstr ""

#: ../../peewee/api.rst:841
msgid ""
"Example selecting users and joining on a particular foreign key field. "
"See the :py:ref:`example app <example-app>` for a real-life usage:"
msgstr ""

#: ../../peewee/api.rst:850
msgid "model to switch the ``query context`` to."
msgstr ""

#: ../../peewee/api.rst:853
msgid ""
"Switches the ``query context`` to the given model.  Raises an exception "
"if the model has not been selected or joined on previously.  Useful for "
"performing multiple joins from a single table."
msgstr ""

#: ../../peewee/api.rst:857
msgid "The following example selects from blog and joins on both entry and user:"
msgstr ""

#: ../../peewee/api.rst:865
msgid "A string to alias the result of this query"
msgstr ""

#: ../../peewee/api.rst:868
msgid "Assign an alias to given query, which can be used as part of a subquery."
msgstr ""

#: ../../peewee/api.rst:878
msgid "Execute the given query"
msgstr ""

#: ../../peewee/api.rst:884
msgid "return the row as a tuple or a single value"
msgstr ""

#: ../../peewee/api.rst:885
msgid ""
"attempt to coerce the selected value to the appropriate data-type based "
"on it's associated Field type (assuming one exists)."
msgstr ""

#: ../../peewee/api.rst:890
msgid ""
"Provide a way to retrieve single values from select queries, for instance"
" when performing an aggregation."
msgstr ""

#: ../../peewee/api.rst:898
msgid ""
"This example illustrates the use of the `convert` argument. When using a "
"SQLite database, datetimes are stored as strings. To select the max "
"datetime, and have it *returned* as a datetime, we will specify "
"``convert=True``."
msgstr ""

#: ../../peewee/api.rst:914
msgid ""
"By far the most complex of the query classes available in peewee. It "
"supports all clauses commonly associated with select queries."
msgstr ""

#: ../../peewee/api.rst:917
msgid "Methods on the select query can be chained together."
msgstr ""

#: ../../peewee/api.rst:919
msgid ""
"``SelectQuery`` implements an :py:meth:`~SelectQuery.__iter__` method, "
"allowing it to be iterated to return model instances."
msgstr ""

#: ../../peewee/api.rst:922
msgid "a :py:class:`Model` class to perform query on"
msgstr ""

#: ../../peewee/api.rst:923
msgid "a list of models, fields, functions or expressions"
msgstr ""

#: ../../peewee/api.rst:925
msgid ""
"If no selection is provided, it will default to all the fields of the "
"given model."
msgstr ""

#: ../../peewee/api.rst:928
msgid ""
"Example selecting some user instances from the database.  Only the ``id``"
" and ``username`` columns are selected.  When iterated, will return "
"instances of the ``User`` model:"
msgstr ""

#: ../../peewee/api.rst:938
msgid ""
"Example selecting users and additionally the number of tweets made by the"
" user. The ``User`` instances returned will have an additional attribute,"
" 'count', that corresponds to the number of tweets made:"
msgstr ""

#: ../../peewee/api.rst:951
msgid ""
"a list of expressions, which can be model classes or fields. if left "
"blank, will default to all the fields of the given model."
msgstr ""

#: ../../peewee/api.rst:953 ../../peewee/api.rst:970 ../../peewee/api.rst:980
#: ../../peewee/api.rst:998 ../../peewee/api.rst:1018 ../../peewee/api.rst:1101
#: ../../peewee/api.rst:1114 ../../peewee/api.rst:1128
#: ../../peewee/api.rst:1136 ../../peewee/api.rst:1152
#: ../../peewee/api.rst:1185 ../../peewee/api.rst:1193
#: ../../peewee/api.rst:1201 ../../peewee/api.rst:1272
msgid ":py:class:`SelectQuery`"
msgstr ""

#: ../../peewee/api.rst:956
msgid ""
"Usually the selection will be specified when the instance is created. "
"This method simply exists for the case when you want to modify the SELECT"
" clause independent of instantiating a query."
msgstr ""

#: ../../peewee/api.rst:967
msgid ""
"one or more expressions, for example :py:class:`Model` or "
":py:class:`SelectQuery` instance(s). if left blank, will default to the "
"table of the given model."
msgstr ""

#: ../../peewee/api.rst:979
msgid ""
"a list of expressions, which can be model classes or individual field "
"instances"
msgstr ""

#: ../../peewee/api.rst:982
msgid ""
"Group by one or more columns.  If a model class is provided, all the "
"fields on that model class will be used."
msgstr ""

#: ../../peewee/api.rst:985
msgid ""
"Example selecting users, joining on tweets, and grouping by the user so a"
" count of tweets can be calculated for each user:"
msgstr ""

#: ../../peewee/api.rst:1000
msgid ""
"Here is the above example selecting users and tweet counts, but "
"restricting the results to those users who have created 100 or more "
"tweets:"
msgstr ""

#: ../../peewee/api.rst:1013
msgid ""
"a list of fields, calls to ``field.[asc|desc]()`` or one or more "
"expressions. If called without any arguments, any pre-existing ``ORDER "
"BY`` clause will be removed."
msgstr ""

#: ../../peewee/api.rst:1016
msgid ""
"When called with ``extend=True``, Peewee will append any to the pre-"
"existing ``ORDER BY`` rather than overwriting it."
msgstr ""

#: ../../peewee/api.rst:1020
msgid "Example of ordering users by username:"
msgstr ""

#: ../../peewee/api.rst:1026
msgid ""
"Example of selecting tweets and ordering them first by user, then newest "
"first:"
msgstr ""

#: ../../peewee/api.rst:1038
msgid ""
"You can also use ``+`` and ``-`` prefixes to indicate ascending or "
"descending order if you prefer:"
msgstr ""

#: ../../peewee/api.rst:1049
msgid ""
"A more complex example ordering users by the number of tweets made "
"(greatest to least), then ordered by username in the event of a tie:"
msgstr ""

#: ../../peewee/api.rst:1061
msgid "Example of removing a pre-existing ``ORDER BY`` clause:"
msgstr ""

#: ../../peewee/api.rst:1074
msgid "One or more :py:class:`Window` instances."
msgstr ""

#: ../../peewee/api.rst:1076
msgid "Add one or more window definitions to this query."
msgstr ""

#: ../../peewee/api.rst:1091
msgid "limit results to ``num`` rows"
msgstr ""

#: ../../peewee/api.rst:1095
msgid "offset results by ``num`` rows"
msgstr ""

#: ../../peewee/api.rst:1099
msgid "a 1-based page number to use for paginating results"
msgstr ""

#: ../../peewee/api.rst:1100
msgid "number of results to return per-page"
msgstr ""

#: ../../peewee/api.rst:1103
msgid "Shorthand for applying a ``LIMIT`` and ``OFFSET`` to the query."
msgstr ""

#: ../../peewee/api.rst:1105
msgid "Page indices are **1-based**, so page 1 is the first page."
msgstr ""

#: ../../peewee/api.rst:1113
msgid "See notes."
msgstr ""

#: ../../peewee/api.rst:1116
msgid ""
"Indicates that this query should only return distinct rows. Results in a "
"``SELECT DISTINCT`` query."
msgstr ""

#: ../../peewee/api.rst:1120
msgid ""
"The value for ``is_distinct`` should either be a boolean, in which case "
"the query will (or won't) be `DISTINCT`."
msgstr ""

#: ../../peewee/api.rst:1123
msgid ""
"You can specify a list of one or more expressions to generate a "
"``DISTINCT ON`` query, e.g. ``.distinct([Model.col1, Model.col2])``."
msgstr ""

#: ../../peewee/api.rst:1130
msgid ""
"Indicate that this query should lock rows for update.  If ``nowait`` is "
"``True`` then the database will raise an ``OperationalError`` if it "
"cannot obtain the lock."
msgstr ""

#: ../../peewee/api.rst:1138
msgid ""
"Indicates that this query shoudl lock rows. A more generic version of the"
" :py:meth:`~SelectQuery.for_update` method."
msgstr ""

#: ../../peewee/api.rst:1148
msgid "You do not need to include the word *FOR*."
msgstr ""

#: ../../peewee/api.rst:1154
msgid ""
"Flag this query indicating it should only attempt to reconstruct a single"
" model instance for every row returned by the cursor.  If multiple tables"
" were queried, the columns returned are patched directly onto the single "
"model instance."
msgstr ""

#: ../../peewee/api.rst:1158
msgid ""
"Generally this method is useful for speeding up the time needed to "
"construct model instances given a database cursor."
msgstr ""

#: ../../peewee/api.rst:1163
msgid ""
"this can provide a significant speed improvement when doing simple "
"iteration over a large result set."
msgstr ""

#: ../../peewee/api.rst:1168
msgid "``iterable``"
msgstr ""

#: ../../peewee/api.rst:1170
msgid ""
"By default peewee will cache rows returned by the cursor.  This is to "
"prevent things like multiple iterations, slicing and indexing from "
"triggering extra queries.  When you are iterating over a large number of "
"rows, however, this cache can take up a lot of memory. Using "
"``iterator()`` will save memory by not storing all the returned model "
"instances."
msgstr ""

#: ../../peewee/api.rst:1187 ../../peewee/api.rst:1823
msgid ""
"Flag this query indicating it should simply return raw tuples from the "
"cursor. This method is useful when you either do not want or do not need "
"full model instances."
msgstr ""

#: ../../peewee/api.rst:1195
msgid ""
"Flag this query indicating it should simply return dictionaries from the "
"cursor. This method is useful when you either do not want or do not need "
"full model instances."
msgstr ""

#: ../../peewee/api.rst:1203
msgid "This method provides one way to avoid the **N+1** query problem."
msgstr ""

#: ../../peewee/api.rst:1205
msgid ""
"Consider a webpage where you wish to display a list of users and all of "
"their associated tweets. You could approach this problem by listing the "
"users, then for each user executing a separate query to retrieve their "
"tweets. This is the **N+1** behavior, because the number of queries "
"varies depending on the number of users. Conventional wisdom is that it "
"is preferable to execute fewer queries. Peewee provides several ways to "
"avoid this problem."
msgstr ""

#: ../../peewee/api.rst:1212
msgid ""
"You can use the :py:func:`prefetch` helper, which uses ``IN`` clauses to "
"retrieve the tweets for the listed users."
msgstr ""

#: ../../peewee/api.rst:1215
msgid ""
"Another method is to select both the user and the tweet data in a single "
"query, then de-dupe the users, aggregating the tweets in the process."
msgstr ""

#: ../../peewee/api.rst:1218
msgid "The raw column data might appear like this:"
msgstr ""

#: ../../peewee/api.rst:1230
msgid ""
"We can infer from the ``JOIN`` clause that the user data will be "
"duplicated, and therefore by de-duping the users, we can collect their "
"tweets in one go and iterate over the users and tweets transparently."
msgstr ""

#: ../../peewee/api.rst:1257
msgid ""
"Be sure that you specify an ``ORDER BY`` clause that ensures duplicated "
"data will appear in consecutive rows."
msgstr ""

#: ../../peewee/api.rst:1261
msgid ""
"You can specify arbitrarily complex joins, though for more complex "
"queries it may be more efficient to use :py:func:`prefetch`. In short, "
"try both and see what works best for your data-set."
msgstr ""

#: ../../peewee/api.rst:1265
msgid ""
"For more information, see the :ref:`nplusone` document and the :ref"
":`aggregate-rows` sub-section."
msgstr ""

#: ../../peewee/api.rst:1269
msgid ""
"related :py:class:`Model` on which to perform aggregation, must be linked"
" by :py:class:`ForeignKeyField`."
msgstr ""

#: ../../peewee/api.rst:1271
msgid "the type of aggregation to use, e.g. ``fn.Count(Tweet.id).alias('count')``"
msgstr ""

#: ../../peewee/api.rst:1274
msgid ""
"Annotate a query with an aggregation performed on a related model, for "
"example, \"get a list of users with the number of tweets for each\":"
msgstr ""

#: ../../peewee/api.rst:1281
msgid ""
"If ``aggregation`` is None, it will default to "
"``fn.Count(related_model.id).alias('count')`` but can be anything:"
msgstr ""

#: ../../peewee/api.rst:1290
msgid ""
"If the ``ForeignKeyField`` is ``nullable``, then a ``LEFT OUTER`` join "
"may need to be used::"
msgstr ""

#: ../../peewee/api.rst:1301
msgid ""
"a function specifying what aggregation to perform, for example "
"``fn.Max(Tweet.created_date)``."
msgstr ""

#: ../../peewee/api.rst:1304
msgid ""
"Method to look at an aggregate of rows using a given function and return "
"a scalar value, such as the count of all rows or the average value of a "
"particular column."
msgstr ""

#: ../../peewee/api.rst:1310 ../../peewee/api.rst:1327
msgid "Remove any limit or offset clauses from the query before counting."
msgstr ""

#: ../../peewee/api.rst:1314
msgid ""
"If the query has a GROUP BY, DISTINCT, LIMIT, or OFFSET clause, then the "
":py:meth:`~SelectQuery.wrapped_count` method will be used instead."
msgstr ""

#: ../../peewee/api.rst:1330
msgid ""
"Wrap the count query in a subquery.  Additional overhead but will give "
"correct counts when performing ``DISTINCT`` queries or those with ``GROUP"
" BY`` clauses."
msgstr ""

#: ../../peewee/api.rst:1335
msgid ""
":py:meth:`~SelectQuery.count` will automatically default to "
":py:meth:`~SelectQuery.wrapped_count` in the event the query is distinct "
"or has a grouping."
msgstr ""

#: ../../peewee/api.rst:1340
msgid ""
"boolean whether the current query will return any rows.  uses an "
"optimized lookup, so use this rather than :py:meth:`~SelectQuery.get`."
msgstr ""

#: ../../peewee/api.rst:1353
msgid ""
"Get a single row from the database that matches the given query.  Raises "
"a ``<model-class>.DoesNotExist`` if no rows are returned:"
msgstr ""

#: ../../peewee/api.rst:1364
msgid ""
"This method is also exposed via the :py:class:`Model` api, in which case "
"it accepts arguments that are translated to the where clause:"
msgstr ""

#: ../../peewee/api.rst:1367
msgid "user = User.get(User.active == True, User.username == username)"
msgstr ""

#: ../../peewee/api.rst:1371
msgid ""
"Return the first *n* query results after applying a limit of ``n`` "
"records."
msgstr ""

#: ../../peewee/api.rst:1373 ../../peewee/api.rst:1389
msgid ":py:class:`Model` instance, list or ``None`` if no results"
msgstr ""

#: ../../peewee/api.rst:1375
msgid ""
"Fetch the first *n* rows from a query. Behind-the-scenes, a ``LIMIT n`` "
"is applied. The results of the query are then cached on the query result "
"wrapper so subsequent calls to :py:meth:`~SelectQuery.first` will not "
"cause multiple queries."
msgstr ""

#: ../../peewee/api.rst:1380
msgid ""
"If only one row is requested (default behavior), then the return-type "
"will be either a model instance or ``None``."
msgstr ""

#: ../../peewee/api.rst:1383
msgid ""
"If multiple rows are requested, the return type will either be a list of "
"one to n model instances, or ``None`` if no results are found."
msgstr ""

#: ../../peewee/api.rst:1388
msgid "Return the first *n* query results."
msgstr ""

#: ../../peewee/api.rst:1391
msgid ""
"Fetch the first *n* rows from a query. No ``LIMIT`` is applied to the "
"query, so the :py:meth:`~SelectQuery.peek` has slightly different "
"semantics from :py:meth:`~SelectQuery.first`, which ensures no more than "
"*n* rows are requested. The ``peek`` method, on the other hand, retains "
"the ability to fetch the entire result set withouth issuing additional "
"queries."
msgstr ""

#: ../../peewee/api.rst:1400
msgid ":py:class:`QueryResultWrapper`"
msgstr ""

#: ../../peewee/api.rst:1402
msgid ""
"Executes the query and returns a :py:class:`QueryResultWrapper` for "
"iterating over the result set.  The results are managed internally by the"
" query and whenever a clause is added that would possibly alter the "
"result set, the query is marked for re-execution."
msgstr ""

#: ../../peewee/api.rst:1409
msgid "Executes the query and returns populated model instances:"
msgstr ""

#: ../../peewee/api.rst:1418
msgid ""
"Return the number of items in the result set of this query. If all you "
"need is the count of items and do not intend to do anything with the "
"results, call :py:meth:`~SelectQuery.count`."
msgstr ""

#: ../../peewee/api.rst:1421
msgid ""
"The ``SELECT`` query will be executed and the result set will be loaded. "
"If you want to obtain the number of results without also loading the "
"query, use :py:meth:`~SelectQuery.count`."
msgstr ""

#: ../../peewee/api.rst:1427
msgid "Either an index or a ``slice`` object."
msgstr ""

#: ../../peewee/api.rst:1429
msgid ""
"Return the model instance(s) at the requested indices. To get the first "
"model, for instance:"
msgstr ""

#: ../../peewee/api.rst:1440 ../../peewee/api.rst:1458
#: ../../peewee/api.rst:1474 ../../peewee/api.rst:1490
msgid "Either a :py:class:`SelectQuery` or a :py:class:`CompoundSelect`"
msgstr ""

#: ../../peewee/api.rst:1441 ../../peewee/api.rst:1459
#: ../../peewee/api.rst:1475 ../../peewee/api.rst:1491
msgid ":py:class:`CompoundSelect`"
msgstr ""

#: ../../peewee/api.rst:1443
msgid ""
"Create a ``UNION`` query with the right-hand object. The result will "
"contain all values from both the left and right queries."
msgstr ""

#: ../../peewee/api.rst:1454
msgid ""
"SQLite does not allow ``ORDER BY`` or ``LIMIT`` clauses on the components"
" of a compound query, however SQLite does allow these clauses on the "
"final, compound result. This applies to ``UNION (ALL)``, ``INTERSECT``, "
"and ``EXCEPT``."
msgstr ""

#: ../../peewee/api.rst:1461
msgid ""
"Create an ``INTERSECT`` query. The result will contain values that are in"
" both the left and right queries."
msgstr ""

#: ../../peewee/api.rst:1477
msgid ""
"Create an ``EXCEPT`` query. The result will contain values that are in "
"the left-hand query but not in the right-hand query."
msgstr ""

#: ../../peewee/api.rst:1493
msgid ""
"Create an symmetric difference query. The result will contain values that"
" are in either the left-hand query or the right-hand query, but not both."
msgstr ""

#: ../../peewee/api.rst:1509
msgid ":py:class:`Model` class on which to perform update"
msgstr ""

#: ../../peewee/api.rst:1510
msgid "mapping of field/value pairs containing columns and values to update"
msgstr ""

#: ../../peewee/api.rst:1512
msgid "Example in which users are marked inactive if their registration expired:"
msgstr ""

#: ../../peewee/api.rst:1519
msgid "Example of an atomic update:"
msgstr ""

#: ../../peewee/api.rst:1531 ../../peewee/api.rst:1643
#: ../../peewee/api.rst:1747 ../../peewee/api.rst:1839
msgid "Performs the query"
msgstr ""

#: ../../peewee/api.rst:1535 ../../peewee/api.rst:1686
#: ../../peewee/api.rst:1751
msgid ""
"A list of model classes, field instances, functions or expressions. If no"
" argument is provided, all columns for the given model will be selected. "
"To clear any existing values, pass in ``None``."
msgstr ""

#: ../../peewee/api.rst:1538
msgid "a :py:class:`UpdateQuery` for the given :py:class:`Model`."
msgstr ""

#: ../../peewee/api.rst:1540
msgid ""
"Add a ``RETURNING`` clause to the query, which will cause the ``UPDATE`` "
"to compute return values based on each row that was actually updated."
msgstr ""

#: ../../peewee/api.rst:1542
msgid ""
"When the query is executed, rather than returning the number of rows "
"updated, an iterator will be returned that yields the updated objects."
msgstr ""

#: ../../peewee/api.rst:1544 ../../peewee/api.rst:1695
#: ../../peewee/api.rst:1760
msgid "Currently only :py:class:`PostgresqlDatabase` supports this feature."
msgstr ""

#: ../../peewee/api.rst:1561 ../../peewee/api.rst:1711
#: ../../peewee/api.rst:1777
msgid ""
"For more information, check out :ref:`the RETURNING clause docs "
"<returning-clause>`."
msgstr ""

#: ../../peewee/api.rst:1565 ../../peewee/api.rst:1573
msgid ":py:class:`UpdateQuery`"
msgstr ""

#: ../../peewee/api.rst:1567 ../../peewee/api.rst:1575
msgid ""
"This method should only be used in conjunction with a call to "
":py:meth:`~UpdateQuery.returning`."
msgstr ""

#: ../../peewee/api.rst:1569
msgid ""
"When the updated results are returned, they will be returned as row "
"tuples."
msgstr ""

#: ../../peewee/api.rst:1577
msgid ""
"When the updated results are returned, they will be returned as "
"dictionaries mapping column to value."
msgstr ""

#: ../../peewee/api.rst:1581
msgid ""
"Add a SQL ``ON CONFLICT`` clause with the specified action to the given "
"``UPDATE`` query. `Valid actions "
"<https://www.sqlite.org/lang_conflict.html>`_ are:"
msgstr ""

#: ../../peewee/api.rst:1583 ../../peewee/api.rst:1655
msgid "ROLLBACK"
msgstr ""

#: ../../peewee/api.rst:1584 ../../peewee/api.rst:1656
msgid "ABORT"
msgstr ""

#: ../../peewee/api.rst:1585 ../../peewee/api.rst:1657
msgid "FAIL"
msgstr ""

#: ../../peewee/api.rst:1586 ../../peewee/api.rst:1658
msgid "IGNORE"
msgstr ""

#: ../../peewee/api.rst:1587 ../../peewee/api.rst:1659
msgid "REPLACE"
msgstr ""

#: ../../peewee/api.rst:1589
msgid "Specifying ``None`` for the action will execute a normal ``UPDATE`` query."
msgstr ""

#: ../../peewee/api.rst:1591 ../../peewee/api.rst:1663
msgid "This feature is only available on SQLite databases."
msgstr ""

#: ../../peewee/api.rst:1596
msgid "Creates an ``InsertQuery`` instance for the given model."
msgstr ""

#: ../../peewee/api.rst:1598
msgid "A mapping of either field or field-name to value."
msgstr ""

#: ../../peewee/api.rst:1599
msgid ""
"An iterable of dictionaries containing a mapping of field or field-name "
"to value."
msgstr ""

#: ../../peewee/api.rst:1601
msgid ""
"A list of field objects to insert data into (only used in combination "
"with the ``query`` parameter)."
msgstr ""

#: ../../peewee/api.rst:1602
msgid "A :py:class:`SelectQuery` to use as the source of data."
msgstr ""

#: ../../peewee/api.rst:1603
msgid ""
"Check that every column referenced in the insert query has a "
"corresponding field on the model. If validation is enabled and then "
"fails, a ``KeyError`` is raised."
msgstr ""

#: ../../peewee/api.rst:1605
msgid "Basic example:"
msgstr ""

#: ../../peewee/api.rst:1614
msgid "Example inserting multiple rows:"
msgstr ""

#: ../../peewee/api.rst:1625
msgid "Example inserting using a query as the data source:"
msgstr ""

#: ../../peewee/api.rst:1647
msgid ""
"Perform an *INSERT OR REPLACE* query with SQLite. MySQL databases will "
"issue a *REPLACE* query. Currently this feature is not supported for "
"Postgres databases, but the 9.5 syntax will be added soon."
msgstr ""

#: ../../peewee/api.rst:1649
msgid "This feature is only available on SQLite and MySQL databases."
msgstr ""

#: ../../peewee/api.rst:1653
msgid ""
"Add a SQL ``ON CONFLICT`` clause with the specified action to the given "
"``INSERT`` query. Specifying ``REPLACE`` is equivalent to using the "
":py:meth:`~InsertQuery.upsert` method. `Valid actions "
"<https://www.sqlite.org/lang_conflict.html>`_ are:"
msgstr ""

#: ../../peewee/api.rst:1661
msgid "Specifying ``None`` for the action will execute a normal ``INSERT`` query."
msgstr ""

#: ../../peewee/api.rst:1667
msgid ""
"By default, when doing bulk INSERTs, peewee will not return the list of "
"generated primary keys. However, if the database supports returning "
"primary keys via ``INSERT ... RETURNING``, this method instructs peewee "
"to return the generated list of IDs."
msgstr ""

#: ../../peewee/api.rst:1670
msgid ""
"Currently only PostgreSQL supports this behavior. While other databases "
"support bulk inserts, they will simply return ``True`` instead."
msgstr ""

#: ../../peewee/api.rst:1689
msgid "a :py:class:`InsertQuery` for the given :py:class:`Model`."
msgstr ""

#: ../../peewee/api.rst:1691
msgid ""
"Add a ``RETURNING`` clause to the query, which will cause the ``INSERT`` "
"to compute return values based on each row that was inserted."
msgstr ""

#: ../../peewee/api.rst:1693
msgid ""
"When the query is executed, rather than returning the primary key of the "
"new row(s), an iterator will be returned that yields the inserted "
"objects."
msgstr ""

#: ../../peewee/api.rst:1715 ../../peewee/api.rst:1723
msgid ":py:class:`InsertQuery`"
msgstr ""

#: ../../peewee/api.rst:1717 ../../peewee/api.rst:1725
msgid ""
"This method should only be used in conjunction with a call to "
":py:meth:`~InsertQuery.returning`."
msgstr ""

#: ../../peewee/api.rst:1719
msgid ""
"When the inserted results are returned, they will be returned as row "
"tuples."
msgstr ""

#: ../../peewee/api.rst:1727
msgid ""
"When the inserted results are returned, they will be returned as "
"dictionaries mapping column to value."
msgstr ""

#: ../../peewee/api.rst:1731
msgid "Creates a *DELETE* query for the given model."
msgstr ""

#: ../../peewee/api.rst:1734
msgid ""
"DeleteQuery will *not* traverse foreign keys or ensure that constraints "
"are obeyed, so use it with care."
msgstr ""

#: ../../peewee/api.rst:1737
msgid "Example deleting users whose account is inactive:"
msgstr ""

#: ../../peewee/api.rst:1756
msgid ""
"Add a ``RETURNING`` clause to the query, which will cause the ``DELETE`` "
"to compute return values based on each row that was removed from the "
"database."
msgstr ""

#: ../../peewee/api.rst:1758
msgid ""
"When the query is executed, rather than returning the number of rows "
"deleted, an iterator will be returned that yields the deleted objects."
msgstr ""

#: ../../peewee/api.rst:1781 ../../peewee/api.rst:1789
#: ../../peewee/querying.rst:234
msgid ":py:class:`DeleteQuery`"
msgstr ""

#: ../../peewee/api.rst:1783 ../../peewee/api.rst:1791
msgid ""
"This method should only be used in conjunction with a call to "
":py:meth:`~DeleteQuery.returning`."
msgstr ""

#: ../../peewee/api.rst:1785
msgid ""
"When the deleted results are returned, they will be returned as row "
"tuples."
msgstr ""

#: ../../peewee/api.rst:1793
msgid ""
"When the deleted results are returned, they will be returned as "
"dictionaries mapping column to value."
msgstr ""

#: ../../peewee/api.rst:1798
msgid ""
"Allows execution of an arbitrary query and returns instances of the model"
" via a :py:class:`QueryResultsWrapper`."
msgstr ""

#: ../../peewee/api.rst:1802
msgid ""
"Generally you will only need this for executing highly optimized SELECT "
"queries."
msgstr ""

#: ../../peewee/api.rst:1806
#, python-format
msgid ""
"If you are executing a parameterized query, you must use the correct "
"interpolation string for your database.  SQLite uses ``'?'`` and most "
"others use ``'%s'``."
msgstr ""

#: ../../peewee/api.rst:1810
msgid "Example selecting users with a given username:"
msgstr ""

#: ../../peewee/api.rst:1821 ../../peewee/api.rst:1829
msgid ":py:class:`RawQuery`"
msgstr ""

#: ../../peewee/api.rst:1831
msgid ""
"Flag this query indicating it should simply return raw dicts from the "
"cursor. This method is useful when you either do not want or do not need "
"full model instances."
msgstr ""

#: ../../peewee/api.rst:1837
msgid ""
"a :py:class:`QueryResultWrapper` for iterating over the result set.  The "
"results are instances of the given model."
msgstr ""

#: ../../peewee/api.rst:1844
msgid "Compound select query."
msgstr ""

#: ../../peewee/api.rst:1846
msgid ""
"The type of model to return, by default the model class of the ``lhs`` "
"query."
msgstr ""

#: ../../peewee/api.rst:1848
msgid ""
"Left-hand query, either a :py:class:`SelectQuery` or a "
":py:class:`CompoundQuery`."
msgstr ""

#: ../../peewee/api.rst:1849
msgid "A string used to join the two queries, for example ``'UNION'``."
msgstr ""

#: ../../peewee/api.rst:1850
msgid ""
"Right query, either a :py:class:`SelectQuery` or a "
":py:class:`CompoundQuery`."
msgstr ""

#: ../../peewee/api.rst:1855
msgid ":py:class:`SelectQuery` instance"
msgstr ""

#: ../../peewee/api.rst:1856
msgid ""
"one or more :py:class:`SelectQuery` instances to prefetch for ``sq``. You"
" can also pass models, but they will be converted into SelectQueries. If "
"you wish to specify a particular model to join against, you can pass a "
"2-tuple of ``(query_or_model, join_model)``."
msgstr ""

#: ../../peewee/api.rst:1860
msgid ":py:class:`SelectQuery` with related instances pre-populated"
msgstr ""

#: ../../peewee/api.rst:1862
msgid ""
"Pre-fetch the appropriate instances from the subqueries and apply them to"
" their corresponding parent row in the outer query. This function will "
"eagerly load the related instances specified in the subqueries. This is a"
" technique used to save doing O(n) queries for n rows, and rather is O(k)"
" queries for *k* subqueries."
msgstr ""

#: ../../peewee/api.rst:1868
msgid ""
"For example, consider you have a list of users and want to display all "
"their tweets:"
msgstr ""

#: ../../peewee/api.rst:1886
msgid ""
"You can prefetch an arbitrary number of items.  For instance, suppose we "
"have a photo site, User -> Photo -> (Comments, Tags).  That is, users can"
" post photos, and these photos can have tags and comments on them.  If we"
" wanted to fetch a list of users, all their photos, and all the comments "
"and tags on the photos:"
msgstr ""

#: ../../peewee/api.rst:1912
msgid "Subqueries must be related by foreign key and can be arbitrarily deep"
msgstr ""

#: ../../peewee/api.rst:1914
msgid ""
"For more information, see the :ref:`nplusone` document and the "
":ref:`prefetch` sub-section."
msgstr ""

#: ../../peewee/api.rst:1917
msgid ""
":py:func:`prefetch` can use up lots of RAM when the result set is large, "
"and will not warn you if you are doing something dangerous, so it is up "
"to you to know when to use it.  Additionally, because of the semantics of"
" subquerying, there may be some cases when prefetch does not act as you "
"expect (for instance, when applying a ``LIMIT`` to subqueries, but there "
"may be others) -- please report anything you think is a bug to `github "
"<https://github.com/coleifer/peewee/issues>`_."
msgstr ""

#: ../../peewee/api.rst:1926
msgid "Database and its subclasses"
msgstr "データベースとそのサブクエリ"

#: ../../peewee/api.rst:1930 ../../peewee/api.rst:2057
msgid "the name of the database (or filename if using sqlite)"
msgstr ""

#: ../../peewee/api.rst:1931
msgid "whether to store connections in a threadlocal"
msgstr ""

#: ../../peewee/api.rst:1932
msgid ""
"automatically commit every query executed by calling "
":py:meth:`~Database.execute`"
msgstr ""

#: ../../peewee/api.rst:1933
msgid ""
"a mapping of :py:attr:`~Field.db_field` to database column type, e.g. "
"'string' => 'varchar'"
msgstr ""

#: ../../peewee/api.rst:1934
msgid "a mapping of operations understood by the querycompiler to expressions"
msgstr ""

#: ../../peewee/api.rst:1935
msgid "automatically rollback when an exception occurs while executing a query."
msgstr ""

#: ../../peewee/api.rst:1936
msgid "use the Cython speedups module to improve performance of some queries."
msgstr ""

#: ../../peewee/api.rst:1937 ../../peewee/api.rst:2058
msgid "any arbitrary parameters to pass to the database driver when connecting"
msgstr ""

#: ../../peewee/api.rst:1939
msgid ""
"The ``connect_kwargs`` dictionary is used for vendor-specific parameters "
"that will be passed back directly to your database driver, allowing you "
"to specify the ``user``, ``host`` and ``password``, for instance. For "
"more information and examples, see the :ref:`vendor-specific parameters "
"document <vendor-specific-parameters>`."
msgstr ""

#: ../../peewee/api.rst:1942
msgid ""
"If your database name is not known when the class is declared, you can "
"pass ``None`` in as the database name which will mark the database as "
"\"deferred\" and any attempt to connect while in this state will raise an"
" exception.  To initialize your database, call the "
":py:meth:`Database.init` method with the database name."
msgstr ""

#: ../../peewee/api.rst:1948
msgid ""
"For an in-depth discussion of run-time database configuration, see the "
":ref:`deferring_initialization` section."
msgstr ""

#: ../../peewee/api.rst:1950
msgid ""
"A high-level API for working with the supported database engines. The "
"database class:"
msgstr ""

#: ../../peewee/api.rst:1952
msgid "Manages the underlying database connection."
msgstr ""

#: ../../peewee/api.rst:1953
msgid "Executes queries."
msgstr ""

#: ../../peewee/api.rst:1954
msgid "Manage transactions and savepoints."
msgstr ""

#: ../../peewee/api.rst:1955
msgid "Create and drop tables and indexes."
msgstr ""

#: ../../peewee/api.rst:1956
msgid "Introspect the database."
msgstr ""

#: ../../peewee/api.rst:1960
msgid ""
"Whether to issue a commit after executing a select query.  With some "
"engines can prevent implicit transactions from piling up."
msgstr ""

#: ../../peewee/api.rst:1965
msgid "A class suitable for compiling queries"
msgstr ""

#: ../../peewee/api.rst:1969
msgid "Supported compound query operations."
msgstr ""

#: ../../peewee/api.rst:1973
msgid ""
"Whether ``UNION`` (or other compound ``SELECT`` queries) allow "
"parentheses around the queries."
msgstr ""

#: ../../peewee/api.rst:1977
msgid "Whether the database supports ``DISTINCT ON`` statements."
msgstr ""

#: ../../peewee/api.rst:1981
msgid "Whether the database supports cascading drop table queries."
msgstr ""

#: ../../peewee/api.rst:1985
msgid ""
"A mapping of field types to database column types, e.g. ``{'primary_key':"
" 'SERIAL'}``"
msgstr ""

#: ../../peewee/api.rst:1989
msgid "Whether the given backend enforces foreign key constraints."
msgstr ""

#: ../../peewee/api.rst:1993 ../../peewee/api.rst:1997
msgid "Whether the given backend supports selecting rows for update"
msgstr ""

#: ../../peewee/api.rst:2001
msgid ""
"Whether the database supports multiple ``VALUES`` clauses for ``INSERT`` "
"queries."
msgstr ""

#: ../../peewee/api.rst:2005
msgid ""
"Whether the database supports returning the primary key for newly "
"inserted rows."
msgstr ""

#: ../../peewee/api.rst:2009
msgid "The string used by the driver to interpolate query parameters"
msgstr ""

#: ../../peewee/api.rst:2013
msgid ""
"A mapping of operation codes to string operations, e.g. ``{OP.LIKE: 'LIKE"
" BINARY'}``"
msgstr ""

#: ../../peewee/api.rst:2017
msgid "The string used by the driver to quote names"
msgstr ""

#: ../../peewee/api.rst:2021
msgid ""
"Table names that are reserved by the backend -- if encountered in the "
"application a warning will be issued."
msgstr ""

#: ../../peewee/api.rst:2026
msgid ""
"Whether the database supports ``RETURNING`` clauses for ``UPDATE``, "
"``INSERT`` and ``DELETE`` queries."
msgstr ""

#: ../../peewee/api.rst:2028
msgid "Currently only :py:class:`PostgresqlDatabase` supports this."
msgstr ""

#: ../../peewee/api.rst:2030
msgid "See the following for more information:"
msgstr ""

#: ../../peewee/api.rst:2032 ../../peewee/querying.rst:870
msgid ":py:meth:`UpdateQuery.returning`"
msgstr ""

#: ../../peewee/api.rst:2033 ../../peewee/querying.rst:871
msgid ":py:meth:`InsertQuery.returning`"
msgstr ""

#: ../../peewee/api.rst:2034 ../../peewee/querying.rst:872
msgid ":py:meth:`DeleteQuery.returning`"
msgstr ""

#: ../../peewee/api.rst:2038
msgid "Whether the given backend supports savepoints."
msgstr ""

#: ../../peewee/api.rst:2042
msgid "Whether the given backend supports sequences"
msgstr ""

#: ../../peewee/api.rst:2046
msgid ""
"Whether the given backend supports deleting rows using a subquery that "
"selects from the same table"
msgstr ""

#: ../../peewee/api.rst:2051
msgid "Whether the given backend supports window functions."
msgstr ""

#: ../../peewee/api.rst:2055
msgid ""
"This method is used to initialize a deferred database. For details on "
"configuring your database at run-time, see the "
":ref:`deferring_initialization` section."
msgstr ""

#: ../../peewee/api.rst:2062
msgid "Establishes a connection to the database"
msgstr ""

#: ../../peewee/api.rst:2065
msgid ""
"By default, connections will be stored on a threadlocal, ensuring "
"connections are not shared across threads. To disable this behavior, "
"initialize the database with ``threadlocals=False``."
msgstr ""

#: ../../peewee/api.rst:2069
msgid "Closes the connection to the database (if one is open)"
msgstr ""

#: ../../peewee/api.rst:2072
msgid ""
"If you initialized with ``threadlocals=True``, only a connection local to"
" the calling thread will be closed."
msgstr ""

#: ../../peewee/api.rst:2077
msgid ""
"Perform additional intialization on a newly-opened connection. For "
"example, if you are using SQLite you may want to enable foreign key "
"constraint enforcement (off by default)."
msgstr ""

#: ../../peewee/api.rst:2079
msgid "Here is how you might use this hook to load a SQLite extension:"
msgstr ""

#: ../../peewee/api.rst:2097
msgid "the database cursor used to perform the insert query"
msgstr ""

#: ../../peewee/api.rst:2098
msgid "the model class that was just created"
msgstr ""

#: ../../peewee/api.rst:2107
msgid ""
"an instance of :py:class:`QueryCompiler` using the field and op overrides"
" specified."
msgstr ""

#: ../../peewee/api.rst:2112
msgid "a :py:class:`Node` instance or subclass (e.g. a :py:class:`SelectQuery`)."
msgstr ""

#: ../../peewee/api.rst:2114
msgid ""
"The clause will be compiled into SQL then sent to the "
":py:meth:`~Database.execute_sql` method."
msgstr ""

#: ../../peewee/api.rst:2118
msgid "a string sql query"
msgstr ""

#: ../../peewee/api.rst:2119
msgid "a list or tuple of parameters to interpolate"
msgstr ""

#: ../../peewee/api.rst:2122
msgid ""
"You can configure whether queries will automatically commit by using the "
":py:meth:`~Database.set_autocommit` and "
":py:meth:`Database.get_autocommit` methods."
msgstr ""

#: ../../peewee/api.rst:2128
msgid ""
"Initiate a new transaction.  By default **not** implemented as this is "
"not part of the DB-API 2.0, but provided for API compatibility and to "
"allow SQLite users to specify the isolation level when beginning "
"transactions."
msgstr ""

#: ../../peewee/api.rst:2132
msgid "For SQLite users, the valid isolation levels for ``lock_type`` are:"
msgstr ""

#: ../../peewee/api.rst:2134 ../../peewee/api.rst:2368
msgid "``exclusive``"
msgstr ""

#: ../../peewee/api.rst:2135 ../../peewee/api.rst:2369
msgid "``immediate``"
msgstr ""

#: ../../peewee/api.rst:2136 ../../peewee/api.rst:2370
msgid "``deferred``"
msgstr ""

#: ../../peewee/api.rst:2138 ../../peewee/api.rst:2372
#: ../../peewee/playhouse.rst:2107 ../../peewee/playhouse.rst:3411
#: ../../peewee/playhouse.rst:3975
msgid "Example usage:"
msgstr ""

#: ../../peewee/api.rst:2157
msgid ""
"Call ``commit()`` on the active connection, committing the current "
"transaction."
msgstr ""

#: ../../peewee/api.rst:2161
msgid ""
"Call ``rollback()`` on the active connection, rolling back the current "
"transaction."
msgstr ""

#: ../../peewee/api.rst:2165
msgid "a boolean value indicating whether to turn on/off autocommit."
msgstr ""

#: ../../peewee/api.rst:2177
msgid ""
"a list of :py:class:`IndexMetadata` instances, representing the indexes "
"for the given table."
msgstr ""

#: ../../peewee/api.rst:2181
msgid ""
"a list of :py:class:`ColumnMetadata` instances, representing the columns "
"for the given table."
msgstr ""

#: ../../peewee/api.rst:2189
msgid ""
"a list of :py:class:`ForeignKeyMetadata` instances, representing the "
"foreign keys for the given table."
msgstr ""

#: ../../peewee/api.rst
msgid "rtype boolean"
msgstr ""

#: ../../peewee/api.rst:2197 ../../peewee/playhouse.rst:2557
msgid ":py:class:`Model` class."
msgstr ""

#: ../../peewee/api.rst:2198
msgid "If `True`, the table will not be created if it already exists."
msgstr ""

#: ../../peewee/api.rst:2201
msgid ""
"Unlike :py:meth:`Model.create_table`, this method does not create indexes"
" or constraints. This method will only create the table itself. If you "
"wish to create the table along with any indexes and constraints, use "
"either :py:meth:`Model.create_table` or "
":py:meth:`Database.create_tables`."
msgstr ""

#: ../../peewee/api.rst:2205
msgid ":py:class:`Model` table on which to create index"
msgstr ""

#: ../../peewee/api.rst:2206
msgid "field(s) to create index on (either field instances or field names)"
msgstr ""

#: ../../peewee/api.rst:2207
msgid "whether the index should enforce uniqueness"
msgstr ""

#: ../../peewee/api.rst:2211
msgid ":py:class:`Model` table on which to create foreign key constraint"
msgstr ""

#: ../../peewee/api.rst:2212
msgid ":py:class:`Field` object"
msgstr ""

#: ../../peewee/api.rst:2213
msgid "Name to give foreign key constraint."
msgstr ""

#: ../../peewee/api.rst:2215
msgid ""
"Manually create a foreign key constraint using an ``ALTER TABLE`` query. "
"This is primarily used when creating a circular foreign key dependency, "
"for example:"
msgstr ""

#: ../../peewee/api.rst:2245
msgid "name of sequence to create"
msgstr ""

#: ../../peewee/api.rst:2247 ../../peewee/api.rst:2259
msgid "only works with database engines that support sequences"
msgstr ""

#: ../../peewee/api.rst:2251
msgid ":py:class:`Model` table to drop"
msgstr ""

#: ../../peewee/api.rst:2252
msgid "if ``True``, query will add a ``IF EXISTS`` clause"
msgstr ""

#: ../../peewee/api.rst:2253 ../../peewee/api.rst:2278
msgid "drop table with ``CASCADE`` option."
msgstr ""

#: ../../peewee/api.rst:2257
msgid "name of sequence to drop"
msgstr ""

#: ../../peewee/api.rst:2263 ../../peewee/api.rst:2276
msgid "A list of models."
msgstr ""

#: ../../peewee/api.rst:2264
msgid "Check first whether the table exists before attempting to create it."
msgstr ""

#: ../../peewee/api.rst:2266
msgid ""
"This method should be used for creating tables as it will resolve the "
"model dependency graph and ensure the tables are created in the correct "
"order. This method will also create any indexes and constraints defined "
"on the models."
msgstr ""

#: ../../peewee/api.rst:2268 ../../peewee/api.rst:2282
#: ../../peewee/database.rst:894 ../../peewee/playhouse.rst:1692
#: ../../peewee/playhouse.rst:3337 ../../peewee/playhouse.rst:3701
#: ../../peewee/playhouse.rst:3802 ../../peewee/playhouse.rst:3855
msgid "Usage:"
msgstr ""

#: ../../peewee/api.rst:2277
msgid "Check the table exists before attempting to drop it."
msgstr ""

#: ../../peewee/api.rst:2280
msgid ""
"This method should be used for dropping tables, as it will resolve the "
"model dependency graph and ensure the tables are dropped in the correct "
"order."
msgstr ""

#: ../../peewee/api.rst:2290
msgid ""
"Execute statements in either a transaction or a savepoint. The outer-most"
" call to *atomic* will use a transaction, and any subsequent nested calls"
" will use savepoints."
msgstr ""

#: ../../peewee/api.rst:2293
msgid ""
"Specify isolation level. This parameter only has effect on **SQLite "
"databases**, and furthermore, only affects the outer-most call to "
":py:meth:`~Database.atomic`. For more information, see "
":py:meth:`~Database.transaction`."
msgstr ""

#: ../../peewee/api.rst:2298
msgid "``atomic`` can be used as either a context manager or a decorator."
msgstr ""

#: ../../peewee/api.rst:2301
msgid ""
"For most use-cases, it makes the most sense to always use "
":py:meth:`~Database.atomic` when you wish to execute queries in a "
"transaction. The benefit of using ``atomic`` is that you do not need to "
"manually keep track of the transaction stack depth, as this will be "
"managed for you."
msgstr ""

#: ../../peewee/api.rst:2303 ../../peewee/api.rst:2338
#: ../../peewee/api.rst:2402
msgid "Context manager example code:"
msgstr ""

#: ../../peewee/api.rst:2317 ../../peewee/api.rst:2355
msgid "Decorator example code:"
msgstr ""

#: ../../peewee/api.rst:2328
msgid ""
"Execute statements in a transaction using either a context manager or "
"decorator. If an error is raised inside the wrapped block, the "
"transaction will be rolled back, otherwise statements are committed when "
"exiting. Transactions can also be explicitly rolled back or committed "
"within the transaction block by calling :py:meth:`~transaction.rollback` "
"or :py:meth:`~transaction.commit`. If you manually commit or roll back, a"
" new transaction will be started automatically."
msgstr ""

#: ../../peewee/api.rst:2332
msgid ""
"Nested blocks can be wrapped with ``transaction`` - the database will "
"keep a stack and only commit when it reaches the end of the outermost "
"function / block."
msgstr ""

#: ../../peewee/api.rst:2336
msgid "Specify isolation level, **SQLite only**."
msgstr ""

#: ../../peewee/api.rst:2365
msgid ""
"SQLite users can specify the isolation level by specifying one of the "
"following values for ``transaction_type``:"
msgstr ""

#: ../../peewee/api.rst:2390
msgid ""
"Use :py:meth:`~Database.atomic` or :py:meth:`~Database.transaction` "
"instead."
msgstr ""

#: ../../peewee/api.rst:2394
msgid ""
"Execute statements in a savepoint using either a context manager or "
"decorator.  If an error is raised inside the wrapped block, the savepoint"
" will be rolled back, otherwise statements are committed when exiting. "
"Like :py:meth:`~Database.transaction`, a savepoint can also be explicitly"
" rolled-back or committed by calling :py:meth:`~savepoint.rollback` or "
":py:meth:`~savepoint.commit`. If you manually commit or roll back, a new "
"savepoint **will not** be created."
msgstr ""

#: ../../peewee/api.rst:2398
msgid "Savepoints can be thought of as nested transactions."
msgstr ""

#: ../../peewee/api.rst:2400
msgid "An optional string identifier for the savepoint."
msgstr ""

#: ../../peewee/api.rst:2420
msgid ""
"Create an :py:class:`ExecutionContext` context manager or decorator. "
"Blocks wrapped with an *ExecutionContext* will run using their own "
"connection. By default, the wrapped block will also run in a transaction,"
" although this can be disabled specifyin ``with_transaction=False``."
msgstr ""

#: ../../peewee/api.rst:2422
msgid ""
"For more explanation of :py:class:`ExecutionContext`, see the "
":ref:`advanced_connection_management` section."
msgstr ""

#: ../../peewee/api.rst:2424
msgid "ExecutionContext is very new and has not been tested extensively."
msgstr ""

#: ../../peewee/api.rst:2428
msgid ""
"Register a mapping of field overrides for the database class.  Used to "
"register custom fields or override the defaults."
msgstr ""

#: ../../peewee/api.rst:2431 ../../peewee/api.rst:2439
msgid "A mapping of :py:attr:`~Field.db_field` to column type"
msgstr ""

#: ../../peewee/api.rst:2435
msgid ""
"Register a mapping of operations understood by the QueryCompiler to their"
" SQL equivalent, e.g. ``{OP.EQ: '='}``.  Used to extend the types of "
"field comparisons."
msgstr ""

#: ../../peewee/api.rst:2443
msgid ""
"Return an expression suitable for extracting a date part from a date "
"field.  For instance, extract the year from a :py:class:`DateTimeField`."
msgstr ""

#: ../../peewee/api.rst:2446
msgid ""
"The date part attribute to retrieve.  Valid options are: \"year\", "
"\"month\", \"day\", \"hour\", \"minute\" and \"second\"."
msgstr ""

#: ../../peewee/api.rst:2448 ../../peewee/api.rst:2456
msgid "field instance storing a datetime, date or time."
msgstr ""

#: ../../peewee/api.rst:2453
msgid ""
"Return an expression suitable for truncating a date / datetime to the "
"given resolution. This can be used, for example, to group a collection of"
" timestamps by day."
msgstr ""

#: ../../peewee/api.rst:2455
msgid ""
"The date part to truncate to. Valid options are: \"year\", \"month\", "
"\"day\", \"hour\", \"minute\" and \"second\"."
msgstr ""

#: ../../peewee/api.rst:2470
msgid ""
":py:class:`Database` subclass that works with the ``sqlite3`` driver (or "
"``pysqlite2``). In addition to the default database parameters, "
":py:class:`SqliteDatabase` also accepts a *journal_mode* parameter which "
"will configure the journaling mode."
msgstr ""

#: ../../peewee/api.rst:2472
msgid ""
"If you have both ``sqlite3`` and ``pysqlite2`` installed on your system, "
"peewee will use whichever points at a newer version of SQLite."
msgstr ""

#: ../../peewee/api.rst:2474
msgid ""
"SQLite is unique among the databases supported by Peewee in that it "
"allows a high degree of customization by the host application. This means"
" you can do things like write custom functions or aggregates *in Python* "
"and then call them from your SQL queries. This feature, and many more, "
"are available through the :py:class:`SqliteExtDatabase`, part of "
"``playhouse.sqlite_ext``. I *strongly* recommend you use "
":py:class:`SqliteExtDatabase` as it exposes many of the features that "
"make SQLite so powerful."
msgstr ""

#: ../../peewee/api.rst:2476
msgid "Custom parameters:"
msgstr ""

#: ../../peewee/api.rst:2478
msgid "Journaling mode."
msgstr ""

#: ../../peewee/api.rst:2479
msgid ""
"List of 2-tuples containing ``PRAGMA`` statements to run against new "
"connections."
msgstr ""

#: ../../peewee/api.rst:2481
msgid ""
"SQLite allows run-time configuration of a number of parameters through "
"``PRAGMA`` statements (`documentation "
"<https://www.sqlite.org/pragma.html>`_). These statements are typically "
"run against a new database connection. To run one or more ``PRAGMA`` "
"statements against new connections, you can specify them as a list of "
"2-tuples containing the pragma name and value:"
msgstr ""

#: ../../peewee/api.rst:2496
msgid ""
":py:class:`Database` subclass that works with either \"MySQLdb\" or "
"\"pymysql\"."
msgstr ""

#: ../../peewee/api.rst:2508
msgid ":py:class:`Database` subclass that works with the \"psycopg2\" driver"
msgstr ""

#: ../../peewee/api.rst:2530
msgid ""
"Control whether the ``UNICODE`` and ``UNICODEARRAY`` psycopg2 extensions "
"are loaded automatically."
msgstr ""

#: ../../peewee/api.rst:2533
msgid "Transaction, Savepoint and ExecutionContext"
msgstr "トランザクション、セーブポイントおよびExecutionContext"

#: ../../peewee/api.rst:2535
msgid ""
"The easiest way to create transactions and savepoints is to use "
":py:meth:`Database.atomic`. The :py:meth:`~Database.atomic` method will "
"create a transaction or savepoint depending on the level of nesting."
msgstr ""

#: ../../peewee/api.rst:2547
msgid ""
"Context manager that encapsulates a database transaction. Statements "
"executed within the wrapped block will be committed at the end of the "
"block unless an exception occurs, in which case any changes will be "
"rolled back."
msgstr ""

#: ../../peewee/api.rst:2549
msgid ""
"Transactions should not be nested as this could lead to unpredictable "
"behavior in the event of an exception in a nested block. If you wish to "
"use nested transactions, use the :py:meth:`~Database.atomic` method, "
"which will create a transaction at the outer-most layer and use "
"savepoints for nested blocks."
msgstr ""

#: ../../peewee/api.rst:2551
msgid ""
"In practice you should not create :py:class:`transaction` objects "
"directly, but rather use the :py:meth:`Database.transaction` method."
msgstr ""

#: ../../peewee/api.rst:2555
msgid "Manually commit any pending changes and begin a new transaction."
msgstr ""

#: ../../peewee/api.rst:2559
msgid "Manually roll-back any pending changes and begin a new transaction."
msgstr ""

#: ../../peewee/api.rst:2563
msgid ""
"Context manager that encapsulates a savepoint (nested transaction). "
"Statements executed within the wrapped block will be committed at the end"
" of the block unless an exception occurs, in which case any changes will "
"be rolled back."
msgstr ""

#: ../../peewee/api.rst:2565
msgid ""
"Savepoints must be created within a transaction. It is recommended that "
"you use :py:meth:`~Database.atomic` instead of manually managing the "
"transaction+savepoint stack."
msgstr ""

#: ../../peewee/api.rst:2567
msgid ""
"In practice you should not create :py:class:`savepoint` objects directly,"
" but rather use the :py:meth:`Database.savepoint` method."
msgstr ""

#: ../../peewee/api.rst:2571
msgid ""
"Manually commit any pending changes. If the savepoint is manually "
"committed and additional changes are made, they will be executed in the "
"context of the outer block."
msgstr ""

#: ../../peewee/api.rst:2575
msgid ""
"Manually roll-back any pending changes. If the savepoint is manually "
"rolled-back and additional changes are made, they will be executed in the"
" context of the outer block."
msgstr ""

#: ../../peewee/api.rst:2579
msgid ""
"ExecutionContext provides a way to explicitly run statements in a "
"dedicated connection. Typically a single database connection is "
"maintained per-thread, but in some situations you may wish to explicitly "
"force a new, separate connection. To accomplish this, you can create an "
":py:class:`ExecutionContext`. Statements executed in the wrapped block "
"will be run in a transaction by default, though you can disable this by "
"specifying ``with_transaction=False``."
msgstr ""

#: ../../peewee/api.rst:2581
msgid ""
"Rather than instantiating ``ExecutionContext`` directly, use "
":py:meth:`Database.execution_context`."
msgstr ""

#: ../../peewee/api.rst:2583 ../../peewee/database.rst:213
#: ../../peewee/database.rst:317 ../../peewee/playhouse.rst:786
#: ../../peewee/playhouse.rst:2670 ../../peewee/playhouse.rst:2694
#: ../../peewee/playhouse.rst:2714
msgid "Example code:"
msgstr ""

#: ../../peewee/api.rst:2606
msgid ""
"For the duration of the wrapped block, all queries against the given "
"``models`` will use the specified ``database``. Optionally these queries "
"can be run outside a transaction by specifying "
"``with_transaction=False``."
msgstr ""

#: ../../peewee/api.rst:2608
msgid ""
"``Using`` provides, in short, a way to run queries on a list of models "
"using a manually specified database."
msgstr ""

#: ../../peewee/api.rst:2610 ../../peewee/playhouse.rst:3712
#: ../../peewee/playhouse.rst:3799
msgid "a :py:class:`Database` instance."
msgstr ""

#: ../../peewee/api.rst:2611
msgid "a list of :py:class:`Model` classes to use with the given database."
msgstr ""

#: ../../peewee/api.rst:2612
msgid "Whether the wrapped block should be run in a transaction."
msgstr ""

#: ../../peewee/api.rst:2616
msgid ""
"The :py:class:`Using` context manager does not do anything to manage the "
"database connections, so it the user's responsibility to make sure that "
"you close the database explicitly."
msgstr ""

#: ../../peewee/api.rst:2651
msgid "Metadata Types"
msgstr "メタデータの種類"

#: ../../peewee/api.rst:2657
msgid "The name of the index."
msgstr ""

#: ../../peewee/api.rst:2661
msgid "The SQL query used to generate the index."
msgstr ""

#: ../../peewee/api.rst:2665
msgid "A list of columns that are covered by the index."
msgstr ""

#: ../../peewee/api.rst:2669
msgid "A boolean value indicating whether the index has a unique constraint."
msgstr ""

#: ../../peewee/api.rst:2673
msgid "The name of the table containing this index."
msgstr ""

#: ../../peewee/api.rst:2679
msgid "The name of the column."
msgstr ""

#: ../../peewee/api.rst:2683
msgid "The data type of the column"
msgstr ""

#: ../../peewee/api.rst:2687
msgid "A boolean value indicating whether ``NULL`` is permitted in this column."
msgstr ""

#: ../../peewee/api.rst:2691
msgid "A boolean value indicating whether this column is a primary key."
msgstr ""

#: ../../peewee/api.rst:2695
msgid "The name of the table containing this column."
msgstr ""

#: ../../peewee/api.rst:2701
msgid "The column containing the foreign key (the \"source\")."
msgstr ""

#: ../../peewee/api.rst:2705
msgid "The table referenced by the foreign key."
msgstr ""

#: ../../peewee/api.rst:2709
msgid "The column referenced by the foreign key (on ``dest_table``)."
msgstr ""

#: ../../peewee/api.rst:2713
msgid "The name of the table containing this foreign key."
msgstr ""

#: ../../peewee/api.rst:2716
msgid "Misc"
msgstr "その他"

#: ../../peewee/api.rst:2720
msgid ""
"A helper class that will convert arbitrary function calls to SQL function"
" calls."
msgstr ""

#: ../../peewee/api.rst:2722
msgid ""
"To express functions in peewee, use the :py:class:`fn` object.  The way "
"it works is anything to the right of the \"dot\" operator will be treated"
" as a function.  You can pass that function arbitrary parameters which "
"can be other valid expressions."
msgstr ""

#: ../../peewee/api.rst:2726
msgid "For example:"
msgstr ""

#: ../../peewee/api.rst:2729
msgid "Peewee expression"
msgstr ""

#: ../../peewee/api.rst:2729
msgid "Equivalent SQL"
msgstr ""

#: ../../peewee/api.rst:2731
msgid "``fn.Count(Tweet.id).alias('count')``"
msgstr ""

#: ../../peewee/api.rst:2731
msgid "``Count(t1.\"id\") AS count``"
msgstr ""

#: ../../peewee/api.rst:2732
msgid "``fn.Lower(fn.Substr(User.username, 1, 1))``"
msgstr ""

#: ../../peewee/api.rst:2732
msgid "``Lower(Substr(t1.\"username\", 1, 1))``"
msgstr ""

#: ../../peewee/api.rst:2733
msgid "``fn.Rand().alias('random')``"
msgstr ""

#: ../../peewee/api.rst:2733
msgid "``Rand() AS random``"
msgstr ""

#: ../../peewee/api.rst:2734
msgid "``fn.Stddev(Employee.salary).alias('sdv')``"
msgstr ""

#: ../../peewee/api.rst:2734
msgid "``Stddev(t1.\"salary\") AS sdv``"
msgstr ""

#: ../../peewee/api.rst:2739
msgid "Basic support for SQL window functions."
msgstr ""

#: ../../peewee/api.rst:2741 ../../peewee/api.rst:2822
msgid "List of :py:class:`Node` instances to partition by."
msgstr ""

#: ../../peewee/api.rst:2742 ../../peewee/api.rst:2823
msgid "List of :py:class:`Node` instances to use for ordering."
msgstr ""

#: ../../peewee/api.rst:2743 ../../peewee/api.rst:2824
msgid "The start of the *frame* of the window query."
msgstr ""

#: ../../peewee/api.rst:2744 ../../peewee/api.rst:2825
msgid "The end of the *frame* of the window query."
msgstr ""

#: ../../peewee/api.rst:2745
msgid "A :py:class:`Window` instance to use for this aggregate."
msgstr ""

#: ../../peewee/api.rst:2747 ../../peewee/api.rst:2827
#: ../../peewee/models.rst:544 ../../peewee/playhouse.rst:3031
#: ../../peewee/playhouse.rst:3259 ../../peewee/playhouse.rst:3304
#: ../../peewee/playhouse.rst:3833
msgid "Examples:"
msgstr ""

#: ../../peewee/api.rst:2800
msgid ""
"Add fragments of SQL to a peewee query.  For example you might want to "
"reference an aliased name."
msgstr ""

#: ../../peewee/api.rst:2803
msgid "Arbitrary SQL string."
msgstr ""

#: ../../peewee/api.rst:2804
msgid "Arbitrary query parameters."
msgstr ""

#: ../../peewee/api.rst:2820
msgid "Create a ``WINDOW`` definition."
msgstr ""

#: ../../peewee/api.rst:2844
msgid ""
"Return an expression appropriate for passing in to the ``start`` or "
"``end`` clause of a :py:class:`Window` object. If ``value`` is not "
"provided, then it will be ``UNBOUNDED PRECEDING``."
msgstr ""

#: ../../peewee/api.rst:2850
msgid ""
"Return an expression appropriate for passing in to the ``start`` or "
"``end`` clause of a :py:class:`Window` object. If ``value`` is not "
"provided, then it will be ``UNBOUNDED FOLLOWING``."
msgstr ""

#: ../../peewee/api.rst:2856
msgid ""
"Used to reference a not-yet-created model class. Stands in as a "
"placeholder for the related model of a foreign key. Useful for circular "
"references."
msgstr ""

#: ../../peewee/api.rst:2877
msgid "Replace the placeholder with the correct model class."
msgstr ""

#: ../../peewee/api.rst:2881
msgid ""
"Proxy class useful for situations when you wish to defer the "
"initialization of an object.  For instance, you want to define your "
"models but you do not know what database engine you will be using until "
"runtime."
msgstr ""

#: ../../peewee/api.rst:2911
msgid "The object to proxy to."
msgstr ""

#: ../../peewee/api.rst:2913
msgid ""
"Once initialized, the attributes and methods on ``obj`` can be accessed "
"directly via the :py:class:`Proxy` instance."
msgstr ""

#: ../../peewee/api.rst:2918
msgid ""
"The :py:class:`Node` class is the parent class for all composable parts "
"of a query, and forms the basis of peewee's expression API. The following"
" classes extend :py:class:`Node`:"
msgstr ""

#: ../../peewee/api.rst:2920
msgid ""
":py:class:`SelectQuery`, :py:class:`UpdateQuery`, "
":py:class:`InsertQuery`, :py:class:`DeleteQuery`, and "
":py:class:`RawQuery`."
msgstr ""

#: ../../peewee/api.rst:2921
msgid ":py:class:`Field`"
msgstr ""

#: ../../peewee/api.rst:2922
msgid ":py:class:`Func` (and :py:func:`fn`)"
msgstr ""

#: ../../peewee/api.rst:2923
msgid ":py:class:`SQL`"
msgstr ""

#: ../../peewee/api.rst:2924
msgid ":py:class:`Expression`"
msgstr ""

#: ../../peewee/api.rst:2925
msgid ":py:class:`Param`"
msgstr ""

#: ../../peewee/api.rst:2926
msgid ":py:class:`Window`"
msgstr ""

#: ../../peewee/api.rst:2927
msgid ":py:class:`Clause`"
msgstr ""

#: ../../peewee/api.rst:2928
msgid ":py:class:`Entity`"
msgstr ""

#: ../../peewee/api.rst:2929
msgid ":py:class:`Check`"
msgstr ""

#: ../../peewee/api.rst:2931
msgid "Overridden operators:"
msgstr ""

#: ../../peewee/api.rst:2933
msgid ""
"Bitwise and- and or- (``&`` and ``|``): combine multiple nodes using the "
"given conjunction."
msgstr ""

#: ../../peewee/api.rst:2934
msgid ""
"``+``, ``-``, ``*``, ``/`` and ``^`` (add, subtract, multiply, divide and"
" exclusive-or)."
msgstr ""

#: ../../peewee/api.rst:2935
msgid ""
"``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``: create a binary expression "
"using the given comparator."
msgstr ""

#: ../../peewee/api.rst:2936
msgid "``<<``: create an *IN* expression."
msgstr ""

#: ../../peewee/api.rst:2937
msgid "``>>``: create an *IS* expression."
msgstr ""

#: ../../peewee/api.rst:2938
msgid "``%`` and ``**``: *LIKE* and *ILIKE*."
msgstr ""

#: ../../peewee/api.rst:2942
msgid "Create a binary expression using case-insensitive string search."
msgstr ""

#: ../../peewee/api.rst:2946
msgid "Create a binary expression using case-insensitive prefix search."
msgstr ""

#: ../../peewee/api.rst:2950
msgid "Create a binary expression using case-insensitive suffix search."
msgstr ""

#: ../../peewee/api.rst:2954
msgid "Create an expression that will match values between ``low`` and ``high``."
msgstr ""

#: ../../peewee/api.rst:2958
msgid "Match based on regular expression."
msgstr ""

#: ../../peewee/api.rst:2962
msgid "Concatenate the current node with the provided ``rhs``."
msgstr ""

#: ../../peewee/api.rst:2965
msgid ""
"In order for this method to work with MySQL, the MySQL session must be "
"set to use ``PIPES_AS_CONCAT``."
msgstr ""

#: ../../peewee/api.rst:2968
msgid ""
"To reliably concatenate strings with MySQL, use ``fn.CONCAT(s1, s2...)`` "
"instead."
msgstr ""

#: ../../peewee/api.rst:2973
msgid "Create an expression testing whether the ``Node`` is (or is not) ``NULL``."
msgstr ""

#: ../../peewee/api.rst:2983
msgid ""
"To simplify things, peewee will generate the correct SQL for equality and"
" inequality. The :py:meth:`~Node.is_null` method is provided simply for "
"readability."
msgstr ""

#: ../../peewee/api.rst:2994
msgid "Negate the node. This translates roughly into *NOT (<node>)*."
msgstr ""

#: ../../peewee/api.rst:2998
msgid "Apply an alias to the given node. This translates into *<node> AS <name>*."
msgstr ""

#: ../../peewee/api.rst:3002
msgid ""
"Apply ascending ordering to the given node. This translates into *<node> "
"ASC*."
msgstr ""

#: ../../peewee/api.rst:3006
msgid ""
"Apply descending ordering to the given node. This translates into *<node>"
" DESC*."
msgstr ""

#: ../../peewee/api.rst:3010
msgid ""
"Bind the results of an expression to a specific model type. Useful when "
"adding expressions to a select, where the result of the expression should"
" be placed on a particular joined instance."
msgstr ""

#: ../../peewee/api.rst:3014
msgid ""
"Decorator for adding the decorated function as a new method on "
":py:class:`Node` and its subclasses. Useful for adding implementation-"
"specific features to all node types."
msgstr ""

#: ../../peewee/api.rst:3016
msgid ""
"Method name. If not provided the name of the wrapped function will be "
"used."
msgstr ""

#: ../../peewee/api.rst:3017
msgid ""
"Whether this method should return a clone. This is generally true when "
"the method mutates the internal state of the node."
msgstr ""

#: ../../peewee/api.rst:3039
msgid ""
"To remove an extended method, simply call ``delattr`` on the class the "
"method was originally added to."
msgstr ""

#: ../../peewee/contributing.rst:4
msgid "Contributing"
msgstr "貢献する"

#: ../../peewee/contributing.rst:6
msgid ""
"In order to continually improve, Peewee needs the help of developers like"
" you. Whether it's contributing patches, submitting bug reports, or just "
"asking and answering questions, you are helping to make Peewee a better "
"library."
msgstr ""

#: ../../peewee/contributing.rst:8
msgid "In this document I'll describe some of the ways you can help."
msgstr ""

#: ../../peewee/contributing.rst:11
msgid "Patches"
msgstr "パッチ"

#: ../../peewee/contributing.rst:13
msgid ""
"Do you have an idea for a new feature, or is there a clunky API you'd "
"like to improve? Before coding it up and submitting a pull-request, `open"
" a new issue <https://github.com/coleifer/peewee/issues/new>`_ on GitHub "
"describing your proposed changes. This doesn't have to be anything "
"formal, just a description of what you'd like to do and why."
msgstr ""

#: ../../peewee/contributing.rst:15
msgid ""
"When you're ready, you can submit a pull-request with your changes. "
"Successful patches will have the following:"
msgstr ""

#: ../../peewee/contributing.rst:17
msgid "Unit tests."
msgstr ""

#: ../../peewee/contributing.rst:18
msgid "Documentation, both prose form and general :ref:`API documentation <api>`."
msgstr ""

#: ../../peewee/contributing.rst:19
msgid "Code that conforms stylistically with the rest of the Peewee codebase."
msgstr ""

#: ../../peewee/contributing.rst:22
msgid "Bugs"
msgstr "バグ"

#: ../../peewee/contributing.rst:24
msgid ""
"If you've found a bug, please check to see if it has `already been "
"reported <https://github.com/coleifer/peewee/issues/>`_, and if not "
"`create an issue on GitHub "
"<https://github.com/coleifer/peewee/issues/new>`_. The more information "
"you include, the more quickly the bug will get fixed, so please try to "
"include the following:"
msgstr ""

#: ../../peewee/contributing.rst:26
msgid ""
"Traceback and the error message (please `format your code "
"<https://help.github.com/articles/markdown-basics/>`_!)"
msgstr ""

#: ../../peewee/contributing.rst:27
msgid "Relevant portions of your code or code to reproduce the error"
msgstr ""

#: ../../peewee/contributing.rst:28
msgid ""
"Peewee version: ``python -c \"from peewee import __version__; "
"print(__version__)\"``"
msgstr ""

#: ../../peewee/contributing.rst:29
msgid "Which database you're using"
msgstr ""

#: ../../peewee/contributing.rst:31
msgid ""
"If you have found a bug in the code and submit a failing test-case, then "
"hats-off to you, you are a hero!"
msgstr ""

#: ../../peewee/contributing.rst:34
msgid "Questions"
msgstr "質問"

#: ../../peewee/contributing.rst:36
msgid ""
"If you have questions about how to do something with peewee, then I "
"recommend either:"
msgstr ""

#: ../../peewee/contributing.rst:38
msgid ""
"Ask on StackOverflow. I check SO just about every day for new peewee "
"questions and try to answer them. This has the benefit also of preserving"
" the question and answer for other people to find."
msgstr ""

#: ../../peewee/contributing.rst:39
msgid ""
"Ask in IRC, ``#peewee`` on freenode. I always answer questions, but it "
"may take a bit to get to them."
msgstr ""

#: ../../peewee/contributing.rst:40
msgid "Ask on the mailing list, https://groups.google.com/group/peewee-orm"
msgstr ""

#: ../../peewee/database.rst:4
msgid "Managing your Database"
msgstr "データベースの管理"

#: ../../peewee/database.rst:6
msgid ""
"This document describes how to perform typical database-related tasks "
"with peewee. Throughout this document we will use the following example "
"models:"
msgstr ""

#: ../../peewee/database.rst:22
msgid "Creating a database connection and tables"
msgstr "データベース接続とテーブルの作成"

#: ../../peewee/database.rst:24
msgid ""
"While it is not necessary to explicitly connect to the database before "
"using it, **managing connections explicitly is a good practice**. This "
"way if the connection fails, the exception can be caught during the "
"*connect* step, rather than some arbitrary time later when a query is "
"executed. Furthermore, if you're using a :ref:`connection pool <pool>`, "
"it is actually necessary to call :py:meth:`~Database.connect` and "
":py:meth:`~Database.close` to ensure connections are recycled correctly."
msgstr ""

#: ../../peewee/database.rst:26
msgid ""
"For web-apps you will typically open a connection when a request is "
"started and close it when the response is delivered:"
msgstr ""

#: ../../peewee/database.rst:38
msgid ""
"For examples of configuring connection hooks for several popular web "
"frameworks, see the :ref:`adding_request_hooks` section."
msgstr ""

#: ../../peewee/database.rst:40
msgid ""
"For advanced connection management techniques, see the :ref:`advanced "
"connection management <advanced_connection_management>` section."
msgstr ""

#: ../../peewee/database.rst:42
msgid ""
"To use this database with your models, set the ``database`` attribute on "
"an inner :ref:`Meta <model-options>` class:"
msgstr ""

#: ../../peewee/database.rst:52
msgid ""
"**Best practice:** define a base model class that points at the database "
"object you wish to use, and then all your models will extend it:"
msgstr ""

#: ../../peewee/database.rst:71
msgid ""
"Remember to specify a database on your model classes, otherwise peewee "
"will fall back to a default sqlite database named \"peewee.db\"."
msgstr ""

#: ../../peewee/database.rst:77
msgid "Vendor-specific Parameters"
msgstr ""

#: ../../peewee/database.rst:79
msgid ""
"Some database drivers accept special parameters when being initialized. "
"Rather than try to accommodate all these parameters, Peewee will pass "
"back unrecognized parameters directly to the database driver."
msgstr ""

#: ../../peewee/database.rst:81
msgid ""
"For instance, with Postgresql it is common to need to specify the "
"``host``, ``user`` and ``password`` when creating your connection. These "
"are not standard Peewee :py:class:`Database` parameters, so they will be "
"passed directly back to ``psycopg2`` when creating connections:"
msgstr ""

#: ../../peewee/database.rst:92
msgid ""
"As another example, the ``pymysql`` driver accepts a ``charset`` "
"parameter which is not a standard Peewee :py:class:`Database` parameter. "
"To set this value, simply pass in ``charset`` alongside your other "
"values:"
msgstr ""

#: ../../peewee/database.rst:98
msgid "Consult your database driver's documentation for the available parameters:"
msgstr ""

#: ../../peewee/database.rst:100
msgid ""
"Postgres: `psycopg2 "
"<http://initd.org/psycopg/docs/module.html#psycopg2.connect>`_"
msgstr ""

#: ../../peewee/database.rst:101
msgid ""
"MySQL: `MySQLdb <http://mysql-python.sourceforge.net/MySQLdb.html#some-"
"mysql-examples>`_"
msgstr ""

#: ../../peewee/database.rst:102
msgid ""
"MySQL: `pymysql "
"<https://github.com/PyMySQL/PyMySQL/blob/f08f01fe8a59e8acfb5f5add4a8fe874bec2a196/pymysql/connections.py#L494-L513>`_"
msgstr ""

#: ../../peewee/database.rst:103
msgid ""
"SQLite: `sqlite3 "
"<https://docs.python.org/2/library/sqlite3.html#sqlite3.connect>`_"
msgstr ""

#: ../../peewee/database.rst:108
msgid "Using Postgresql"
msgstr "Postgresqlの使用"

#: ../../peewee/database.rst:110
msgid ""
"To connect to a Postgresql database, we will use "
":py:class:`PostgresqlDatabase`. The first parameter is always the name of"
" the database, and after that you can specify arbitrary `psycopg2 "
"parameters "
"<http://initd.org/psycopg/docs/module.html#psycopg2.connect>`_."
msgstr ""

#: ../../peewee/database.rst:124
msgid ""
"The :ref:`playhouse` contains a :ref:`Postgresql extension module "
"<postgres_ext>` which provides many postgres-specific features such as:"
msgstr ""

#: ../../peewee/database.rst:126
msgid ":ref:`Arrays <pgarrays>`"
msgstr ""

#: ../../peewee/database.rst:127
msgid ":ref:`HStore <hstore>`"
msgstr ""

#: ../../peewee/database.rst:128
msgid ":ref:`JSON <pgjson>`"
msgstr ""

#: ../../peewee/database.rst:129
msgid ":ref:`Server-side cursors <server_side_cursors>`"
msgstr ""

#: ../../peewee/database.rst:130 ../../peewee/database.rst:165
msgid "And more!"
msgstr ""

#: ../../peewee/database.rst:132
msgid ""
"If you would like to use these awesome features, use the "
":py:class:`PostgresqlExtDatabase` from the ``playhouse.postgres_ext`` "
"module:"
msgstr ""

#: ../../peewee/database.rst:143
msgid "Using SQLite"
msgstr "SQLiteの使用"

#: ../../peewee/database.rst:145
msgid ""
"To connect to a SQLite database, we will use :py:class:`SqliteDatabase`. "
"The first parameter is the filename containing the database, or the "
"string *:memory:* to create an in-memory database. After the database "
"filename, you can specify arbitrary `sqlite3 parameters "
"<https://docs.python.org/2/library/sqlite3.html#sqlite3.connect>`_."
msgstr ""

#: ../../peewee/database.rst:160
msgid ""
"The :ref:`playhouse` contains a :ref:`SQLite extension module "
"<sqlite_ext>` which provides many SQLite-specific features such as:"
msgstr ""

#: ../../peewee/database.rst:162
msgid ""
":ref:`Full-text search <sqlite_fts>` with :ref:`BM25 ranking "
"<sqlite_bm25>`."
msgstr ""

#: ../../peewee/database.rst:163
msgid "Support for custom functions, aggregates and collations"
msgstr ""

#: ../../peewee/database.rst:164
msgid "Advanced transaction support"
msgstr ""

#: ../../peewee/database.rst:167
msgid ""
"If you would like to use these awesome features, use the "
":py:class:`SqliteExtDatabase` from the ``playhouse.sqlite_ext`` module:"
msgstr ""

#: ../../peewee/database.rst:178
msgid "PRAGMA statements"
msgstr ""

#: ../../peewee/database.rst:182
msgid ""
"SQLite allows run-time configuration of a number of parameters through "
"``PRAGMA`` statements (`documentation "
"<https://www.sqlite.org/pragma.html>`_). These statements are typically "
"run against a new database connection. To run one or more ``PRAGMA`` "
"statements against new connections, you can specify them as a list or "
"tuple of 2-tuples containing the pragma name and value:"
msgstr ""

#: ../../peewee/database.rst:197
msgid "SQLite and Autocommit"
msgstr ""

#: ../../peewee/database.rst:201
msgid ""
"In version 2.4.5, the default isolation level for SQLite databases is "
"``None``, which equates to *autocommit*. The reason for this change has "
"to do with some idiosyncracies of ``pysqlite`` (or the standard library "
"``sqlite3``)."
msgstr ""

#: ../../peewee/database.rst:203
msgid ""
"If you are using your database in autocommit mode (the default) then you "
"should not need to make any changes to your code."
msgstr ""

#: ../../peewee/database.rst:205
msgid ""
"If you are using ``autocommit=False``, you will need to explicitly call "
":py:meth:`~Database.begin` before executing queries."
msgstr ""

#: ../../peewee/database.rst:208
msgid ""
"This does not apply to code executed within "
":py:meth:`~Database.transaction` or :py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/database.rst:211
msgid ""
"If you are using peewee with autocommit disabled, you must explicitly "
"call :py:meth:`~Database.begin`, otherwise statements **will** be "
"executed in autocommit mode."
msgstr ""

#: ../../peewee/database.rst:235
msgid "APSW, an Advanced SQLite Driver"
msgstr ""

#: ../../peewee/database.rst:237
msgid ""
"Peewee also comes with an alternate SQLite database that uses "
":ref:`apsw`, an advanced Python SQLite driver. More information on APSW "
"can be obtained on the `APSW project website "
"<https://code.google.com/p/apsw/>`_. APSW provides special features like:"
msgstr ""

#: ../../peewee/database.rst:239
msgid "Virtual tables, virtual file-systems, Blob I/O, backups and file control."
msgstr ""

#: ../../peewee/database.rst:240 ../../peewee/playhouse.rst:1081
msgid "Connections can be shared across threads without any additional locking."
msgstr ""

#: ../../peewee/database.rst:241 ../../peewee/playhouse.rst:1082
msgid "Transactions are managed explicitly by your code."
msgstr ""

#: ../../peewee/database.rst:242
msgid "Unicode is handled *correctly*."
msgstr ""

#: ../../peewee/database.rst:243
msgid "APSW is faster that the standard library sqlite3 module."
msgstr ""

#: ../../peewee/database.rst:244
msgid "Exposes pretty much the entire SQLite C API to your Python app."
msgstr ""

#: ../../peewee/database.rst:246
msgid ""
"If you would like to use APSW, use the :py:class:`APSWDatabase` from the "
"`apsw_ext` module:"
msgstr ""

#: ../../peewee/database.rst:257
msgid "Using BerkeleyDB"
msgstr "BerkeleyBDの使用"

#: ../../peewee/database.rst:259
msgid ""
"The :ref:`playhouse <playhouse>` contains a special extension module for "
"using a :ref:`BerkeleyDB database <berkeleydb>`. BerkeleyDB can be "
"compiled with a SQLite-compatible API, then the python SQLite driver can "
"be compiled to use the Berkeley version of SQLite."
msgstr ""

#: ../../peewee/database.rst:261
msgid ""
"You can find up-to-date `step by step instructions "
"<http://charlesleifer.com/blog/building-the-python-sqlite-driver-for-use-"
"with-berkeleydb/>`_ on my blog for compling the BerkeleyDB + SQLite "
"library, then building a statically-linked `pysqlite "
"<https://github.com/ghaering/pysqlite>`_ that uses the custom sqlite "
"library."
msgstr ""

#: ../../peewee/database.rst:263
msgid ""
"To connect to a BerkeleyDB database, we will use "
":py:class:`BerkeleyDatabase`. Like :py:class:`SqliteDatabase`, the first "
"parameter is the filename containing the database or the string "
"*:memory:* to create an in-memory database."
msgstr ""

#: ../../peewee/database.rst:283
msgid "Using MySQL"
msgstr "MySQLの使用"

#: ../../peewee/database.rst:285
msgid ""
"To connect to a MySQL database, we will use :py:class:`MySQLDatabase`. "
"After the database name, you can specify arbitrary connection parameters "
"that will be passed back to the driver (either MySQLdb or pymysql)."
msgstr ""

#: ../../peewee/database.rst:301
msgid "Error 2006: MySQL server has gone away"
msgstr ""

#: ../../peewee/database.rst:303
msgid ""
"This particular error can occur when MySQL kills an idle database "
"connection. This typically happens with web apps that do not explicitly "
"manage database connections. What happens is your application starts, a "
"connection is opened to handle the first query that executes, and, since "
"that connection is never closed, it remains open, waiting for more "
"queries."
msgstr ""

#: ../../peewee/database.rst:305
msgid ""
"To fix this, make sure you are explicitly connecting to the database when"
" you need to execute queries, and close your connection when you are "
"done. In a web-application, this typically means you will open a "
"connection when a request comes in, and close the connection when you "
"return a response."
msgstr ""

#: ../../peewee/database.rst:307
msgid "See the :ref:`adding_request_hooks` for more information."
msgstr ""

#: ../../peewee/database.rst:309
msgid ""
"If you would like to automatically reconnect and retry queries that fail "
"due to an ``OperationalError``, peewee provides a :py:class:`Database` "
"mixin :py:class:`RetryOperationalError` that will handle reconnecting and"
" retrying the query automatically. For more information see :ref"
":`automatic-reconnect`."
msgstr ""

#: ../../peewee/database.rst:313
msgid "Connecting using a Database URL"
msgstr "データベースのURLを使用した接続"

#: ../../peewee/database.rst:315
msgid ""
"The playhouse module :ref:`db_url` provides a helper :py:func:`connect` "
"function that accepts a database URL and returns a :py:class:`Database` "
"instance."
msgstr ""

#: ../../peewee/database.rst:334
msgid "Example database URLs:"
msgstr ""

#: ../../peewee/database.rst:336 ../../peewee/playhouse.rst:3835
msgid ""
"*sqlite:///my_database.db* will create a :py:class:`SqliteDatabase` "
"instance for the file ``my_database.db`` in the current directory."
msgstr ""

#: ../../peewee/database.rst:337 ../../peewee/playhouse.rst:3836
msgid ""
"*sqlite:///:memory:* will create an in-memory :py:class:`SqliteDatabase` "
"instance."
msgstr ""

#: ../../peewee/database.rst:338 ../../peewee/playhouse.rst:3837
msgid ""
"*postgresql://postgres:my_password@localhost:5432/my_database* will "
"create a :py:class:`PostgresqlDatabase` instance. A username and password"
" are provided, as well as the host and port to connect to."
msgstr ""

#: ../../peewee/database.rst:339 ../../peewee/playhouse.rst:3838
msgid ""
"*mysql://user:passwd@ip:port/my_db* will create a "
":py:class:`MySQLDatabase` instance for the local MySQL database *my_db*."
msgstr ""

#: ../../peewee/database.rst:340
msgid ":ref:`More examples in the db_url documentation <db_url>`."
msgstr ""

#: ../../peewee/database.rst:343
msgid "Multi-threaded applications"
msgstr "マルチスレッドアプリケーション"

#: ../../peewee/database.rst:345
msgid ""
"peewee stores the connection state in a thread local, so each thread gets"
" its own separate connection. If you prefer to manage the connections "
"yourself, you can disable this behavior by initializing your database "
"with ``threadlocals=False``."
msgstr ""

#: ../../peewee/database.rst:350
msgid "Run-time database configuration"
msgstr "実行時のデータベース設定"

#: ../../peewee/database.rst:352
msgid ""
"Sometimes the database connection settings are not known until run-time, "
"when these values may be loaded from a configuration file or the "
"environment. In these cases, you can *defer* the initialization of the "
"database by specifying ``None`` as the database_name."
msgstr ""

#: ../../peewee/database.rst:362
msgid ""
"If you try to connect or issue any queries while your database is "
"uninitialized you will get an exception:"
msgstr ""

#: ../../peewee/database.rst:369
msgid ""
"To initialize your database, call the :py:meth:`~Database.init` method "
"with the database name and any additional keyword arguments:"
msgstr ""

#: ../../peewee/database.rst:376
msgid ""
"For even more control over initializing your database, see the next "
"section, :ref:`dynamic_db`."
msgstr ""

#: ../../peewee/database.rst:381
msgid "Dynamically defining a database"
msgstr "データベースの動的定義"

#: ../../peewee/database.rst:383
msgid ""
"For even more control over how your database is defined/initialized, you "
"can use the :py:class:`Proxy` helper. :py:class:`Proxy` objects act as a "
"placeholder, and then at run-time you can swap it out for a different "
"object. In the example below, we will swap out the database depending on "
"how the app is configured:"
msgstr ""

#: ../../peewee/database.rst:408
msgid ""
"Only use this method if your actual database driver varies at run-time. "
"For instance, if your tests and local dev environment run on SQLite, but "
"your deployed app uses PostgreSQL, you can use the :py:class:`Proxy` to "
"swap out engines at run-time."
msgstr ""

#: ../../peewee/database.rst:410
msgid ""
"However, if it is only connection values that vary at run-time, such as "
"the path to the database file, or the database host, you should instead "
"use :py:meth:`Database.init`. See :ref:`deferring_initialization` for "
"more details."
msgstr ""

#: ../../peewee/database.rst:415
msgid "Connection Pooling"
msgstr "接続のプーリング"

#: ../../peewee/database.rst:417
msgid ""
"Connection pooling is provided by the :ref:`pool module <pool>`, included"
" in the :ref:`playhouse` extensions library. The pool supports:"
msgstr ""

#: ../../peewee/database.rst:419
msgid "Timeout after which connections will be recycled."
msgstr ""

#: ../../peewee/database.rst:420
msgid "Upper bound on the number of open connections."
msgstr ""

#: ../../peewee/database.rst:422
msgid ""
"The connection pool module comes with support for Postgres and MySQL "
"(though adding support for other databases is trivial)."
msgstr ""

#: ../../peewee/database.rst:438
msgid "The following pooled database classes are available:"
msgstr ""

#: ../../peewee/database.rst:440
msgid ":py:class:`PooledPostgresqlDatabase`"
msgstr ""

#: ../../peewee/database.rst:441
msgid ":py:class:`PooledPostgresqlExtDatabase`"
msgstr ""

#: ../../peewee/database.rst:442
msgid ":py:class:`PooledMySQLDatabase`"
msgstr ""

#: ../../peewee/database.rst:443
msgid ":py:class:`PooledSqliteDatabase`"
msgstr ""

#: ../../peewee/database.rst:444
msgid ":py:class:`PooledSqliteExtDatabase`"
msgstr ""

#: ../../peewee/database.rst:446
msgid ""
"For an in-depth discussion of peewee's connection pool, see the "
":ref:`pool` section of the :ref:`playhouse` documentation."
msgstr ""

#: ../../peewee/database.rst:451 ../../peewee/playhouse.rst:4071
msgid "Read Slaves"
msgstr "スレーブを読み込む"

#: ../../peewee/database.rst:453
msgid ""
"Peewee can automatically run *SELECT* queries against one or more read "
"replicas. The :ref:`read_slave module <read_slaves>`, included in the "
":ref:`playhouse` extensions library, contains a :py:class:`Model` "
"subclass which provides this behavior."
msgstr ""

#: ../../peewee/database.rst:455
msgid "Here is how you might use the :py:class:`ReadSlaveModel`:"
msgstr ""

#: ../../peewee/database.rst:475
msgid ""
"Now when you execute writes (or deletes), they will be run on the master,"
" while all read-only queries will be executed against one of the "
"replicas. Queries are dispatched among the read slaves in round-robin "
"fashion."
msgstr ""

#: ../../peewee/database.rst:478
msgid "Schema migrations"
msgstr "スキーママイグレーション"

#: ../../peewee/database.rst:480
msgid ""
"Currently peewee does not have support for *automatic* schema migrations,"
" but you can use the :ref:`migrate` module to create simple migration "
"scripts. The schema migrations module works with SQLite, MySQL and "
"Postgres, and will even allow you to do things like drop or rename "
"columns in SQLite!"
msgstr ""

#: ../../peewee/database.rst:482
msgid "Here is an example of how you might write a migration script:"
msgstr ""

#: ../../peewee/database.rst:501
msgid "Check the :ref:`migrate` documentation for more details."
msgstr ""

#: ../../peewee/database.rst:504
msgid "Generating Models from Existing Databases"
msgstr "既存データベースからモデル生成"

#: ../../peewee/database.rst:506
msgid ""
"If you'd like to generate peewee model definitions for an existing "
"database, you can try out the database introspection tool :ref:`pwiz` "
"that comes with peewee. *pwiz* is capable of introspecting Postgresql, "
"MySQL and SQLite databases."
msgstr ""

#: ../../peewee/database.rst:508
msgid "Introspecting a Postgresql database:"
msgstr ""

#: ../../peewee/database.rst:514
msgid "Introspecting a SQLite database:"
msgstr ""

#: ../../peewee/database.rst:520
msgid "pwiz will generate:"
msgstr ""

#: ../../peewee/database.rst:522
msgid "Database connection object"
msgstr ""

#: ../../peewee/database.rst:523
msgid "A *BaseModel* class to use with the database"
msgstr ""

#: ../../peewee/database.rst:524
msgid "*Model* classes for each table in the database."
msgstr ""

#: ../../peewee/database.rst:526
msgid ""
"The generated code is written to stdout, and can easily be redirected to "
"a file:"
msgstr ""

#: ../../peewee/database.rst:533
msgid ""
"pwiz generally works quite well with even large and complex database "
"schemas, but in some cases it will not be able to introspect a column. "
"You may need to go through the generated code to add indexes, fix "
"unrecognized column types, and resolve any circular references that were "
"found."
msgstr ""

#: ../../peewee/database.rst:541
msgid "Adding Request Hooks"
msgstr "リクエストフックの追加"

#: ../../peewee/database.rst:543
msgid ""
"When building web-applications, it is very important that you manage your"
" database connections correctly. In this section I will describe how to "
"add hooks to your web app to ensure the database connection is handled "
"properly."
msgstr ""

#: ../../peewee/database.rst:545
msgid ""
"These steps will ensure that regardless of whether you're using a simple "
"SQLite database, or a pool of multiple Postgres connections, peewee will "
"handle the connections correctly."
msgstr ""

#: ../../peewee/database.rst:548
msgid "Flask"
msgstr ""

#: ../../peewee/database.rst:550
msgid ""
"Flask and peewee are a great combo and my go-to for projects of any size."
" Flask provides two hooks which we will use to open and close our db "
"connection. We'll open the connection when a request is received, then "
"close it when the response is returned."
msgstr ""

#: ../../peewee/database.rst:574
msgid "Django"
msgstr ""

#: ../../peewee/database.rst:576
msgid ""
"While it's less common to see peewee used with Django, it is actually "
"very easy to use the two. To manage your peewee database connections with"
" Django, the easiest way in my opinion is to add a middleware to your "
"app. The middleware should be the very first in the list of middlewares, "
"to ensure it runs first when a request is handled, and last when the "
"response is returned."
msgstr ""

#: ../../peewee/database.rst:578
msgid ""
"If you have a django project named *my_blog* and your peewee database is "
"defined in the module ``my_blog.db``, you might add the following "
"middleware class:"
msgstr ""

#: ../../peewee/database.rst:595
msgid ""
"To ensure this middleware gets executed, add it to your ``settings`` "
"module:"
msgstr ""

#: ../../peewee/database.rst:616
msgid "Bottle"
msgstr ""

#: ../../peewee/database.rst:618
msgid ""
"I haven't used bottle myself, but looking at the documentation I believe "
"the following code should ensure the database connections are properly "
"managed:"
msgstr ""

#: ../../peewee/database.rst:640
msgid "Web.py"
msgstr ""

#: ../../peewee/database.rst:642
msgid ""
"See `application processors "
"<http://webpy.org/cookbook/application_processors>`_."
msgstr ""

#: ../../peewee/database.rst:659
msgid "Tornado"
msgstr ""

#: ../../peewee/database.rst:661
msgid ""
"It looks like Tornado's ``RequestHandler`` class implements two hooks "
"which can be used to open and close connections when a request is "
"handled."
msgstr ""

#: ../../peewee/database.rst:679
msgid ""
"In your app, instead of extending the default ``RequestHandler``, now you"
" can extend ``PeeweeRequestHandler``."
msgstr ""

#: ../../peewee/database.rst:681
msgid ""
"Note that this does not address how to use peewee asynchronously with "
"Tornado or another event loop."
msgstr ""

#: ../../peewee/database.rst:684
msgid "Wheezy.web"
msgstr ""

#: ../../peewee/database.rst:686
msgid ""
"The connection handling code can be placed in a `middleware "
"<https://pythonhosted.org/wheezy.http/userguide.html#middleware>`_."
msgstr ""

#: ../../peewee/database.rst:704
msgid "Thanks to GitHub user *@tuukkamustonen* for submitting this code."
msgstr ""

#: ../../peewee/database.rst:707
msgid "Falcon"
msgstr ""

#: ../../peewee/database.rst:709
msgid ""
"The connection handling code can be placed in a `middleware component "
"<https://falcon.readthedocs.io/en/stable/api/middleware.html>`_."
msgstr ""

#: ../../peewee/database.rst:732
msgid "Pyramid"
msgstr ""

#: ../../peewee/database.rst:734
msgid ""
"Set up a Request factory that handles database connection lifetime as "
"follows:"
msgstr ""

#: ../../peewee/database.rst:752
msgid ""
"In your application `main()` make sure `MyRequest` is used as "
"`request_factory`:"
msgstr ""

#: ../../peewee/database.rst:761
msgid "CherryPy"
msgstr ""

#: ../../peewee/database.rst:763
msgid ""
"See `Publish/Subscribe pattern "
"<http://docs.cherrypy.org/en/latest/extend.html#publish-subscribe-"
"pattern>`_."
msgstr ""

#: ../../peewee/database.rst:778
msgid "Other frameworks"
msgstr ""

#: ../../peewee/database.rst:780
msgid ""
"Don't see your framework here? Please `open a GitHub ticket "
"<https://github.com/coleifer/peewee/issues/new>`_ and I'll see about "
"adding a section, or better yet, submit a documentation pull-request."
msgstr ""

#: ../../peewee/database.rst:783
msgid "Additional connection initialization"
msgstr "追加接続の初期化"

#: ../../peewee/database.rst:785
msgid ""
"Peewee does a few basic things depending on your database to initialize a"
" connection. For SQLite this means registering custom user-defined "
"functions, for Postgresql this means registering unicode support."
msgstr ""

#: ../../peewee/database.rst:787
msgid ""
"You may find it necessary to add additional initialization when a new "
"connection is opened, however. For example you may want to tell SQLite to"
" enforce all foreign key constraints (off by default). To do this, you "
"can subclass the database and override the "
":py:meth:`~Database.initialize_connection` method."
msgstr ""

#: ../../peewee/database.rst:789
msgid ""
"This method contains no implementation on the base database classes, so "
"you do not need to call ``super()`` with it."
msgstr ""

#: ../../peewee/database.rst:791
msgid "Example turning on SQLite foreign keys:"
msgstr ""

#: ../../peewee/database.rst:802
msgid "Advanced Connection Management"
msgstr "高度な接続管理"

#: ../../peewee/database.rst:804
msgid ""
"Managing your database connections is as simple as calling "
":py:meth:`~Database.connect` when you need to open a connection, and "
":py:meth:`~Database.close` when you are finished. In a web-app, you would"
" typically connect when you receive a request, and close the connection "
"when you return a response. Because connection state is stored in a "
"thread-local, you do not need to worry about juggling connection objects "
"-- peewee will handle it for you."
msgstr ""

#: ../../peewee/database.rst:806
msgid ""
"In some situations, however, you may want to manage your connections more"
" explicitly. Since peewee stores the active connection in a threadlocal, "
"this typically would mean that there could only ever be one connection "
"open per thread. For most applications this is desirable, but if you "
"would like to manually manage multiple connections you can create an "
":py:class:`ExecutionContext`."
msgstr ""

#: ../../peewee/database.rst:808
msgid ""
"Execution contexts allow finer-grained control over managing multiple "
"connections to the database. When an execution context is initialized "
"(either as a context manager or as a decorated function), a separate "
"connection will be used for the duration of the wrapped block. You can "
"also choose whether to wrap the block in a transaction."
msgstr ""

#: ../../peewee/database.rst:810
msgid "Execution context examples:"
msgstr ""

#: ../../peewee/database.rst:828
msgid ""
"If you are using the peewee connection pool, then the new connections "
"used by the :py:class:`ExecutionContext` will be pulled from the pool of "
"available connections and recycled appropriately."
msgstr ""

#: ../../peewee/database.rst:831
msgid "Using multiple databases"
msgstr "複数データベースの使用"

#: ../../peewee/database.rst:833
msgid ""
"With peewee you can use as many databases as you want. Each model can "
"define it's database by specifying a :ref:`Meta.database <model-"
"options>`. What if you want to use the same model with multiple "
"databases, though? Depending on your use-case, peewee provides several "
"options."
msgstr ""

#: ../../peewee/database.rst:835
msgid ""
"If you have a Master/Slave setup and want all writes to go to the master,"
" but reads can go to any number of replicated copies, check out the "
":ref:`Read Slave extension <read_slaves>`."
msgstr ""

#: ../../peewee/database.rst:837
msgid ""
"For finer-grained control, check out the :py:class:`Using` context "
"manager / decorator. This allows you to specify the database to use with "
"a given list of models for the duration of the wrapped block."
msgstr ""

#: ../../peewee/database.rst:839
msgid ""
"Here is an example of how you might use the :py:class:`Using` context "
"manager:"
msgstr ""

#: ../../peewee/database.rst:867
msgid ""
"For simple master/slave configurations, check out the :ref:`read_slaves` "
"extension. This extension ensures writes are sent to the master database "
"and reads occur from any of the listed read replicas."
msgstr ""

#: ../../peewee/database.rst:872
msgid "Database Errors"
msgstr "データベースエラー"

#: ../../peewee/database.rst:874
msgid ""
"The Python DB-API 2.0 spec describes `several types of exceptions "
"<https://www.python.org/dev/peps/pep-0249/#exceptions>`_. Because most "
"database drivers have their own implementations of these exceptions, "
"Peewee simplifies things by providing its own wrappers around any "
"implementation-specific exception classes. That way, you don't need to "
"worry about importing any special exception classes, you can just use the"
" ones from peewee:"
msgstr ""

#: ../../peewee/database.rst:876
msgid "``DatabaseError``"
msgstr ""

#: ../../peewee/database.rst:877
msgid "``DataError``"
msgstr ""

#: ../../peewee/database.rst:878
msgid "``IntegrityError``"
msgstr ""

#: ../../peewee/database.rst:879
msgid "``InterfaceError``"
msgstr ""

#: ../../peewee/database.rst:880
msgid "``InternalError``"
msgstr ""

#: ../../peewee/database.rst:881
msgid "``NotSupportedError``"
msgstr ""

#: ../../peewee/database.rst:882
msgid "``OperationalError``"
msgstr ""

#: ../../peewee/database.rst:883
msgid "``ProgrammingError``"
msgstr ""

#: ../../peewee/database.rst:885
msgid "All of these error classes extend ``PeeweeException``."
msgstr ""

#: ../../peewee/database.rst:890
msgid "Automatic Reconnect"
msgstr "自動再接続"

#: ../../peewee/database.rst:892
msgid ""
"Peewee provides very basic support for automatic reconnecting in the "
":ref:`shortcuts` module, through the use of the "
":py:class:`RetryOperationalError` mixin. This mixin will automatically "
"reconnect to the database and retry any queries that fail with an "
"``OperationalError``. The query that failed will be retried only once, "
"and if it fails twice an exception will be raised."
msgstr ""

#: ../../peewee/database.rst:909
msgid "Logging queries"
msgstr "クエリのロギング"

#: ../../peewee/database.rst:911
msgid ""
"All queries are logged to the *peewee* namespace using the standard "
"library ``logging`` module. Queries are logged using the *DEBUG* level.  "
"If you're interested in doing something with the queries, you can simply "
"register a handler."
msgstr ""

#: ../../peewee/database.rst:922
msgid "Generating skeleton code"
msgstr "スケルトンコードの生成"

#: ../../peewee/database.rst:924
msgid ""
"For writing quick scripts, peewee comes with a helper script :ref:`pskel`"
" which generates database connection and model boilerplate code. If you "
"find yourself frequently writing small programs, :ref:`pskel` can really "
"save you time."
msgstr ""

#: ../../peewee/database.rst:926
msgid "To generate a script, you can simply run:"
msgstr ""

#: ../../peewee/database.rst:932
msgid ""
"``pskel`` will generate code to connect to an in-memory SQLite database, "
"as well as blank model definitions for the model names specified on the "
"command line."
msgstr ""

#: ../../peewee/database.rst:934
msgid ""
"Here is a more complete example, which will use the "
":py:class:`PostgresqlExtDatabase` with query logging enabled:"
msgstr ""

#: ../../peewee/database.rst:940
msgid "You can now fill in the model definitions and get to hacking!"
msgstr ""

#: ../../peewee/database.rst:943
msgid "Adding a new Database Driver"
msgstr "新しいデータベースドライバーの追加"

#: ../../peewee/database.rst:945
msgid ""
"Peewee comes with built-in support for Postgres, MySQL and SQLite. These "
"databases are very popular and run the gamut from fast, embeddable "
"databases to heavyweight servers suitable for large-scale deployments.  "
"That being said, there are a ton of cool databases out there and adding "
"support for your database-of-choice should be really easy, provided the "
"driver supports the `DB-API 2.0 spec "
"<http://www.python.org/dev/peps/pep-0249/>`_."
msgstr ""

#: ../../peewee/database.rst:947
msgid ""
"The db-api 2.0 spec should be familiar to you if you've used the standard"
" library sqlite3 driver, psycopg2 or the like. Peewee currently relies on"
" a handful of parts:"
msgstr ""

#: ../../peewee/database.rst:949
msgid "`Connection.commit`"
msgstr ""

#: ../../peewee/database.rst:950
msgid "`Connection.execute`"
msgstr ""

#: ../../peewee/database.rst:951
msgid "`Connection.rollback`"
msgstr ""

#: ../../peewee/database.rst:952
msgid "`Cursor.description`"
msgstr ""

#: ../../peewee/database.rst:953
msgid "`Cursor.fetchone`"
msgstr ""

#: ../../peewee/database.rst:955
msgid ""
"These methods are generally wrapped up in higher-level abstractions and "
"exposed by the :py:class:`Database`, so even if your driver doesn't do "
"these exactly you can still get a lot of mileage out of peewee.  An "
"example is the `apsw sqlite driver <http://code.google.com/p/apsw/>`_ in "
"the \"playhouse\" module."
msgstr ""

#: ../../peewee/database.rst:957
msgid ""
"The first thing is to provide a subclass of :py:class:`Database` that "
"will open a connection."
msgstr ""

#: ../../peewee/database.rst:969
msgid ""
"The :py:class:`Database` provides a higher-level API and is responsible "
"for executing queries, creating tables and indexes, and introspecting the"
" database to get lists of tables. The above implementation is the "
"absolute minimum needed, though some features will not work -- for best "
"results you will want to additionally add a method for extracting a list "
"of tables and indexes for a table from the database.  We'll pretend that "
"``FooDB`` is a lot like MySQL and has special \"SHOW\" statements:"
msgstr ""

#: ../../peewee/database.rst:981
msgid "Other things the database handles that are not covered here include:"
msgstr ""

#: ../../peewee/database.rst:983
msgid ":py:meth:`~Database.last_insert_id` and :py:meth:`~Database.rows_affected`"
msgstr ""

#: ../../peewee/database.rst:984
msgid ":py:attr:`~Database.interpolation` and :py:attr:`~Database.quote_char`"
msgstr ""

#: ../../peewee/database.rst:985
msgid ""
":py:attr:`~Database.op_overrides` for mapping operations such as "
"\"LIKE/ILIKE\" to their database equivalent"
msgstr ""

#: ../../peewee/database.rst:987
msgid ""
"Refer to the :py:class:`Database` API reference or the `source code "
"<https://github.com/coleifer/peewee/blob/master/peewee.py>`_. for "
"details."
msgstr ""

#: ../../peewee/database.rst:989
msgid ""
"If your driver conforms to the DB-API 2.0 spec, there shouldn't be much "
"work needed to get up and running."
msgstr ""

#: ../../peewee/database.rst:991
msgid ""
"Our new database can be used just like any of the other database "
"subclasses:"
msgstr ""

#: ../../peewee/example.rst:4
msgid "Example app"
msgstr "サンプル・アプリケーション"

#: ../../peewee/example.rst:6
msgid ""
"We'll be building a simple *twitter*-like site. The source code for the "
"example can be found in the ``examples/twitter`` directory. You can also "
"`browse the source-code "
"<https://github.com/coleifer/peewee/tree/master/examples/twitter>`_ on "
"github. There is also an example `blog app "
"<https://github.com/coleifer/peewee/tree/master/examples/blog>`_ if "
"that's more to your liking."
msgstr ""

#: ../../peewee/example.rst:8
msgid ""
"The example app uses the `flask <http://flask.pocoo.org/>`_ web framework"
" which is very easy to get started with. If you don't have flask already,"
" you will need to install it to run the example:"
msgstr ""

#: ../../peewee/example.rst:15
msgid "Running the example"
msgstr "サンプルの実行"

#: ../../peewee/example.rst:19
msgid ""
"After ensuring that flask is installed, ``cd`` into the twitter example "
"directory and execute the ``run_example.py`` script:"
msgstr ""

#: ../../peewee/example.rst:25
msgid "The example app will be accessible at http://localhost:5000/"
msgstr ""

#: ../../peewee/example.rst:28
msgid "Diving into the code"
msgstr "コードへの潜入"

#: ../../peewee/example.rst:30
msgid ""
"For simplicity all example code is contained within a single module, "
"``examples/twitter/app.py``. For a guide on structuring larger Flask apps"
" with peewee, check out `Structuring Flask Apps "
"<http://charlesleifer.com/blog/structuring-flask-apps-a-how-to-for-those-"
"coming-from-django/>`_."
msgstr ""

#: ../../peewee/example.rst:37
msgid ""
"In the spirit of the popular web framework Django, peewee uses "
"declarative model definitions. If you're not familiar with Django, the "
"idea is that you declare a model class for each table. The model class "
"then defines one or more field attributes which correspond to the table's"
" columns. For the twitter clone, there are just three models:"
msgstr ""

#: ../../peewee/example.rst:42
msgid "*User*:"
msgstr ""

#: ../../peewee/example.rst:40
msgid ""
"Represents a user account and stores the username and password, an email "
"address for generating avatars using *gravatar*, and a datetime field "
"indicating when that account was created."
msgstr ""

#: ../../peewee/example.rst:46
msgid "*Relationship*:"
msgstr ""

#: ../../peewee/example.rst:45
msgid ""
"This is a utility model that contains two foreign-keys to the *User* "
"model and stores which users follow one another."
msgstr ""

#: ../../peewee/example.rst:50
msgid "*Message*:"
msgstr ""

#: ../../peewee/example.rst:49
msgid ""
"Analagous to a tweet. The Message model stores the text content of the "
"tweet, when it was created, and who posted it (foreign key to User)."
msgstr ""

#: ../../peewee/example.rst:52
msgid "If you like UML, these are the tables and relationships:"
msgstr ""

#: ../../peewee/example.rst:56
msgid ""
"In order to create these models we need to instantiate a "
":py:class:`SqliteDatabase` object. Then we define our model classes, "
"specifying the columns as :py:class:`Field` instances on the class."
msgstr ""

#: ../../peewee/example.rst:107
msgid ""
"Note that we create a *BaseModel* class that simply defines what database"
" we would like to use.  All other models then extend this class and will "
"also use the correct database connection."
msgstr ""

#: ../../peewee/example.rst:112
msgid ""
"Peewee supports many different :ref:`field types <fields>` which map to "
"different column types commonly supported by database engines.  "
"Conversion between python types and those used in the database is handled"
" transparently, allowing you to use the following in your application:"
msgstr ""

#: ../../peewee/example.rst:114
msgid "Strings (unicode or otherwise)"
msgstr ""

#: ../../peewee/example.rst:115
msgid "Integers, floats, and ``Decimal`` numbers."
msgstr ""

#: ../../peewee/example.rst:116
msgid "Boolean values"
msgstr ""

#: ../../peewee/example.rst:117
msgid "Dates, times and datetimes"
msgstr ""

#: ../../peewee/example.rst:118
msgid "``None`` (NULL)"
msgstr ""

#: ../../peewee/example.rst:119
msgid "Binary data"
msgstr ""

#: ../../peewee/example.rst:122
msgid "Creating tables"
msgstr ""

#: ../../peewee/example.rst:124
msgid ""
"In order to start using the models, its necessary to create the tables. "
"This is a one-time operation and can be done quickly using the "
"interactive interpreter. We can create a small helper function to "
"accomplish this:"
msgstr ""

#: ../../peewee/example.rst:132
msgid ""
"Open a python shell in the directory alongside the example app and "
"execute the following:"
msgstr ""

#: ../../peewee/example.rst:141
msgid ""
"If you encounter an *ImportError* it means that either *flask* or "
"*peewee* was not found and may not be installed correctly. Check the "
":ref:`installation` document for instructions on installing peewee."
msgstr ""

#: ../../peewee/example.rst:145
msgid ""
"Every model has a :py:meth:`~Model.create_table` classmethod which runs a"
" SQL *CREATE TABLE* statement in the database. This method will create "
"the table, including all columns, foreign-key constraints, indexes, and "
"sequences. Usually this is something you'll only do once, whenever a new "
"model is added."
msgstr ""

#: ../../peewee/example.rst:147
msgid ""
"Peewee provides a helper method :py:meth:`Database.create_tables` which "
"will resolve inter-model dependencies and call "
":py:meth:`~Model.create_table` on each model."
msgstr ""

#: ../../peewee/example.rst:150
msgid ""
"Adding fields after the table has been created will required you to "
"either drop the table and re-create it or manually add the columns using "
"an *ALTER TABLE* query."
msgstr ""

#: ../../peewee/example.rst:154
msgid ""
"Alternatively, you can use the :ref:`schema migrations <migrate>` "
"extension to alter your database schema using Python."
msgstr ""

#: ../../peewee/example.rst:158
msgid ""
"You can also write ``database.create_tables([User, ...], True)`` and "
"peewee will first check to see if the table exists before creating it."
msgstr ""

#: ../../peewee/example.rst:161
msgid "Establishing a database connection"
msgstr ""

#: ../../peewee/example.rst:163
msgid ""
"You may have noticed in the above model code that there is a class "
"defined on the base model named *Meta* that sets the ``database`` "
"attribute. Peewee allows every model to specify which database it uses. "
"There are many :ref:`Meta options <model-options>` you can specify which "
"control the behavior of your model."
msgstr ""

#: ../../peewee/example.rst:165
msgid "This is a peewee idiom:"
msgstr ""

#: ../../peewee/example.rst:175
msgid ""
"When developing a web application, it's common to open a connection when "
"a request starts, and close it when the response is returned. **You "
"should always manage your connections explicitly**. For instance, if you "
"are using a :ref:`connection pool <pool>`, connections will only be "
"recycled correctly if you call :py:meth:`~Database.connect` and "
":py:meth:`~Database.close`."
msgstr ""

#: ../../peewee/example.rst:177
msgid ""
"We will tell flask that during the request/response cycle we need to "
"create a connection to the database. Flask provides some handy decorators"
" to make this a snap:"
msgstr ""

#: ../../peewee/example.rst:191
msgid ""
"Peewee uses thread local storage to manage connection state, so this "
"pattern can be used with multi-threaded WSGI servers."
msgstr ""

#: ../../peewee/example.rst:195
msgid "Making queries"
msgstr ""

#: ../../peewee/example.rst:197
msgid ""
"In the *User* model there are a few instance methods that encapsulate "
"some user-specific functionality:"
msgstr ""

#: ../../peewee/example.rst:199
msgid "``following()``: who is this user following?"
msgstr ""

#: ../../peewee/example.rst:200
msgid "``followers()``: who is following this user?"
msgstr ""

#: ../../peewee/example.rst:202
msgid ""
"These methods are similar in their implementation but with an important "
"difference in the SQL *JOIN* and *WHERE* clauses:"
msgstr ""

#: ../../peewee/example.rst:220
msgid "Creating new objects"
msgstr ""

#: ../../peewee/example.rst:222
msgid ""
"When a new user wants to join the site we need to make sure the username "
"is available, and if so, create a new *User* record. Looking at the "
"*join()* view, we can see that our application attempts to create the "
"User using :py:meth:`Model.create`. We defined the *User.username* field "
"with a unique constraint, so if the username is taken the database will "
"raise an ``IntegrityError``."
msgstr ""

#: ../../peewee/example.rst:244
msgid ""
"We will use a similar approach when a user wishes to follow someone. To "
"indicate a following relationship, we create a row in the *Relationship* "
"table pointing from one user to another. Due to the unique index on "
"``from_user`` and ``to_user``, we will be sure not to end up with "
"duplicate rows:"
msgstr ""

#: ../../peewee/example.rst:258
msgid "Performing subqueries"
msgstr ""

#: ../../peewee/example.rst:260
msgid ""
"If you are logged-in and visit the twitter homepage, you will see tweets "
"from the users that you follow. In order to implement this cleanly, we "
"can use a subquery:"
msgstr ""

#: ../../peewee/example.rst:267
msgid "This code corresponds to the following SQL query:"
msgstr ""

#: ../../peewee/example.rst:282
msgid "Other topics of interest"
msgstr ""

#: ../../peewee/example.rst:284
msgid ""
"There are a couple other neat things going on in the example app that are"
" worth mentioning briefly."
msgstr ""

#: ../../peewee/example.rst:286
msgid ""
"Support for paginating lists of results is implemented in a simple "
"function called ``object_list`` (after it's corollary in Django).  This "
"function is used by all the views that return lists of objects."
msgstr ""

#: ../../peewee/example.rst:300
msgid ""
"Simple authentication system with a ``login_required`` decorator.  The "
"first function simply adds user data into the current session when a user"
" successfully logs in.  The decorator ``login_required`` can be used to "
"wrap view functions, checking for whether the session is authenticated "
"and if not redirecting to the login page."
msgstr ""

#: ../../peewee/example.rst:322
msgid ""
"Return a 404 response instead of throwing exceptions when an object is "
"not found in the database."
msgstr ""

#: ../../peewee/example.rst:334
msgid "More examples"
msgstr "より多くの例"

#: ../../peewee/example.rst:336
msgid ""
"There are more examples included in the peewee `examples directory "
"<https://github.com/coleifer/peewee/blob/master/examples/>`_, including:"
msgstr ""

#: ../../peewee/example.rst:338
msgid ""
"`Example blog app "
"<https://github.com/coleifer/peewee/tree/master/examples/blog>`_ using "
"Flask and peewee. Also see `accompanying blog post "
"<http://charlesleifer.com/blog/how-to-make-a-flask-blog-in-one-hour-or-"
"less/>`_."
msgstr ""

#: ../../peewee/example.rst:339
msgid ""
"`An encrypted command-line diary "
"<https://github.com/coleifer/peewee/blob/master/examples/diary.py>`_. "
"There is a `companion blog post <http://charlesleifer.com/blog/dear-"
"diary-an-encrypted-command-line-diary-with-python/>`_ you might enjoy as "
"well."
msgstr ""

#: ../../peewee/example.rst:340
msgid ""
"`Analytics web-service "
"<https://github.com/coleifer/peewee/tree/master/examples/analytics>`_ "
"(like a lite version of Google Analytics). Also check out the `companion "
"blog post <http://charlesleifer.com/blog/saturday-morning-hacks-building-"
"an-analytics-app-with-flask/>`_."
msgstr ""

#: ../../peewee/example.rst:343
msgid ""
"Like these snippets and interested in more?  Check out `flask-peewee "
"<https://github.com/coleifer/flask-peewee>`_ - a flask plugin that "
"provides a django-like Admin interface, RESTful API, Authentication and "
"more for your peewee models."
msgstr ""

#: ../../peewee/hacks.rst:4
msgid "Hacks"
msgstr ""

#: ../../peewee/hacks.rst:6
msgid ""
"Collected hacks using peewee. Have a cool hack you'd like to share? Open "
"`an issue on GitHub <https://github.com/coleifer/peewee/issues/new>`_ or "
"`contact me <http://charlesleifer.com/contact/>`_."
msgstr ""

#: ../../peewee/hacks.rst:11
msgid "Optimistic Locking"
msgstr ""

#: ../../peewee/hacks.rst:13
msgid ""
"Optimistic locking is useful in situations where you might ordinarily use"
" a *SELECT FOR UPDATE* (or in SQLite, *BEGIN IMMEDIATE*). For example, "
"you might fetch a user record from the database, make some modifications,"
" then save the modified user record. Typically this scenario would "
"require us to lock the user record for the duration of the transaction, "
"from the moment we select it, to the moment we save our changes."
msgstr ""

#: ../../peewee/hacks.rst:20
msgid ""
"In optimistic locking, on the other hand, we do *not* acquire any lock "
"and instead rely on an internal *version* column in the row we're "
"modifying. At read time, we see what version the row is currently at, and"
" on save, we ensure that the update takes place only if the version is "
"the same as the one we initially read. If the version is higher, then "
"some other process must have snuck in and changed the row -- to save our "
"modified version could result in the loss of important changes."
msgstr ""

#: ../../peewee/hacks.rst:28
msgid ""
"It's quite simple to implement optimistic locking in Peewee, here is a "
"base class that you can use as a starting point:"
msgstr ""

#: ../../peewee/hacks.rst:69
msgid ""
"Here's an example of how this works. Let's assume we have the following "
"model definition. Note that there's a unique constraint on the username "
"-- this is important as it provides a way to prevent double-inserts."
msgstr ""

#: ../../peewee/hacks.rst:119
msgid "Top object per group"
msgstr ""

#: ../../peewee/hacks.rst:121
msgid ""
"These examples describe several ways to query the single top item per "
"group. For a thorough discuss of various techniques, check out my blog "
"post `Querying the top item by group with Peewee ORM "
"<http://charlesleifer.com/blog/techniques-for-querying-lists-of-objects-"
"and-determining-the-top-related-item/>`_. If you are interested in the "
"more general problem of querying the top *N* items, see the section below"
" :ref:`top_n_per_group`."
msgstr ""

#: ../../peewee/hacks.rst:123
msgid ""
"In these examples we will use the *User* and *Tweet* models to find each "
"user and their most-recent tweet."
msgstr ""

#: ../../peewee/hacks.rst:125
msgid ""
"The most efficient method I found in my testing uses the ``MAX()`` "
"aggregate function."
msgstr ""

#: ../../peewee/hacks.rst:127
msgid ""
"We will perform the aggregation in a non-correlated subquery, so we can "
"be confident this method will be performant. The idea is that we will "
"select the posts, grouped by their author, whose timestamp is equal to "
"the max observed timestamp for that user."
msgstr ""

#: ../../peewee/hacks.rst:154
msgid ""
"SQLite and MySQL are a bit more lax and permit grouping by a subset of "
"the columns that are selected. This means we can do away with the "
"subquery and express it quite concisely:"
msgstr ""

#: ../../peewee/hacks.rst:167
msgid "Top N objects per group"
msgstr ""

#: ../../peewee/hacks.rst:169
msgid ""
"These examples describe several ways to query the top *N* items per group"
" reasonably efficiently. For a thorough discussion of various techniques,"
" check out my blog post `Querying the top N objects per group with Peewee"
" ORM <http://charlesleifer.com/blog/querying-the-top-n-objects-per-group-"
"with-peewee-orm/>`_."
msgstr ""

#: ../../peewee/hacks.rst:171
msgid ""
"In these examples we will use the *User* and *Tweet* models to find each "
"user and their three most-recent tweets."
msgstr ""

#: ../../peewee/hacks.rst:174
msgid "Postgres lateral joins"
msgstr ""

#: ../../peewee/hacks.rst:176
msgid ""
"`Lateral joins <http://blog.heapanalytics.com/postgresqls-powerful-new-"
"join-type-lateral/>`_ are a neat Postgres feature that allow reasonably "
"efficient correlated subqueries. They are often described as SQL ``for "
"each`` loops."
msgstr ""

#: ../../peewee/hacks.rst:178 ../../peewee/hacks.rst:231
msgid "The desired SQL is:"
msgstr ""

#: ../../peewee/hacks.rst:191
msgid ""
"To accomplish this with peewee we'll need to express the lateral join as "
"a :py:class:`Clause`, which gives us greater flexibility than the "
":py:meth:`~Query.join` method."
msgstr ""

#: ../../peewee/hacks.rst:227 ../../peewee/querying.rst:795
msgid "Window functions"
msgstr "ウィンドウ関数"

#: ../../peewee/hacks.rst:229
msgid ""
"`Window functions <http://www.postgresql.org/docs/9.1/static/tutorial-"
"window.html>`_, which are :ref:`supported by peewee <window-functions>`, "
"provide scalable, efficient performance."
msgstr ""

#: ../../peewee/hacks.rst:249
msgid ""
"To accomplish this with peewee, we will wrap the ranked Tweets in an "
"outer query that performs the filtering."
msgstr ""

#: ../../peewee/hacks.rst:276
msgid "Other methods"
msgstr ""

#: ../../peewee/hacks.rst:278
msgid ""
"If you're not using Postgres, then unfortunately you're left with options"
" that exhibit less-than-ideal performance. For a more complete overview "
"of common methods, check out `this blog post "
"<http://charlesleifer.com/blog/querying-the-top-n-objects-per-group-with-"
"peewee-orm/>`_. Below I will summarize the approaches and the "
"corresponding SQL."
msgstr ""

#: ../../peewee/hacks.rst:280
msgid ""
"Using ``COUNT``, we can get all tweets where there exist less than *N* "
"tweets with more recent timestamps:"
msgstr ""

#: ../../peewee/hacks.rst:301
msgid ""
"We can achieve similar results by doing a self-join and performing the "
"filtering in the ``HAVING`` clause:"
msgstr ""

#: ../../peewee/hacks.rst:319
msgid "The last example uses a ``LIMIT`` clause in a correlated subquery."
msgstr ""

#: ../../peewee/hacks.rst:341
msgid "Writing custom functions with SQLite"
msgstr ""

#: ../../peewee/hacks.rst:343
msgid ""
"SQLite is very easy to extend with custom functions written in Python, "
"that are then callable from your SQL statements. By using the "
":py:class:`SqliteExtDatabase` and the :py:meth:`~SqliteExtDatabase.func` "
"decorator, you can very easily define your own functions."
msgstr ""

#: ../../peewee/hacks.rst:345
msgid ""
"Here is an example function that generates a hashed version of a user-"
"supplied password. We can also use this to implement ``login`` "
"functionality for matching a user and password."
msgstr ""

#: ../../peewee/hacks.rst:370
msgid ""
"Here is how you can use the function to add a new user, storing a hashed "
"password:"
msgstr ""

#: ../../peewee/hacks.rst:378
msgid ""
"If we retrieve the user from the database, the password that's stored is "
"hashed and salted:"
msgstr ""

#: ../../peewee/hacks.rst:386
msgid ""
"To implement ``login``-type functionality, you could write something like"
" this:"
msgstr ""

#: ../../peewee/installation.rst:4
msgid "Installing and Testing"
msgstr "インストールとテスト"

#: ../../peewee/installation.rst:6
msgid "Most users will want to simply install the latest version, hosted on PyPI:"
msgstr "ほとんどのユーザーはPyPIでホストされている最新バージョンをインストールするだけです:"

#: ../../peewee/installation.rst:12
msgid "Peewee comes with two C extensions that can optionally be compiled:"
msgstr "Peeweeにはオプションでコンパイルできる2つのCエクステンションが付属しています:"

#: ../../peewee/installation.rst:14
msgid ""
"Speedups, which includes miscellaneous functions re-implemented with "
"Cython. This module will be built automatically if Cython is installed."
msgstr "Cythonで再実装されたその他の関数が含まれているSpeedupsモジュール。Cythonがインストールされている場合、このモジュールは自動的に構築されます。"

#: ../../peewee/installation.rst:15
msgid ""
"Sqlite extensions, which includes Cython implementations of the SQLite "
"date manipulation functions, the REGEXP operator, and full-text search "
"result ranking algorithms. This module should be built using the "
"``build_sqlite_ext`` command."
msgstr ""

#: ../../peewee/installation.rst:18
msgid ""
"If you have Cython installed, then the ``speedups`` module will "
"automatically be built. If you wish to also build the SQLite Cython "
"extension, you must manually run:"
msgstr ""
"Cythonがインストールされている場合は、 ``speedups`` モジュールが自動的に構築されます。SQLite "
"Cythonエクステンションをビルドする場合は、手動で実行する必要があります:"

#: ../../peewee/installation.rst:27
msgid "Installing with git"
msgstr "gitでインストールする"

#: ../../peewee/installation.rst:29
msgid ""
"The project is hosted at https://github.com/coleifer/peewee and can be "
"installed using git:"
msgstr "このプロジェクトは https://github.com/coleifer/peewee にホストされていて、gitを使用してインストールできます:"

#: ../../peewee/installation.rst:38
msgid ""
"If you would like to build the SQLite extension in a git checkout, you "
"can run:"
msgstr "git checkoutでSQLite拡張機能をビルドしたい場合は、以下のように実行できます"

#: ../../peewee/installation.rst:46
msgid ""
"On some systems you may need to use ``sudo python setup.py install`` to "
"install peewee system-wide."
msgstr ""
"いくつかのシステムではシステム全体にpeeweeをインストールするために``sudo python setup.py install`` "
"を使用する必要があります。"

#: ../../peewee/installation.rst:49
msgid "Running tests"
msgstr "テストの実行"

#: ../../peewee/installation.rst:51
msgid "You can test your installation by running the test suite."
msgstr "テストスイートを実行してインストールをテストできます。"

#: ../../peewee/installation.rst:60
msgid ""
"You can test specific features or specific database drivers using the "
"``runtests.py`` script. By default the test suite is run using SQLite and"
" the ``playhouse`` extension tests are not run. To view the available "
"test runner options, use:"
msgstr ""
"``runtests.py`` "
"スクリプトを使用して、特定の機能や特定のデータベースドライバをテストすることができます。デフォルトでは、テストスイートはSQLiteを使用して実行され、``playhouse``"
" エクステンションのテストは実行されません。使用可能なテストランナーのオプションを表示するには、次のコマンドを使用します:"

#: ../../peewee/installation.rst:69
msgid "Optional dependencies"
msgstr ""

#: ../../peewee/installation.rst:72
msgid ""
"To use Peewee, you typically won't need anything outside the standard "
"library, since most Python distributions are compiled with SQLite "
"support. You can test by running ``import sqlite3`` in the Python "
"console. If you wish to use another database, there are many DB-API "
"2.0-compatible drivers out there, such as ``pymysql`` or ``psycopg2`` for"
" MySQL and Postgres respectively."
msgstr ""

#: ../../peewee/installation.rst:79
msgid ""
"`Cython <http://cython.org/>`_: used for various speedups. Can give a big"
" boost to certain operations, particularly if you use SQLite."
msgstr ""

#: ../../peewee/installation.rst:81
msgid ""
"`apsw <https://github.com/rogerbinns/apsw>`_: an optional 3rd-party "
"SQLite binding offering greater performance and much, much saner "
"semantics than the standard library ``pysqlite``. Use with "
":py:class:`APSWDatabase`."
msgstr ""

#: ../../peewee/installation.rst:84
msgid ""
"`pycrypto <http://pythonhosted.org/pycrypto/>`_ is used for the "
":py:class:`AESEncryptedField`."
msgstr ""

#: ../../peewee/installation.rst:86
msgid "``bcrypt`` module is used for the :py:class:`PasswordField`."
msgstr ""

#: ../../peewee/installation.rst:87
msgid ""
"`vtfunc <https://github.com/coleifer/sqlite-vtfunc>` is used to provide "
"some table-valued functions for Sqlite as part of the ``sqlite_udf`` "
"extensions module."
msgstr ""

#: ../../peewee/installation.rst:90
msgid ""
"`gevent <http://www.gevent.org/>`_ is an optional dependency for "
":py:class:`SqliteQueueDatabase` (though it works with ``threading`` just "
"fine)."
msgstr ""

#: ../../peewee/installation.rst:93
msgid ""
"`BerkeleyDB <http://www.oracle.com/technetwork/database/database-"
"technologies/berkeleydb/downloads/index.html>`_ can be compiled with a "
"SQLite frontend, which works with Peewee. Compiling can be tricky so "
"`here are instructions <http://charlesleifer.com/blog/updated-"
"instructions-for-compiling-berkeleydb-with-sqlite-for-use-with-"
"python/>`_."
msgstr ""

#: ../../peewee/installation.rst:96
msgid ""
"Lastly, if you use the *Flask* or *Django* frameworks, there are helper "
"extension modules available."
msgstr ""

#: ../../peewee/models.rst:4
msgid "Models and Fields"
msgstr "モデルとフィールド"

#: ../../peewee/models.rst:6
msgid ""
":py:class:`Model` classes, :py:class:`Field` instances and model "
"instances all map to database concepts:"
msgstr ""

#: ../../peewee/models.rst:9 ../../peewee/quickstart.rst:27
msgid "Thing"
msgstr ""

#: ../../peewee/models.rst:9 ../../peewee/quickstart.rst:27
msgid "Corresponds to..."
msgstr ""

#: ../../peewee/models.rst:11 ../../peewee/quickstart.rst:29
msgid "Model class"
msgstr ""

#: ../../peewee/models.rst:11 ../../peewee/quickstart.rst:29
msgid "Database table"
msgstr ""

#: ../../peewee/models.rst:12 ../../peewee/quickstart.rst:30
msgid "Field instance"
msgstr ""

#: ../../peewee/models.rst:12 ../../peewee/quickstart.rst:30
msgid "Column on a table"
msgstr ""

#: ../../peewee/models.rst:13 ../../peewee/quickstart.rst:31
msgid "Model instance"
msgstr ""

#: ../../peewee/models.rst:13 ../../peewee/quickstart.rst:31
msgid "Row in a database table"
msgstr ""

#: ../../peewee/models.rst:16
msgid ""
"The following code shows the typical way you will define your database "
"connection and model classes."
msgstr ""

#: ../../peewee/models.rst:39
msgid "Create an instance of a :py:class:`Database`."
msgstr ""

#: ../../peewee/models.rst:45
msgid ""
"The ``db`` object will be used to manage the connections to the Sqlite "
"database. In this example we're using :py:class:`SqliteDatabase`, but you"
" could also use one of the other :ref:`database engines <databases>`."
msgstr ""

#: ../../peewee/models.rst:47
msgid "Create a base model class which specifies our database."
msgstr "データベースを指定する基本モデルクラスを作成します。"

#: ../../peewee/models.rst:55
msgid ""
"It is good practice to define a base model class which establishes the "
"database connection. This makes your code DRY as you will not have to "
"specify the database for subsequent models."
msgstr "データベース接続を確立する基本モデルクラスを定義することをお勧めします。これにより、後続のモデルにデータベースを指定する必要がないため、DRYなコードになります。"

#: ../../peewee/models.rst:57
msgid ""
"Model configuration is kept namespaced in a special class called "
"``Meta``. This convention is borrowed from Django. :ref:`Meta <model-"
"options>` configuration is passed on to subclasses, so our project's "
"models will all subclass *BaseModel*. There are :ref:`many different "
"attributes <model-options>` you can configure using *Model.Meta*."
msgstr ""
"モデル設定は、 ``Meta`` と呼ばれる特別なクラスに名前空間が維持されます。この慣例はDjangoから借用しています。:ref:`Meta "
"<model-options>` 設定はサブクラスに渡されるので、プロジェクトのモデルはすべて *BaseModel* "
"をサブクラス化します。*Model.Meta* を使用して設定できる :ref:`多くの異なる属性 <model-options>` があります。"

#: ../../peewee/models.rst:59
msgid "Define a model class."
msgstr ""

#: ../../peewee/models.rst:66
msgid ""
"Model definition uses the declarative style seen in other popular ORMs "
"like SQLAlchemy or Django. Note that we are extending the *BaseModel* "
"class so the *User* model will inherit the database connection."
msgstr ""

#: ../../peewee/models.rst:68
msgid ""
"We have explicitly defined a single *username* column with a unique "
"constraint. Because we have not specified a primary key, peewee will "
"automatically add an auto-incrementing integer primary key field named "
"*id*."
msgstr ""

#: ../../peewee/models.rst:71
msgid ""
"If you would like to start using peewee with an existing database, you "
"can use :ref:`pwiz` to automatically generate model definitions."
msgstr ""

#: ../../peewee/models.rst:78
msgid ""
"The :py:class:`Field` class is used to describe the mapping of "
":py:class:`Model` attributes to database columns. Each field type has a "
"corresponding SQL storage class (i.e. varchar, int), and conversion "
"between python data types and underlying storage is handled "
"transparently."
msgstr ""

#: ../../peewee/models.rst:80
msgid ""
"When creating a :py:class:`Model` class, fields are defined as class "
"attributes. This should look familiar to users of the django framework. "
"Here's an example:"
msgstr ""

#: ../../peewee/models.rst:89
msgid ""
"There is one special type of field, :py:class:`ForeignKeyField`, which "
"allows you to represent foreign-key relationships between models in an "
"intuitive way:"
msgstr ""

#: ../../peewee/models.rst:99
msgid "This allows you to write code like the following:"
msgstr ""

#: ../../peewee/models.rst:112
msgid ""
"For full documentation on fields, see the :ref:`Fields API notes <fields-"
"api>`"
msgstr ""

#: ../../peewee/models.rst:117
msgid "Field types table"
msgstr ""

#: ../../peewee/models.rst:120
msgid "Field Type"
msgstr ""

#: ../../peewee/models.rst:120
msgid "Sqlite"
msgstr ""

#: ../../peewee/models.rst:120
msgid "Postgresql"
msgstr ""

#: ../../peewee/models.rst:120
msgid "MySQL"
msgstr ""

#: ../../peewee/models.rst:122
msgid "``CharField``"
msgstr ""

#: ../../peewee/models.rst:122
msgid "varchar"
msgstr ""

#: ../../peewee/models.rst:123
msgid "``FixedCharField``"
msgstr ""

#: ../../peewee/models.rst:123
msgid "char"
msgstr ""

#: ../../peewee/models.rst:124
msgid "``TextField``"
msgstr ""

#: ../../peewee/models.rst:124 ../../peewee/models.rst:139
#: ../../peewee/playhouse.rst:605
msgid "text"
msgstr ""

#: ../../peewee/models.rst:124
msgid "longtext"
msgstr ""

#: ../../peewee/models.rst:125
msgid "``DateTimeField``"
msgstr ""

#: ../../peewee/models.rst:125
msgid "datetime"
msgstr ""

#: ../../peewee/models.rst:125
msgid "timestamp"
msgstr ""

#: ../../peewee/models.rst:126
msgid "``IntegerField``"
msgstr ""

#: ../../peewee/models.rst:126 ../../peewee/models.rst:127
#: ../../peewee/models.rst:130 ../../peewee/models.rst:131
#: ../../peewee/models.rst:133 ../../peewee/models.rst:134
#: ../../peewee/models.rst:137 ../../peewee/playhouse.rst:601
msgid "integer"
msgstr ""

#: ../../peewee/models.rst:127
msgid "``BooleanField``"
msgstr ""

#: ../../peewee/models.rst:127
msgid "boolean"
msgstr ""

#: ../../peewee/models.rst:127
msgid "bool"
msgstr ""

#: ../../peewee/models.rst:128
msgid "``FloatField``"
msgstr ""

#: ../../peewee/models.rst:128 ../../peewee/models.rst:129
#: ../../peewee/playhouse.rst:602
msgid "real"
msgstr ""

#: ../../peewee/models.rst:129
msgid "``DoubleField``"
msgstr ""

#: ../../peewee/models.rst:129
msgid "double precision"
msgstr ""

#: ../../peewee/models.rst:130
msgid "``BigIntegerField``"
msgstr ""

#: ../../peewee/models.rst:130
msgid "bigint"
msgstr ""

#: ../../peewee/models.rst:131
msgid "``SmallIntegerField``"
msgstr ""

#: ../../peewee/models.rst:131
msgid "smallint"
msgstr ""

#: ../../peewee/models.rst:132
msgid "``DecimalField``"
msgstr ""

#: ../../peewee/models.rst:132
msgid "decimal"
msgstr ""

#: ../../peewee/models.rst:132
msgid "numeric"
msgstr ""

#: ../../peewee/models.rst:133
msgid "``PrimaryKeyField``"
msgstr ""

#: ../../peewee/models.rst:133
msgid "serial"
msgstr ""

#: ../../peewee/models.rst:134
msgid "``ForeignKeyField``"
msgstr ""

#: ../../peewee/models.rst:135
msgid "``DateField``"
msgstr ""

#: ../../peewee/models.rst:135
msgid "date"
msgstr ""

#: ../../peewee/models.rst:136
msgid "``TimeField``"
msgstr ""

#: ../../peewee/models.rst:136
msgid "time"
msgstr ""

#: ../../peewee/models.rst:137
msgid "``TimestampField``"
msgstr ""

#: ../../peewee/models.rst:138
msgid "``BlobField``"
msgstr ""

#: ../../peewee/models.rst:138
msgid "blob"
msgstr ""

#: ../../peewee/models.rst:138
msgid "bytea"
msgstr ""

#: ../../peewee/models.rst:139
msgid "``UUIDField``"
msgstr ""

#: ../../peewee/models.rst:139
msgid "uuid"
msgstr ""

#: ../../peewee/models.rst:139
msgid "varchar(40)"
msgstr ""

#: ../../peewee/models.rst:140
msgid "``BareField``"
msgstr ""

#: ../../peewee/models.rst:140
msgid "untyped"
msgstr ""

#: ../../peewee/models.rst:140
msgid "not supported"
msgstr ""

#: ../../peewee/models.rst:144
msgid ""
"Don't see the field you're looking for in the above table? It's easy to "
"create custom field types and use them with your models."
msgstr ""

#: ../../peewee/models.rst:146
msgid ":ref:`custom-fields`"
msgstr ""

#: ../../peewee/models.rst:147
msgid ":py:class:`Database`, particularly the ``fields`` parameter."
msgstr ""

#: ../../peewee/models.rst:150
msgid "Field initialization arguments"
msgstr ""

#: ../../peewee/models.rst:152
msgid "Parameters accepted by all field types and their default values:"
msgstr ""

#: ../../peewee/models.rst:154
msgid ""
"``null = False`` -- boolean indicating whether null values are allowed to"
" be stored"
msgstr ""

#: ../../peewee/models.rst:155
msgid ""
"``index = False`` -- boolean indicating whether to create an index on "
"this column"
msgstr ""

#: ../../peewee/models.rst:156
msgid ""
"``unique = False`` -- boolean indicating whether to create a unique index"
" on this column. See also :ref:`adding composite indexes "
"<model_indexes>`."
msgstr ""

#: ../../peewee/models.rst:157
msgid ""
"``verbose_name = None`` -- string representing the \"user-friendly\" name"
" of this field"
msgstr ""

#: ../../peewee/models.rst:158
msgid ""
"``help_text = None`` -- string representing any helpful text for this "
"field"
msgstr ""

#: ../../peewee/models.rst:159
msgid ""
"``db_column = None`` -- string representing the underlying column to use "
"if different, useful for legacy databases"
msgstr ""

#: ../../peewee/models.rst:160
msgid ""
"``default = None`` -- any value to use as a default for uninitialized "
"models; If ``callable``, will be called to produce value"
msgstr ""

#: ../../peewee/models.rst:161
msgid ""
"``choices = None`` -- an optional iterable containing 2-tuples of "
"``value``, ``display``"
msgstr ""

#: ../../peewee/models.rst:162
msgid ""
"``primary_key = False`` -- whether this field is the primary key for the "
"table"
msgstr ""

#: ../../peewee/models.rst:163
msgid "``sequence = None`` -- sequence to populate field (if backend supports it)"
msgstr ""

#: ../../peewee/models.rst:164
msgid ""
"``constraints = None`` - a list of one or more constraints, e.g. "
"``[Check('price > 0')]``"
msgstr ""

#: ../../peewee/models.rst:165
msgid ""
"``schema = None`` -- optional name of the schema to use, if your db "
"supports this."
msgstr ""

#: ../../peewee/models.rst:168
msgid "Some fields take special parameters..."
msgstr ""

#: ../../peewee/models.rst:171
msgid "Field type"
msgstr ""

#: ../../peewee/models.rst:171
msgid "Special Parameters"
msgstr ""

#: ../../peewee/models.rst:173
msgid ":py:class:`CharField`"
msgstr ""

#: ../../peewee/models.rst:175
msgid ":py:class:`FixedCharField`"
msgstr ""

#: ../../peewee/models.rst:177
msgid ":py:class:`DateTimeField`"
msgstr ""

#: ../../peewee/models.rst:177 ../../peewee/models.rst:179
#: ../../peewee/models.rst:181
msgid "``formats``"
msgstr ""

#: ../../peewee/models.rst:179
msgid ":py:class:`DateField`"
msgstr ""

#: ../../peewee/models.rst:181
msgid ":py:class:`TimeField`"
msgstr ""

#: ../../peewee/models.rst:183
msgid ":py:class:`TimestampField`"
msgstr ""

#: ../../peewee/models.rst:183
msgid "``resolution``, ``utc``"
msgstr ""

#: ../../peewee/models.rst:185
msgid ":py:class:`DecimalField`"
msgstr ""

#: ../../peewee/models.rst:185
msgid "``max_digits``, ``decimal_places``, ``auto_round``, ``rounding``"
msgstr ""

#: ../../peewee/models.rst:188
msgid ":py:class:`ForeignKeyField`"
msgstr ""

#: ../../peewee/models.rst:188
msgid ""
"``rel_model``, ``related_name``, ``to_field``, ``on_delete``, "
"``on_update``, ``extra``"
msgstr ""

#: ../../peewee/models.rst:191
msgid ":py:class:`BareField`"
msgstr ""

#: ../../peewee/models.rst:191
msgid "``coerce``"
msgstr ""

#: ../../peewee/models.rst:195
msgid ""
"Both ``default`` and ``choices`` could be implemented at the database "
"level as *DEFAULT* and *CHECK CONSTRAINT* respectively, but any "
"application change would require a schema change. Because of this, "
"``default`` is implemented purely in python and ``choices`` are not "
"validated but exist for metadata purposes only."
msgstr ""

#: ../../peewee/models.rst:197
msgid ""
"To add database (server-side) constraints, use the ``constraints`` "
"parameter."
msgstr ""

#: ../../peewee/models.rst:200
msgid "Default field values"
msgstr ""

#: ../../peewee/models.rst:202
msgid ""
"Peewee can provide default values for fields when objects are created. "
"For example to have an ``IntegerField`` default to zero rather than "
"``NULL``, you could declare the field with a default value:"
msgstr ""

#: ../../peewee/models.rst:212
msgid ""
"In some instances it may make sense for the default value to be dynamic. "
"A common scenario is using the current date and time. Peewee allows you "
"to specify a function in these cases, whose return value will be used "
"when the object is created. Note we only provide the function, we do not "
"actually *call* it:"
msgstr ""

#: ../../peewee/models.rst:225
msgid ""
"If you are using a field that accepts a mutable type (`list`, `dict`, "
"etc), and would like to provide a default, it is a good idea to wrap your"
" default value in a simple function so that multiple model instances are "
"not sharing a reference to the same underlying object:"
msgstr ""

#: ../../peewee/models.rst:240
msgid ""
"The database can also provide the default value for a field. While peewee"
" does not explicitly provide an API for setting a server-side default "
"value, you can use the ``constraints`` parameter to specify the server "
"default:"
msgstr ""

#: ../../peewee/models.rst:251
msgid ""
"**Remember:** when using the ``default`` parameter, the values are set by"
" Peewee rather than being a part of the actual table and column "
"definition."
msgstr ""

#: ../../peewee/models.rst:255
msgid "ForeignKeyField"
msgstr ""

#: ../../peewee/models.rst:257
msgid ""
":py:class:`ForeignKeyField` is a special field type that allows one model"
" to reference another. Typically a foreign key will contain the primary "
"key of the model it relates to (but you can specify a particular column "
"by specifying a ``to_field``)."
msgstr ""

#: ../../peewee/models.rst:259
msgid ""
"Foreign keys allow data to be `normalized "
"<http://en.wikipedia.org/wiki/Database_normalization>`_. In our example "
"models, there is a foreign key from ``Tweet`` to ``User``. This means "
"that all the users are stored in their own table, as are the tweets, and "
"the foreign key from tweet to user allows each tweet to *point* to a "
"particular user object."
msgstr ""

#: ../../peewee/models.rst:261
msgid ""
"In peewee, accessing the value of a :py:class:`ForeignKeyField` will "
"return the entire related object, e.g.:"
msgstr ""

#: ../../peewee/models.rst:269
msgid ""
"In the example above the ``User`` data was selected as part of the query."
" For more examples of this technique, see the :ref:`Avoiding N+1 "
"<nplusone>` document."
msgstr ""

#: ../../peewee/models.rst:271
msgid ""
"If we did not select the ``User``, though, then an additional query would"
" be issued to fetch the associated ``User`` data:"
msgstr ""

#: ../../peewee/models.rst:281
msgid ""
"Sometimes you only need the associated primary key value from the foreign"
" key column. In this case, Peewee follows the convention established by "
"Django, of allowing you to access the raw foreign key value by appending "
"``\"_id\"`` to the foreign key field's name:"
msgstr ""

#: ../../peewee/models.rst:291
msgid ""
":py:class:`ForeignKeyField` allows for a backreferencing property to be "
"bound to the target model. Implicitly, this property will be named "
"`classname_set`, where `classname` is the lowercase name of the class, "
"but can be overridden via the parameter ``related_name``:"
msgstr ""

#: ../../peewee/models.rst:310
msgid "DateTimeField, DateField and TimeField"
msgstr ""

#: ../../peewee/models.rst:312
msgid ""
"The three fields devoted to working with dates and times have special "
"properties which allow access to things like the year, month, hour, etc."
msgstr ""

#: ../../peewee/models.rst:315
msgid ":py:class:`DateField` has properties for:"
msgstr ""

#: ../../peewee/models.rst:317
msgid "``year``"
msgstr ""

#: ../../peewee/models.rst:318
msgid "``month``"
msgstr ""

#: ../../peewee/models.rst:319
msgid "``day``"
msgstr ""

#: ../../peewee/models.rst:321
msgid ":py:class:`TimeField` has properties for:"
msgstr ""

#: ../../peewee/models.rst:323
msgid "``hour``"
msgstr ""

#: ../../peewee/models.rst:324
msgid "``minute``"
msgstr ""

#: ../../peewee/models.rst:325
msgid "``second``"
msgstr ""

#: ../../peewee/models.rst:327
msgid ":py:class:`DateTimeField` has all of the above."
msgstr ""

#: ../../peewee/models.rst:329
msgid ""
"These properties can be used just like any other expression. Let's say we"
" have an events calendar and want to highlight all the days in the "
"current month that have an event attached:"
msgstr ""

#: ../../peewee/models.rst:344
msgid ""
"SQLite does not have a native date type, so dates are stored in formatted"
" text columns. To ensure that comparisons work correctly, the dates need "
"to be formatted so they are sorted lexicographically. That is why they "
"are stored, by default, as ``YYYY-MM-DD HH:MM:SS``."
msgstr ""

#: ../../peewee/models.rst:347
msgid "BareField"
msgstr ""

#: ../../peewee/models.rst:349
msgid ""
"The :py:class:`BareField` class is intended to be used only with SQLite. "
"Since SQLite uses dynamic typing and data-types are not enforced, it can "
"be perfectly fine to declare fields without *any* data-type. In those "
"cases you can use :py:class:`BareField`. It is also common for SQLite "
"virtual tables to use meta-columns or untyped columns, so for those cases"
" as well you may wish to use an untyped field."
msgstr ""

#: ../../peewee/models.rst:351
msgid ""
":py:class:`BareField` accepts a special parameter ``coerce``. This "
"parameter is a function that takes a value coming from the database and "
"converts it into the appropriate Python type. For instance, if you have a"
" virtual table with an un-typed column but you know that it will return "
"``int`` objects, you can specify ``coerce=int``."
msgstr ""

#: ../../peewee/models.rst:356
msgid "Creating a custom field"
msgstr ""

#: ../../peewee/models.rst:358
msgid ""
"It isn't too difficult to add support for custom field types in peewee. "
"In this example we will create a UUID field for postgresql (which has a "
"native UUID column type)."
msgstr ""

#: ../../peewee/models.rst:360
msgid ""
"To add a custom field type you need to first identify what type of column"
" the field data will be stored in. If you just want to add python "
"behavior atop, say, a decimal field (for instance to make a currency "
"field) you would just subclass :py:class:`DecimalField`. On the other "
"hand, if the database offers a custom column type you will need to let "
"peewee know. This is controlled by the :py:attr:`Field.db_field` "
"attribute."
msgstr ""

#: ../../peewee/models.rst:362
msgid "Let's start by defining our UUID field:"
msgstr ""

#: ../../peewee/models.rst:369
msgid ""
"We will store the UUIDs in a native UUID column. Since psycopg2 treats "
"the data as a string by default, we will add two methods to the field to "
"handle:"
msgstr ""

#: ../../peewee/models.rst:371
msgid "The data coming out of the database to be used in our application"
msgstr ""

#: ../../peewee/models.rst:372
msgid "The data from our python app going into the database"
msgstr ""

#: ../../peewee/models.rst:387
msgid ""
"Now, we need to let the database know how to map this *uuid* label to an "
"actual *uuid* column type in the database. There are 2 ways of doing "
"this:"
msgstr ""

#: ../../peewee/models.rst:389
msgid "Specify the overrides in the :py:class:`Database` constructor:"
msgstr ""

#: ../../peewee/models.rst:395
msgid "Register them class-wide using :py:meth:`Database.register_fields`:"
msgstr ""

#: ../../peewee/models.rst:402
msgid ""
"That is it! Some fields may support exotic operations, like the "
"postgresql HStore field acts like a key/value store and has custom "
"operators for things like *contains* and *update*. You can specify "
":ref:`custom operations <custom-operators>` as well. For example code, "
"check out the source code for the :py:class:`HStoreField`, in "
"``playhouse.postgres_ext``."
msgstr ""

#: ../../peewee/models.rst:405
msgid "Creating model tables"
msgstr "モデルテーブルの作成"

#: ../../peewee/models.rst:407
msgid ""
"In order to start using our models, its necessary to open a connection to"
" the database and create the tables first. Peewee will run the necessary "
"*CREATE TABLE* queries, additionally creating any constraints and "
"indexes."
msgstr ""

#: ../../peewee/models.rst:418
msgid ""
"Strictly speaking, it is not necessary to call "
":py:meth:`~Database.connect` but it is good practice to be explicit. That"
" way if something goes wrong, the error occurs at the connect step, "
"rather than some arbitrary time later."
msgstr ""

#: ../../peewee/models.rst:421
msgid ""
"Peewee can determine if your tables already exist, and conditionally "
"create them:"
msgstr ""

#: ../../peewee/models.rst:428
msgid ""
"After you have created your tables, if you choose to modify your database"
" schema (by adding, removing or otherwise changing the columns) you will "
"need to either:"
msgstr ""

#: ../../peewee/models.rst:430
msgid "Drop the table and re-create it."
msgstr ""

#: ../../peewee/models.rst:431
msgid ""
"Run one or more *ALTER TABLE* queries. Peewee comes with a schema "
"migration tool which can greatly simplify this. Check the :ref:`schema "
"migrations <migrate>` docs for details."
msgstr ""

#: ../../peewee/models.rst:436
msgid "Model options and table metadata"
msgstr "モデルオプションとテーブルのメタデータ"

#: ../../peewee/models.rst:438
msgid ""
"In order not to pollute the model namespace, model-specific configuration"
" is placed in a special class called *Meta* (a convention borrowed from "
"the django framework):"
msgstr ""

#: ../../peewee/models.rst:452
msgid ""
"This instructs peewee that whenever a query is executed on *Person* to "
"use the contacts database."
msgstr ""

#: ../../peewee/models.rst:455
msgid ""
"Take a look at :ref:`the sample models <blog-models>` - you will notice "
"that we created a ``BaseModel`` that defined the database, and then "
"extended. This is the preferred way to define a database and create "
"models."
msgstr ""

#: ../../peewee/models.rst:457
msgid ""
"Once the class is defined, you should not access ``ModelClass.Meta``, but"
" instead use ``ModelClass._meta``:"
msgstr ""

#: ../../peewee/models.rst:469
msgid ""
"The :py:class:`ModelOptions` class implements several methods which may "
"be of use for retrieving model metadata (such as lists of fields, foreign"
" key relationships, and more)."
msgstr ""

#: ../../peewee/models.rst:482
msgid ""
"There are several options you can specify as ``Meta`` attributes. While "
"most options are inheritable, some are table-specific and will not be "
"inherited by subclasses."
msgstr ""

#: ../../peewee/models.rst:485 ../../peewee/playhouse.rst:3532
#: ../../peewee/playhouse.rst:4243
msgid "Option"
msgstr ""

#: ../../peewee/models.rst:485 ../../peewee/playhouse.rst:3532
#: ../../peewee/querying.rst:883 ../../peewee/querying.rst:901
#: ../../peewee/querying.rst:919
msgid "Meaning"
msgstr ""

#: ../../peewee/models.rst:485
msgid "Inheritable?"
msgstr ""

#: ../../peewee/models.rst:487
msgid "``database``"
msgstr ""

#: ../../peewee/models.rst:487
msgid "database for model"
msgstr ""

#: ../../peewee/models.rst:487 ../../peewee/models.rst:489
#: ../../peewee/models.rst:490 ../../peewee/models.rst:491
#: ../../peewee/models.rst:492 ../../peewee/models.rst:494
#: ../../peewee/models.rst:495 ../../peewee/models.rst:496
#: ../../peewee/models.rst:497
msgid "yes"
msgstr ""

#: ../../peewee/models.rst:488
msgid "``db_table``"
msgstr ""

#: ../../peewee/models.rst:488
msgid "name of the table to store data"
msgstr ""

#: ../../peewee/models.rst:488 ../../peewee/models.rst:493
msgid "no"
msgstr ""

#: ../../peewee/models.rst:489
msgid "``db_table_func``"
msgstr ""

#: ../../peewee/models.rst:489
msgid "function that accepts model and returns a table name"
msgstr ""

#: ../../peewee/models.rst:490
msgid "``indexes``"
msgstr ""

#: ../../peewee/models.rst:490
msgid "a list of fields to index"
msgstr ""

#: ../../peewee/models.rst:491
msgid "``order_by``"
msgstr ""

#: ../../peewee/models.rst:491
msgid "a list of fields to use for default ordering"
msgstr ""

#: ../../peewee/models.rst:492
msgid "``primary_key``"
msgstr ""

#: ../../peewee/models.rst:492
msgid "a :py:class:`CompositeKey` instance"
msgstr ""

#: ../../peewee/models.rst:493
msgid "``table_alias``"
msgstr ""

#: ../../peewee/models.rst:493
msgid "an alias to use for the table in queries"
msgstr ""

#: ../../peewee/models.rst:494
msgid "``schema``"
msgstr ""

#: ../../peewee/models.rst:494
msgid "the database schema for the model"
msgstr ""

#: ../../peewee/models.rst:495
msgid "``constraints``"
msgstr ""

#: ../../peewee/models.rst:495
msgid "a list of table constraints"
msgstr ""

#: ../../peewee/models.rst:496
msgid "``validate_backrefs``"
msgstr ""

#: ../../peewee/models.rst:496
msgid "ensure backrefs do not conflict with other attributes."
msgstr ""

#: ../../peewee/models.rst:497
msgid "``only_save_dirty``"
msgstr ""

#: ../../peewee/models.rst:497
msgid "when calling model.save(), only save dirty fields"
msgstr ""

#: ../../peewee/models.rst:500
msgid "Here is an example showing inheritable versus non-inheritable attributes:"
msgstr ""

#: ../../peewee/models.rst:519
msgid "Meta.order_by"
msgstr ""

#: ../../peewee/models.rst:521
msgid ""
"Specifying a default ordering is, in my opinion, a bad idea. It's better "
"to be explicit in your code when you want to sort your results."
msgstr ""

#: ../../peewee/models.rst:523
msgid ""
"That said, to specify a default ordering, the syntax is similar to that "
"of Django. ``Meta.order_by`` is a tuple of field names, and to indicate "
"descending ordering, the field name is prefixed by a ``'-'``."
msgstr ""

#: ../../peewee/models.rst:538
msgid "Meta.primary_key"
msgstr ""

#: ../../peewee/models.rst:540
msgid ""
"The ``Meta.primary_key`` attribute is used to specify either a "
":py:class:`CompositeKey` or to indicate that the model has *no* primary "
"key. Composite primary keys are discussed in more detail here: :ref"
":`composite-key`."
msgstr ""

#: ../../peewee/models.rst:542
msgid ""
"To indicate that a model should not have a primary key, then set "
"``primary_key = False``."
msgstr ""

#: ../../peewee/models.rst:565
msgid "Indexes and Constraints"
msgstr "インデックスと制約"

#: ../../peewee/models.rst:567
msgid ""
"Peewee can create indexes on single or multiple columns, optionally "
"including a *UNIQUE* constraint. Peewee also supports user-defined "
"constraints on both models and fields."
msgstr ""

#: ../../peewee/models.rst:570
msgid "Single-column indexes and constraints"
msgstr ""

#: ../../peewee/models.rst:572
msgid ""
"Single column indexes are defined using field initialization parameters. "
"The following example adds a unique index on the *username* field, and a "
"normal index on the *email* field:"
msgstr ""

#: ../../peewee/models.rst:580
msgid ""
"To add a user-defined constraint on a column, you can pass it in using "
"the ``constraints`` parameter. You may wish to specify a default value as"
" part of the schema, or add a ``CHECK`` constraint, for example:"
msgstr ""

#: ../../peewee/models.rst:591
msgid "Multi-column indexes"
msgstr ""

#: ../../peewee/models.rst:593
msgid ""
"Multi-column indexes are defined as *Meta* attributes using a nested "
"tuple. Each database index is a 2-tuple, the first part of which is a "
"tuple of the names of the fields, the second part a boolean indicating "
"whether the index should be unique."
msgstr ""

#: ../../peewee/models.rst:613
msgid ""
"Remember to add a **trailing comma** if your tuple of indexes contains "
"only one item:"
msgstr ""

#: ../../peewee/models.rst:623
msgid "Table constraints"
msgstr ""

#: ../../peewee/models.rst:625
msgid ""
"Peewee allows you to add arbitrary constraints to your :py:class:`Model`,"
" that will be part of the table definition when the schema is created."
msgstr ""

#: ../../peewee/models.rst:627
msgid ""
"For instance, suppose you have a *people* table with a composite primary "
"key of two columns, the person's first and last name. You wish to have "
"another table relate to the *people* table, and to do this, you will need"
" to define a foreign key constraint:"
msgstr ""

#: ../../peewee/models.rst:647
msgid "You can also implement ``CHECK`` constraints at the table level:"
msgstr ""

#: ../../peewee/models.rst:661
msgid "Non-integer Primary Keys, Composite Keys and other Tricks"
msgstr "非整数主キー、複合キーおよびその他のトリック"

#: ../../peewee/models.rst:664
msgid "Non-integer primary keys"
msgstr ""

#: ../../peewee/models.rst:666
msgid ""
"If you would like use a non-integer primary key (which I generally don't "
"recommend), you can specify ``primary_key=True`` when creating a field. "
"When you wish to create a new instance for a model using a non-"
"autoincrementing primary key, you need to be sure you "
":py:meth:`~Model.save` specifying ``force_insert=True``."
msgstr ""

#: ../../peewee/models.rst:675
msgid ""
"Auto-incrementing IDs are, as their name says, automatically generated "
"for you when you insert a new row into the database. When you call "
":py:meth:`~Model.save`, peewee determines whether to do an *INSERT* "
"versus an *UPDATE* based on the presence of a primary key value. Since, "
"with our uuid example, the database driver won't generate a new ID, we "
"need to specify it manually. When we call save() for the first time, pass"
" in ``force_insert = True``:"
msgstr ""

#: ../../peewee/models.rst:692
msgid ""
"Any foreign keys to a model with a non-integer primary key will have a "
"``ForeignKeyField`` use the same underlying storage type as the primary "
"key they are related to."
msgstr ""

#: ../../peewee/models.rst:697
msgid "Composite primary keys"
msgstr ""

#: ../../peewee/models.rst:699
msgid ""
"Peewee has very basic support for composite keys.  In order to use a "
"composite key, you must set the ``primary_key`` attribute of the model "
"options to a :py:class:`CompositeKey` instance:"
msgstr ""

#: ../../peewee/models.rst:712
msgid "Manually specifying primary keys"
msgstr ""

#: ../../peewee/models.rst:714
msgid ""
"Sometimes you do not want the database to automatically generate a value "
"for the primary key, for instance when bulk loading relational data. To "
"handle this on a *one-off* basis, you can simply tell peewee to turn off "
"``auto_increment`` during the import:"
msgstr ""

#: ../../peewee/models.rst:728
msgid ""
"If you *always* want to have control over the primary key, simply do not "
"use the :py:class:`PrimaryKeyField` field type, but use a normal "
":py:class:`IntegerField` (or other column type):"
msgstr ""

#: ../../peewee/models.rst:743
msgid "Models without a Primary Key"
msgstr ""

#: ../../peewee/models.rst:745
msgid ""
"If you wish to create a model with no primary key, you can specify "
"``primary_key = False`` in the inner ``Meta`` class:"
msgstr ""

#: ../../peewee/models.rst:756
msgid "This will yield the following DDL:"
msgstr ""

#: ../../peewee/models.rst:766
msgid ""
"Some model APIs may not work correctly for models without a primary key, "
"for instance :py:meth:`~Model.save` and `~Model.delete_instance` (you can"
" instead use `~Model.insert`, `~Model.update` and `~Model.delete`)."
msgstr ""

#: ../../peewee/models.rst:769
msgid "Self-referential foreign keys"
msgstr "自己参照外部キー"

#: ../../peewee/models.rst:771
msgid ""
"When creating a heirarchical structure it is necessary to create a self-"
"referential foreign key which links a child object to its parent.  "
"Because the model class is not defined at the time you instantiate the "
"self-referential foreign key, use the special string ``'self'`` to "
"indicate a self-referential foreign key:"
msgstr ""

#: ../../peewee/models.rst:779
msgid ""
"As you can see, the foreign key points *upward* to the parent object and "
"the back-reference is named *children*."
msgstr ""

#: ../../peewee/models.rst:781
msgid "Self-referential foreign-keys should always be ``null=True``."
msgstr ""

#: ../../peewee/models.rst:783
msgid ""
"When querying against a model that contains a self-referential foreign "
"key you may sometimes need to perform a self-join. In those cases you can"
" use :py:meth:`Model.alias` to create a table reference. Here is how you "
"might query the category and parent model using a self-join:"
msgstr ""

#: ../../peewee/models.rst:797
msgid "Circular foreign key dependencies"
msgstr "循環外部キー依存関係"

#: ../../peewee/models.rst:799
msgid ""
"Sometimes it happens that you will create a circular dependency between "
"two tables."
msgstr ""

#: ../../peewee/models.rst:802
msgid ""
"My personal opinion is that circular foreign keys are a code smell and "
"should be refactored (by adding an intermediary table, for instance)."
msgstr ""

#: ../../peewee/models.rst:804
msgid ""
"Adding circular foreign keys with peewee is a bit tricky because at the "
"time you are defining either foreign key, the model it points to will not"
" have been defined yet, causing a ``NameError``."
msgstr ""

#: ../../peewee/models.rst:816
msgid ""
"One option is to simply use an :py:class:`IntegerField` to store the raw "
"ID:"
msgstr ""

#: ../../peewee/models.rst:824
msgid ""
"By using :py:class:`DeferredRelation` we can get around the problem and "
"still use a foreign key field:"
msgstr ""

#: ../../peewee/models.rst:843
msgid ""
"After initializing the deferred relation, the foreign key fields are now "
"correctly set up. There is one more quirk to watch out for, though. When "
"you call :py:class:`~Model.create_table` we will again encounter the same"
" issue. For this reason peewee will not automatically create a foreign "
"key constraint for any *deferred* foreign keys."
msgstr ""

#: ../../peewee/models.rst:845
msgid "Here is how to create the tables:"
msgstr ""

#: ../../peewee/models.rst:862
msgid ""
"SQLite does not support adding constraints to existing tables through the"
" ``ALTER TABLE`` statement."
msgstr ""

#: ../../peewee/more-resources.rst:4
msgid "Additional Resources"
msgstr "その他のリソース"

#: ../../peewee/more-resources.rst:6
msgid ""
"I've written a number of blog posts about building applications and web-"
"services with peewee (and usually Flask). If you'd like to see some "
"\"real-life\" applications that use peewee, the following resources may "
"be useful:"
msgstr ""

#: ../../peewee/more-resources.rst:8
msgid ""
"`How to make a Flask blog in one hour or less "
"<http://charlesleifer.com/blog/how-to-make-a-flask-blog-in-one-hour-or-"
"less/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:9
msgid ""
"`Building a note-taking app with Flask and Peewee "
"<http://charlesleifer.com/blog/saturday-morning-hack-a-little-note-"
"taking-app-with-flask/>`_ as well as `Part 2 "
"<http://charlesleifer.com/blog/saturday-morning-hacks-revisiting-the-"
"notes-app/>`_ and `Part 3 <http://charlesleifer.com/blog/saturday-"
"morning-hacks-adding-full-text-search-to-the-flask-note-taking-app/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:10
msgid ""
"`Analytics web service built with Flask and Peewee "
"<http://charlesleifer.com/blog/saturday-morning-hacks-building-an-"
"analytics-app-with-flask/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:11
msgid ""
"`Personalized news digest (with a boolean query parser!) "
"<http://charlesleifer.com/blog/saturday-morning-hack-personalized-news-"
"digest-with-boolean-query-parser/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:12
msgid ""
"`Using peewee to explore CSV files <http://charlesleifer.com/blog/using-"
"peewee-to-explore-csv-files/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:13
msgid ""
"`Structuring Flask apps with Peewee <http://charlesleifer.com/blog"
"/structuring-flask-apps-a-how-to-for-those-coming-from-django/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:14
msgid ""
"`Creating a lastpass clone with Flask and Peewee "
"<http://charlesleifer.com/blog/creating-a-personal-password-manager/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:15
msgid ""
"`Building a web-based encrypted file manager with Flask, peewee and S3 "
"<http://charlesleifer.com/blog/web-based-encrypted-file-storage-using-"
"flask-and-aws/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:16
msgid ""
"`Creating a bookmarking web-service that takes screenshots of your "
"bookmarks <http://charlesleifer.com/blog/building-bookmarking-service-"
"python-and-phantomjs/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:17
msgid ""
"`Building a pastebin, wiki and a bookmarking service using Flask and "
"Peewee <http://charlesleifer.com/blog/dont-sweat-small-stuff-use-flask-"
"blueprints/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:18
msgid ""
"`Encrypted databases with Python and SQLCipher "
"<http://charlesleifer.com/blog/encrypted-sqlite-databases-with-python-"
"and-sqlcipher/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:19
msgid ""
"`Dear Diary, an Encrypted Command-Line Diary "
"<http://charlesleifer.com/blog/dear-diary-an-encrypted-command-line-"
"diary-with-python/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:4
msgid "Playhouse, extensions to Peewee"
msgstr "Playhouse。Peeweeへの拡張"

#: ../../peewee/playhouse.rst:6
msgid ""
"Peewee comes with numerous extension modules which are collected under "
"the ``playhouse`` namespace. Despite the silly name, there are some very "
"useful extensions, particularly those that expose vendor-specific "
"database features like the :ref:`sqlite_ext` and :ref:`postgres_ext` "
"extensions."
msgstr ""

#: ../../peewee/playhouse.rst:8
msgid ""
"Below you will find a loosely organized listing of the various modules "
"that make up the ``playhouse``."
msgstr ""

#: ../../peewee/playhouse.rst:10
msgid "**Database drivers / vendor-specific database functionality**"
msgstr ""

#: ../../peewee/playhouse.rst:12
msgid ":ref:`sqlite_ext`"
msgstr ""

#: ../../peewee/playhouse.rst:13
msgid ":ref:`sqliteq`"
msgstr ""

#: ../../peewee/playhouse.rst:14
msgid ":ref:`sqlite_udf`"
msgstr ""

#: ../../peewee/playhouse.rst:15
msgid ":ref:`apsw`"
msgstr ""

#: ../../peewee/playhouse.rst:16
msgid ":ref:`berkeleydb`"
msgstr ""

#: ../../peewee/playhouse.rst:17
msgid ":ref:`sqlcipher_ext`"
msgstr ""

#: ../../peewee/playhouse.rst:18
msgid ":ref:`postgres_ext`"
msgstr ""

#: ../../peewee/playhouse.rst:20
msgid "**High-level features**"
msgstr ""

#: ../../peewee/playhouse.rst:22
msgid ":ref:`extra-fields`"
msgstr ""

#: ../../peewee/playhouse.rst:23
msgid ":ref:`shortcuts`"
msgstr ""

#: ../../peewee/playhouse.rst:24
msgid ":ref:`hybrid`"
msgstr ""

#: ../../peewee/playhouse.rst:25
msgid ":ref:`signals`"
msgstr ""

#: ../../peewee/playhouse.rst:26
msgid ":ref:`dataset`"
msgstr ""

#: ../../peewee/playhouse.rst:27
msgid ":ref:`kv`"
msgstr ""

#: ../../peewee/playhouse.rst:28
msgid ":ref:`gfk`"
msgstr ""

#: ../../peewee/playhouse.rst:29
msgid ":ref:`csv_utils`"
msgstr ""

#: ../../peewee/playhouse.rst:31
msgid "**Database management and framework integration**"
msgstr ""

#: ../../peewee/playhouse.rst:33
msgid ":ref:`pwiz`"
msgstr ""

#: ../../peewee/playhouse.rst:34
msgid ":ref:`migrate`"
msgstr ""

#: ../../peewee/playhouse.rst:35
msgid ":ref:`pool`"
msgstr ""

#: ../../peewee/playhouse.rst:36
msgid ":ref:`reflection`"
msgstr ""

#: ../../peewee/playhouse.rst:37
msgid ":ref:`db_url`"
msgstr ""

#: ../../peewee/playhouse.rst:38
msgid ":ref:`read_slaves`"
msgstr ""

#: ../../peewee/playhouse.rst:39
msgid ":ref:`test_utils`"
msgstr ""

#: ../../peewee/playhouse.rst:40
msgid ":ref:`pskel`"
msgstr ""

#: ../../peewee/playhouse.rst:41
msgid ":ref:`flask_utils`"
msgstr ""

#: ../../peewee/playhouse.rst:42
msgid ":ref:`djpeewee`"
msgstr ""

#: ../../peewee/playhouse.rst:47
msgid "Sqlite Extensions"
msgstr "Sqlite拡張"

#: ../../peewee/playhouse.rst:49
msgid ""
"The SQLite extensions module provides support for some interesting "
"sqlite-only features:"
msgstr ""

#: ../../peewee/playhouse.rst:52
msgid "Define custom aggregates, collations and functions."
msgstr ""

#: ../../peewee/playhouse.rst:53
msgid ""
"Support for FTS3/4 (sqlite full-text search) with :ref:`BM25 ranking "
"<sqlite_bm25>`."
msgstr ""

#: ../../peewee/playhouse.rst:54
msgid ""
"C extension providing fast implementations of ranking and other utility "
"functions."
msgstr ""

#: ../../peewee/playhouse.rst:55
msgid "Support for the new FTS5 search extension."
msgstr ""

#: ../../peewee/playhouse.rst:56
msgid "Specify isolation level in transactions."
msgstr ""

#: ../../peewee/playhouse.rst:57
msgid "Support for virtual tables and SQLite C extensions."
msgstr ""

#: ../../peewee/playhouse.rst:58
msgid ""
"Support for the `closure table <http://charlesleifer.com/blog/querying-"
"tree-structures-in-sqlite-using-python-and-the-transitive-closure-"
"extension/>`_ extension, which allows efficient querying of heirarchical "
"tables."
msgstr ""

#: ../../peewee/playhouse.rst:61
msgid "sqlite_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:65
msgid ""
"A list or tuple of 2-tuples containing ``PRAGMA`` settings to configure "
"on a per-connection basis."
msgstr ""

#: ../../peewee/playhouse.rst:66
msgid ""
"Boolean flag indicating whether to use the fast implementations of "
"various SQLite user-defined functions. If Cython was installed when you "
"built ``peewee``, then these functions should be available. If not, "
"Peewee will fall back to using the slower pure-Python functions."
msgstr ""

#: ../../peewee/playhouse.rst:68
msgid ""
"Subclass of the :py:class:`SqliteDatabase` that provides some advanced "
"features only offered by Sqlite."
msgstr ""

#: ../../peewee/playhouse.rst:70
msgid "Register custom aggregates, collations and functions"
msgstr ""

#: ../../peewee/playhouse.rst:71
msgid "Support for SQLite virtual tables and C extensions"
msgstr ""

#: ../../peewee/playhouse.rst:72
msgid "Specify a row factory"
msgstr ""

#: ../../peewee/playhouse.rst:73
msgid "Advanced transactions (specify isolation level)"
msgstr ""

#: ../../peewee/playhouse.rst:77
msgid "Class-decorator for registering custom aggregation functions."
msgstr ""

#: ../../peewee/playhouse.rst:79
msgid "string name for the aggregate, defaults to the name of the class."
msgstr ""

#: ../../peewee/playhouse.rst:80
msgid ""
"integer representing number of parameters the aggregate function accepts."
" The default value, ``-1``, indicates the aggregate can accept any number"
" of parameters."
msgstr ""

#: ../../peewee/playhouse.rst:103
msgid "Unregister the given aggregate function."
msgstr ""

#: ../../peewee/playhouse.rst:107
msgid "Function decorator for registering a custom collation."
msgstr ""

#: ../../peewee/playhouse.rst:109
msgid "string name to use for this collation."
msgstr ""

#: ../../peewee/playhouse.rst:120
msgid ""
"As you might have noticed, the original ``collate_reverse`` function has "
"a special attribute called ``collation`` attached to it.  This extra "
"attribute provides a shorthand way to generate the SQL necessary to use "
"our custom collation."
msgstr ""

#: ../../peewee/playhouse.rst:127
msgid "Unregister the given collation function."
msgstr ""

#: ../../peewee/playhouse.rst:131
msgid "Function decorator for registering user-defined functions."
msgstr ""

#: ../../peewee/playhouse.rst:133
msgid "name to use for this function."
msgstr ""

#: ../../peewee/playhouse.rst:134
msgid ""
"number of parameters this function accepts.  If not provided, peewee will"
" introspect the function for you."
msgstr ""

#: ../../peewee/playhouse.rst:157
msgid "Unregister the given user-defiend function."
msgstr ""

#: ../../peewee/playhouse.rst:161
msgid ""
"Load the given C extension. If a connection is currently open in the "
"calling thread, then the extension will be loaded for that connection as "
"well as all subsequent connections."
msgstr ""

#: ../../peewee/playhouse.rst:163
msgid ""
"For example, if you've compiled the closure table extension and wish to "
"use it in your application, you might write:"
msgstr ""

#: ../../peewee/playhouse.rst:172
msgid "Unload the given SQLite extension."
msgstr ""

#: ../../peewee/playhouse.rst:177
msgid ""
"Subclass of :py:class:`Model` that signifies the model operates using a "
"virtual table provided by a sqlite extension."
msgstr ""

#: ../../peewee/playhouse.rst:180
msgid ""
"Creating a virtual model is easy, simply subclass ``VirtualModel`` and "
"specify the extension module and any options:"
msgstr ""

#: ../../peewee/playhouse.rst:194
msgid ""
"SQLite virtual tables often support configuration via arbitrary key/value"
" options which are included in the ``CREATE TABLE`` statement. To "
"configure a virtual table, you can specify options like this:"
msgstr ""

#: ../../peewee/playhouse.rst:214
msgid ""
"Model class that provides support for Sqlite's full-text search "
"extension. Models should be defined normally, however there are a couple "
"caveats:"
msgstr ""

#: ../../peewee/playhouse.rst:217
msgid ""
"Unique constraints, not null constraints, check constraints and foreign "
"keys are not supported."
msgstr ""

#: ../../peewee/playhouse.rst:218
msgid "Indexes on fields and multi-column indexes are ignored completely"
msgstr ""

#: ../../peewee/playhouse.rst:219
msgid ""
"Sqlite will treat all column types as ``TEXT`` (although you can store "
"other data types, Sqlite will treat them as text)."
msgstr ""

#: ../../peewee/playhouse.rst:221
msgid ""
"FTS models contain a ``docid`` field which is automatically created and "
"managed by SQLite (unless you choose to explicitly set it during model "
"creation). Lookups on this column **are performant**."
msgstr ""

#: ../../peewee/playhouse.rst:223
msgid ""
"``sqlite_ext`` provides a :py:class:`SearchField` field class which "
"should be used on ``FTSModel`` implementations instead of the regular "
"peewee field types. This will help prevent you accidentally creating "
"invalid column constraints."
msgstr ""

#: ../../peewee/playhouse.rst:225
msgid ""
"Because of the lack of secondary indexes, it usually makes sense to use "
"the ``docid`` primary key as a pointer to a row in a regular table. For "
"example:"
msgstr ""

#: ../../peewee/playhouse.rst:248
msgid ""
"To store a document in the document index, we will ``INSERT`` a row into "
"the ``DocumentIndex`` table, manually setting the ``docid``:"
msgstr ""

#: ../../peewee/playhouse.rst:258
msgid ""
"To perform a search and return ranked results, we can query the "
"``Document`` table and join on the ``DocumentIndex``:"
msgstr ""

#: ../../peewee/playhouse.rst:273
msgid ""
"All SQL queries on ``FTSModel`` classes will be slow **except** full-text"
" searches and ``docid`` lookups."
msgstr ""

#: ../../peewee/playhouse.rst:275
msgid "Continued examples:"
msgstr ""

#: ../../peewee/playhouse.rst:301
msgid "Examples using the BM25 ranking algorithm:"
msgstr ""

#: ../../peewee/playhouse.rst:322
msgid ""
"If the primary source of the content you are indexing exists in a "
"separate table, you can save some disk space by instructing SQLite to not"
" store an additional copy of the search index content. SQLite will still "
"create the metadata and data-structures needed to perform searches on the"
" content, but the content itself will not be stored in the search index."
msgstr ""

#: ../../peewee/playhouse.rst:324
msgid ""
"To accomplish this, you can specify a table or column using the "
"``content`` option. The `FTS4 documentation "
"<http://sqlite.org/fts3.html#section_6_2>`_ has more information."
msgstr ""

#: ../../peewee/playhouse.rst:326
msgid ""
"Here is a short code snippet illustrating how to implement this with "
"peewee:"
msgstr ""

#: ../../peewee/playhouse.rst:354
msgid ""
"The ``content`` option accepts either a single :py:class:`Field` or a "
":py:class:`Model` and can reduce the amount of storage used.  However, "
"content will need to be manually moved to/from the associated "
"``FTSModel``."
msgstr ""

#: ../../peewee/playhouse.rst:358
msgid "**FTSModel API methods:**"
msgstr ""

#: ../../peewee/playhouse.rst:362
msgid "do not re-create if table already exists."
msgstr ""

#: ../../peewee/playhouse.rst:363
msgid "options passed along when creating the table, e.g. ``content``."
msgstr ""

#: ../../peewee/playhouse.rst:367
msgid "Shorthand for generating a ``MATCH`` expression for the given term(s)."
msgstr ""

#: ../../peewee/playhouse.rst:379
msgid ""
"Shorthand way of searching for a term and sorting results by the quality "
"of the match. This is equivalent to the :py:meth:`~FTSModel.rank` example"
" code presented below."
msgstr ""

#: ../../peewee/playhouse.rst:383 ../../peewee/playhouse.rst:430
#: ../../peewee/playhouse.rst:686
msgid "Search term to use."
msgstr ""

#: ../../peewee/playhouse.rst:384 ../../peewee/playhouse.rst:431
#: ../../peewee/playhouse.rst:687
msgid ""
"A list of weights for the columns, ordered with respect to the column's "
"position in the table. **Or**, a dictionary keyed by the field or field "
"name and mapped to a value."
msgstr ""

#: ../../peewee/playhouse.rst:385 ../../peewee/playhouse.rst:432
#: ../../peewee/playhouse.rst:688
msgid "Whether the score should be returned as part of the ``SELECT`` statement."
msgstr ""

#: ../../peewee/playhouse.rst:386 ../../peewee/playhouse.rst:433
#: ../../peewee/playhouse.rst:689
msgid ""
"Alias to use for the calculated rank score. This is the attribute you "
"will use to access the score if ``with_score=True``."
msgstr ""

#: ../../peewee/playhouse.rst:406
msgid ""
"Generate an expression that will calculate and return the quality of the "
"search match. This ``rank`` can be used to sort the search results. The "
"lower the ``rank``, the better the match."
msgstr ""

#: ../../peewee/playhouse.rst:408
msgid ""
"The ``rank`` function accepts optional parameters that allow you to "
"specify weights for the various columns. If no weights are specified, all"
" columns are considered of equal importance."
msgstr ""

#: ../../peewee/playhouse.rst:426
msgid ""
"Shorthand way of searching for a term and sorting results by the quality "
"of the match, as determined by the BM25 algorithm. This is equivalent to "
"the :py:meth:`~FTSModel.bm25` example code presented below."
msgstr ""

#: ../../peewee/playhouse.rst:453
msgid ""
"Generate an expression that will calculate and return the quality of the "
"search match using the `BM25 algorithm "
"<https://en.wikipedia.org/wiki/Okapi_BM25>`_. This value can be used to "
"sort the search results, and the lower the value the better the match."
msgstr ""

#: ../../peewee/playhouse.rst:455
msgid ""
"The ``bm25`` function accepts optional parameters that allow you to "
"specify weights for the various columns. If no weights are specified, all"
" columns are considered of equal importance."
msgstr ""

#: ../../peewee/playhouse.rst:471
msgid ""
"Rebuild the search index -- this only works when the ``content`` option "
"was specified during table creation."
msgstr ""

#: ../../peewee/playhouse.rst:476
msgid "Optimize the search index."
msgstr ""

#: ../../peewee/playhouse.rst:481
msgid ""
"Whether the contents of this field should be excluded from the full-text "
"search index."
msgstr ""

#: ../../peewee/playhouse.rst:482
msgid "Name of the underlying database column."
msgstr ""

#: ../../peewee/playhouse.rst:483
msgid ""
"Function used to convert the value from the database into the appropriate"
" Python format."
msgstr ""

#: ../../peewee/playhouse.rst:488
msgid ""
"Field class suitable for working with JSON stored and manipulated using "
"the `JSON1 extension <https://www.sqlite.org/json1.html>`_."
msgstr ""

#: ../../peewee/playhouse.rst:490
msgid ""
"Most functions that operate on JSON fields take a ``path`` argument. The "
"JSON documents specify that the path should begin with ``'$'`` followed "
"by zero or more instances of ``'.objectlabel'`` or ``'[arrayindex]'``. "
"Peewee simplifies this by allowing you to omit the ``'$'`` character and "
"just specify the path you need or ``None`` for an empty path:"
msgstr ""

#: ../../peewee/playhouse.rst:492
msgid "``path=''`` --> ``'$'``"
msgstr ""

#: ../../peewee/playhouse.rst:493
msgid "``path='tags'`` --> ``'$.tags'``"
msgstr ""

#: ../../peewee/playhouse.rst:494
msgid "``path='[0][1].bar'`` --> ``'$[0][1].bar'``"
msgstr ""

#: ../../peewee/playhouse.rst:495
msgid "``path='metadata[0]'`` --> ``'$.metadata[0]'``"
msgstr ""

#: ../../peewee/playhouse.rst:496
msgid "``path='user.data.email'`` --> ``'$.user.data.email'``"
msgstr ""

#: ../../peewee/playhouse.rst:500
msgid ""
"Return the number of items in a JSON array at the given path. If the path"
" is omitted, then return the number of items in the top-level array."
msgstr ""

#: ../../peewee/playhouse.rst:502
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jarraylen>`_."
msgstr ""

#: ../../peewee/playhouse.rst:506
msgid ""
"Return the value at the given path. If the value is a JSON object or "
"array, it will be decoded into a ``dict`` or ``list``. If the value is a "
"scalar type, string or ``null`` then it will be returned as the "
"appropriate Python type."
msgstr ""

#: ../../peewee/playhouse.rst:508
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jex>`_."
msgstr ""

#: ../../peewee/playhouse.rst:525
msgid ""
"Set values stored in the input JSON string using the given path/value "
"pairs. The ``set`` function returns a **new** JSON string formed by "
"updating the input JSON with the given path/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:527
msgid "If the path does not exist, it **will** be created."
msgstr ""

#: ../../peewee/playhouse.rst:529
msgid "Similarly, if the path does exist, it **will** be overwritten."
msgstr ""

#: ../../peewee/playhouse.rst:531
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jset>`_."
msgstr ""

#: ../../peewee/playhouse.rst:573
msgid ""
"Insert the given path/value pairs into the JSON string stored in the "
"field. The ``insert`` function returns a **new** JSON string formed by "
"updating the input JSON with the given path/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:575
msgid "If the path already exists, it will **not** be overwritten."
msgstr ""

#: ../../peewee/playhouse.rst:577
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jins>`_."
msgstr ""

#: ../../peewee/playhouse.rst:581
msgid ""
"Replace values stored in the input JSON string using the given path/value"
" pairs. The ``replace`` function returns a **new** JSON string formed by "
"updating the input JSON with the given path/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:583
msgid "If the path does not exist, it will **not** be created."
msgstr ""

#: ../../peewee/playhouse.rst:585
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jrepl>`_."
msgstr ""

#: ../../peewee/playhouse.rst:589
msgid ""
"Remove values referenced by the given path(s). The ``remove`` function "
"returns a **new** JSON string formed by removing the specified paths from"
" the input JSON string."
msgstr ""

#: ../../peewee/playhouse.rst:591
msgid ""
"The process for removing fields from a JSON column is similar to the way "
"you :py:meth:`~JSONField.set` them. For a code example, see "
":ref:`updating JSON data <updating-json>`."
msgstr ""

#: ../../peewee/playhouse.rst:593
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jrm>`_."
msgstr ""

#: ../../peewee/playhouse.rst:597
msgid ""
"Return a string indicating the type of object stored in the field. You "
"can optionally supply a path to specify a sub-item. The types of objects "
"are:"
msgstr ""

#: ../../peewee/playhouse.rst:599
msgid "object"
msgstr ""

#: ../../peewee/playhouse.rst:600
msgid "array"
msgstr ""

#: ../../peewee/playhouse.rst:603
msgid "true"
msgstr ""

#: ../../peewee/playhouse.rst:604
msgid "false"
msgstr ""

#: ../../peewee/playhouse.rst:606
msgid "null  <-- the string \"null\" means an actual NULL value"
msgstr ""

#: ../../peewee/playhouse.rst:607
msgid "NULL  <-- an actual NULL value means the path was not found"
msgstr ""

#: ../../peewee/playhouse.rst:609
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jtype>`_."
msgstr ""

#: ../../peewee/playhouse.rst:613
msgid ""
"The ``children`` function corresponds to ``json_each``, a table-valued "
"function that walks the JSON value provided and returns the immediate "
"children of the top-level array or object. If a path is specified, then "
"that path is treated as the top-most element."
msgstr ""

#: ../../peewee/playhouse.rst:615
msgid ""
"The rows returned by calls to ``children()`` have the following "
"attributes:"
msgstr ""

#: ../../peewee/playhouse.rst:617
msgid "``key``: the key of the current element relative to its parent."
msgstr ""

#: ../../peewee/playhouse.rst:618
msgid "``value``: the value of the current element."
msgstr ""

#: ../../peewee/playhouse.rst:619
msgid "``type``: one of the data-types (see :py:meth:`~JSONField.json_type`)."
msgstr ""

#: ../../peewee/playhouse.rst:620
msgid ""
"``atom``: the scalar value for primitive types, ``NULL`` for arrays and "
"objects."
msgstr ""

#: ../../peewee/playhouse.rst:621
msgid "``id``: a unique ID referencing the current node in the tree."
msgstr ""

#: ../../peewee/playhouse.rst:622
msgid "``parent``: the ID of the containing node."
msgstr ""

#: ../../peewee/playhouse.rst:623
msgid "``fullkey``: the full path describing the current element."
msgstr ""

#: ../../peewee/playhouse.rst:624
msgid "``path``: the path to the container of the current row."
msgstr ""

#: ../../peewee/playhouse.rst:626 ../../peewee/playhouse.rst:636
msgid ""
"For examples, see `my blog post on JSON1 <http://charlesleifer.com/blog"
"/using-the-sqlite-json1-and-fts5-extensions-with-python/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:628
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jeach>`_."
msgstr ""

#: ../../peewee/playhouse.rst:632
msgid ""
"The ``tree`` function corresponds to ``json_tree``, a table-valued "
"function that walks the JSON value provided and recursively returns all "
"descendants of the given root node. If a path is specified, then that "
"path is treated as the root node element."
msgstr ""

#: ../../peewee/playhouse.rst:634
msgid ""
"The rows returned by calls to ``tree()`` have the same attributes as rows"
" returned by calls to :py:meth:`~JSONField.children`."
msgstr ""

#: ../../peewee/playhouse.rst:638
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jtree>`_."
msgstr ""

#: ../../peewee/playhouse.rst:643
msgid ""
"Subclass of :py:class:`PrimaryKeyField` that uses a monotonically-"
"increasing value for the primary key. This differs from the default "
"SQLite primary key, which simply uses the \"max + 1\" approach to "
"determining the next ID."
msgstr ""

#: ../../peewee/playhouse.rst:648
msgid ""
"Subclass of :py:class:`PrimaryKeyField` that provides access to the "
"underlying ``rowid`` field used internally by SQLite."
msgstr ""

#: ../../peewee/playhouse.rst:650
msgid ""
"When added to a Model, this field will act as the primary key. However, "
"this field will not be included by default when selecting rows from the "
"table."
msgstr ""

#: ../../peewee/playhouse.rst:655
msgid ""
"Subclass of :py:class:`PrimaryKeyField` that provides access to the "
"underlying ``docid`` field used internally by SQLite's FTS3/4 virtual "
"tables."
msgstr ""

#: ../../peewee/playhouse.rst:657
msgid ""
"This field should not be created manually, as it is only needed on "
"``FTSModel`` classes, which include it already."
msgstr ""

#: ../../peewee/playhouse.rst:662
msgid "Generate a SQLite `MATCH` expression for use in full-text searches."
msgstr ""

#: ../../peewee/playhouse.rst:671
msgid ""
"Model class that should be used to implement virtual tables using the "
"FTS5 extension. Documentation on the FTS5 extension `can be found here "
"<http://sqlite.org/fts5.html>`_. This extension behaves very similarly to"
" the FTS3 and FTS4 extensions, and the ``FTS5Model`` supports many of the"
" same APIs as :py:class:`FTSModel`."
msgstr ""

#: ../../peewee/playhouse.rst:673
msgid ""
"The ``FTS5`` extension is more strict in enforcing that no column define "
"any type or constraints. For this reason, only :py:class:`SearchField` "
"objects can be used with ``FTS5Model`` implementations."
msgstr ""

#: ../../peewee/playhouse.rst:675
msgid ""
"Additionally, ``FTS5`` comes with a built-in implementation of the BM25 "
"ranking function. Therefore, the ``search`` and ``search_bm25`` methods "
"have been overridden to use the builtin ranking functions rather than "
"user-defined functions."
msgstr ""

#: ../../peewee/playhouse.rst:679
msgid ""
"Return a boolean indicating whether the FTS5 extension is installed. If "
"it is not installed, an attempt will be made to load the extension."
msgstr ""

#: ../../peewee/playhouse.rst:683
msgid ""
"Shorthand way of searching for a term and sorting results by the quality "
"of the match. This is equivalent to the built-in ``rank`` value provided "
"by the ``FTS5`` extension."
msgstr ""

#: ../../peewee/playhouse.rst:709
msgid ""
"With FTS5, the ``search_bm25`` method is the same as the "
":py:meth:`FTS5Model.search` method."
msgstr ""

#: ../../peewee/playhouse.rst:713
msgid "Either ``'row'`` or ``'col'``."
msgstr ""

#: ../../peewee/playhouse.rst:714
msgid "Name for the vocab table. If not specified, will be \"fts5tablename_v\"."
msgstr ""

#: ../../peewee/playhouse.rst:721
msgid ""
"Factory function for creating a model class suitable for working with a "
"`transitive closure "
"<http://www.sqlite.org/cgi/src/artifact/636024302cde41b2bf0c542f81c40c624cfb7012>`_"
" table. Closure tables are :py:class:`VirtualModel` subclasses that work "
"with the transitive closure SQLite extension. These special tables are "
"designed to make it easy to efficiently query heirarchical data. The "
"SQLite extension manages an AVL tree behind-the-scenes, transparently "
"updating the tree when your table changes and making it easy to perform "
"common queries on heirarchical data."
msgstr ""

#: ../../peewee/playhouse.rst:723
msgid "To use the closure table extension in your project, you need:"
msgstr ""

#: ../../peewee/playhouse.rst:725
msgid ""
"A copy of the SQLite extension. The source code can be found in the "
"`SQLite code repository "
"<http://www.sqlite.org/cgi/src/artifact/636024302cde41b2bf0c542f81c40c624cfb7012>`_"
" or by cloning `this gist "
"<https://gist.github.com/coleifer/7f3593c5c2a645913b92>`_:"
msgstr ""

#: ../../peewee/playhouse.rst:732
msgid "Compile the extension as a shared library, e.g."
msgstr ""

#: ../../peewee/playhouse.rst:738
msgid ""
"Create a model for your hierarchical data. The only requirement here is "
"that the model has an integer primary key and a self-referential foreign "
"key. Any additional fields are fine."
msgstr ""

#: ../../peewee/playhouse.rst:750
msgid ""
"The self-referentiality can also be achieved via an intermediate table "
"(for a many-to-many relation)."
msgstr ""

#: ../../peewee/playhouse.rst:771
msgid ""
"In your application code, make sure you load the extension when you "
"instantiate your :py:class:`Database` object. This is done by passing the"
" path to the shared library to the "
":py:meth:`~SqliteExtDatabase.load_extension` method."
msgstr ""

#: ../../peewee/playhouse.rst:778
msgid "The model class containing the nodes in the tree."
msgstr ""

#: ../../peewee/playhouse.rst:779
msgid ""
"The self-referential parent-node field on the model class. If not "
"provided, peewee will introspect the model to find a suitable key."
msgstr ""

#: ../../peewee/playhouse.rst:780
msgid "The intermediate table for a many-to-many relationship."
msgstr ""

#: ../../peewee/playhouse.rst:781
msgid "For a many-to-many relationship: the originating side of the relation."
msgstr ""

#: ../../peewee/playhouse.rst:782
msgid "Returns a :py:class:`VirtualModel` for working with a closure table."
msgstr ""

#: ../../peewee/playhouse.rst:784
msgid ""
"There are two caveats you should be aware of when using the "
"``transitive_closure`` extension. First, it requires that your *source "
"model* have an integer primary key. Second, it is strongly recommended "
"that you create an index on the self-referential foreign key."
msgstr ""

#: ../../peewee/playhouse.rst:805
msgid ""
"It is now possible to perform interesting queries using the data from the"
" closure table:"
msgstr ""

#: ../../peewee/playhouse.rst:832
msgid ""
"The :py:class:`VirtualTable` returned by this function contains a handful"
" of interesting methods. The model will be a subclass of "
":py:class:`BaseClosureTable`."
msgstr ""

#: ../../peewee/playhouse.rst:838
msgid "A field for the primary key of the given node."
msgstr ""

#: ../../peewee/playhouse.rst:842
msgid "A field representing the relative depth of the given node."
msgstr ""

#: ../../peewee/playhouse.rst:846
msgid "A field representing the relative root node."
msgstr ""

#: ../../peewee/playhouse.rst:850
msgid ""
"Retrieve all descendants of the given node. If a depth is specified, only"
" nodes at that depth (relative to the given node) will be returned."
msgstr ""

#: ../../peewee/playhouse.rst:868
msgid ""
"Retrieve all ancestors of the given node. If a depth is specified, only "
"nodes at that depth (relative to the given node) will be returned."
msgstr ""

#: ../../peewee/playhouse.rst:882
msgid "Retrieve all nodes that are children of the specified node's parent."
msgstr ""

#: ../../peewee/playhouse.rst:884
msgid ""
"For an in-depth discussion of the SQLite transitive closure extension, "
"check out this blog post, `Querying Tree Structures in SQLite using "
"Python and the Transitive Closure Extension "
"<http://charlesleifer.com/blog/querying-tree-structures-in-sqlite-using-"
"python-and-the-transitive-closure-extension/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:890
msgid "SqliteQ"
msgstr ""

#: ../../peewee/playhouse.rst:892
msgid ""
"The ``playhouse.sqliteq`` module provides a subclass of "
":py:class:`SqliteExtDatabase`, that will serialize concurrent writes to a"
" SQLite database. :py:class:`SqliteQueueDatabase` can be used as a drop-"
"in replacement for the regular :py:class:`SqliteDatabase` if you want "
"simple **read and write** access to a SQLite database from **multiple "
"threads**."
msgstr ""

#: ../../peewee/playhouse.rst:898
msgid ""
"SQLite only allows one connection to write to the database at any given "
"time. As a result, if you have a multi-threaded application (like a web-"
"server, for example) that needs to write to the database, you may see "
"occasional errors when one or more of the threads attempting to write "
"cannot acquire the lock."
msgstr ""

#: ../../peewee/playhouse.rst:903
msgid ""
":py:class:`SqliteQueueDatabase` is designed to simplify things by sending"
" all write queries through a single, long-lived connection. The benefit "
"is that you get the appearance of multiple threads writing to the "
"database without conflicts or timeouts. The downside, however, is that "
"you cannot issue write transactions that encompass multiple queries -- "
"all writes run in autocommit mode, essentially."
msgstr ""

#: ../../peewee/playhouse.rst:911
msgid ""
"The module gets its name from the fact that all write queries get put "
"into a thread-safe queue. A single worker thread listens to the queue and"
" executes all queries that are sent to it."
msgstr ""

#: ../../peewee/playhouse.rst:916 ../../peewee/transactions.rst:4
msgid "Transactions"
msgstr "トランザクション"

#: ../../peewee/playhouse.rst:918
msgid ""
"Because all queries are serialized and executed by a single worker "
"thread, it is possible for transactional SQL from separate threads to be "
"executed out-of-order. In the example below, the transaction started by "
"thread \"B\" is rolled back by thread \"A\" (with bad consequences!):"
msgstr ""

#: ../../peewee/playhouse.rst:923
msgid "Thread A: UPDATE transplants SET organ='liver', ...;"
msgstr ""

#: ../../peewee/playhouse.rst:924
msgid "Thread B: BEGIN TRANSACTION;"
msgstr ""

#: ../../peewee/playhouse.rst:925
msgid "Thread B: UPDATE life_support_system SET timer += 60 ...;"
msgstr ""

#: ../../peewee/playhouse.rst:926
msgid "Thread A: ROLLBACK; -- Oh no...."
msgstr ""

#: ../../peewee/playhouse.rst:928
msgid ""
"Since there is a potential for queries from separate transactions to be "
"interleaved, the :py:meth:`~SqliteQueueDatabase.transaction` and "
":py:meth:`~SqliteQueueDatabase.atomic` methods are disabled on "
":py:class:`SqliteQueueDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:932
msgid ""
"For cases when you wish to temporarily write to the database from a "
"different thread, you can use the :py:meth:`~SqliteQueueDatabase.pause` "
"and :py:meth:`~SqliteQueueDatabase.unpause` methods. These methods block "
"the caller until the writer thread is finished with its current workload."
" The writer then disconnects and the caller takes over until ``unpause`` "
"is called."
msgstr ""

#: ../../peewee/playhouse.rst:938
msgid ""
"The :py:meth:`~SqliteQueueDatabase.stop`, "
":py:meth:`~SqliteQueueDatabase.start`, and "
":py:meth:`~SqliteQueueDatabase.is_stopped` methods can also be used to "
"control the writer thread."
msgstr ""

#: ../../peewee/playhouse.rst:943
msgid ""
"Take a look at SQLite's `isolation "
"<https://www.sqlite.org/isolation.html>`_ documentation for more "
"information about how SQLite handles concurrent connections."
msgstr ""

#: ../../peewee/playhouse.rst:948
#, fuzzy
msgid "Code sample"
msgstr "より多くの例"

#: ../../peewee/playhouse.rst:950
msgid ""
"Creating a database instance does not require any special handling. The "
":py:class:`SqliteQueueDatabase` accepts some special parameters which you"
" should be aware of, though. If you are using `gevent "
"<http://gevent.org>`_, you must specify ``use_gevent=True`` when "
"instantiating your database -- this way Peewee will know to use the "
"appropriate objects for handling queueing, thread creation, and locking."
msgstr ""

#: ../../peewee/playhouse.rst:969
msgid ""
"If ``autostart=False``, as in the above example, you will need to call "
":py:meth:`~SqliteQueueDatabase.start` to bring up the worker threads that"
" will do the actual write query execution."
msgstr ""

#: ../../peewee/playhouse.rst:979
msgid ""
"If you plan on performing SELECT queries or generally wanting to access "
"the database, you will need to call :py:meth:`~Database.connect` and "
":py:meth:`~Database.close` as you would with any other database instance."
msgstr ""

#: ../../peewee/playhouse.rst:983
msgid ""
"When your application is ready to terminate, use the "
":py:meth:`~SqliteQueueDatabase.stop` method to shut down the worker "
"thread. If there was a backlog of work, then this method will block until"
" all pending work is finished (though no new work is allowed)."
msgstr ""

#: ../../peewee/playhouse.rst:997
msgid ""
"Lastly, the :py:meth:`~SqliteQueueDatabase.is_stopped` method can be used"
" to determine whether the database writer is up and running."
msgstr ""

#: ../../peewee/playhouse.rst:1003
msgid "Sqlite User-Defined Functions"
msgstr "Sqliteユーザー定義関数"

#: ../../peewee/playhouse.rst:1005
msgid ""
"The ``sqlite_udf`` playhouse module contains a number of user-defined "
"functions, aggregates, and table-valued functions, which you may find "
"useful. The functions are grouped in collections and you can register "
"these user-defined extensions individually, by collection, or register "
"everything."
msgstr ""

#: ../../peewee/playhouse.rst:1007
msgid ""
"Scalar functions are functions which take a number of parameters and "
"return a single value. For example, converting a string to upper-case, or"
" calculating the MD5 hex digest."
msgstr ""

#: ../../peewee/playhouse.rst:1009
msgid ""
"Aggregate functions are like scalar functions that operate on multiple "
"rows of data, producing a single result. For example, calculating the sum"
" of a list of integers, or finding the smallest value in a particular "
"column."
msgstr ""

#: ../../peewee/playhouse.rst:1011
msgid ""
"Table-valued functions are simply functions that can return multiple rows"
" of data. For example, a regular-expression search function that returns "
"all the matches in a given string, or a function that accepts two dates "
"and generates all the intervening days."
msgstr ""

#: ../../peewee/playhouse.rst:1013
msgid ""
"To use table-valued functions, you will need to install the ``vtfunc`` "
"module. The ``vtfunc`` module is available `on GitHub "
"<https://github.com/coleifer/sqlite-vtfunc>`_ or can be installed using "
"``pip``."
msgstr ""

#: ../../peewee/playhouse.rst:1016
msgid "Functions, listed by collection name"
msgstr ""

#: ../../peewee/playhouse.rst:1018
msgid ""
"Scalar functions are indicated by ``(f)``, aggregate functions by "
"``(a)``, and table-valued functions by ``(t)``."
msgstr ""

#: ../../peewee/playhouse.rst:1020
msgid "``CONTROL_FLOW`` * :py:func:`if_then_else` (f)"
msgstr ""

#: ../../peewee/playhouse.rst:1022
msgid ""
"``DATE`` * :py:func:`strip_tz` (f) * :py:func:`human_delta` (f) * "
":py:func:`mintdiff` (a) * :py:func:`avgtdiff` (a) * :py:func:`duration` "
"(a) * :py:func:`date_series` (t)"
msgstr ""

#: ../../peewee/playhouse.rst:1029
msgid "``FILE`` * :py:func:`file_ext` (f) * :py:func:`file_read` (f)"
msgstr ""

#: ../../peewee/playhouse.rst:1032
msgid ""
"``HELPER`` * :py:func:`gzip` (f) * :py:func:`gunzip` (f) * "
":py:func:`hostname` (f) * :py:func:`toggle` (f) * :py:func:`setting` (f) "
"* :py:func:`clear_toggles` (f) * :py:func:`clear_settings` (f)"
msgstr ""

#: ../../peewee/playhouse.rst:1040
msgid ""
"``MATH`` * :py:func:`randomrange` (f) * :py:func:`gauss_distribution` (f)"
" * :py:func:`sqrt` (f) * :py:func:`tonumber` (f) * :py:func:`mode` (a) * "
":py:func:`minrange` (a) * :py:func:`avgrange` (a) * :py:func:`range` (a) "
"* :py:func:`median` (a) (requires cython)"
msgstr ""

#: ../../peewee/playhouse.rst:1050
msgid ""
"``STRING`` * :py:func:`substr_count` (f) * :py:func:`strip_chars` (f) * "
":py:func:`md5` (f) * :py:func:`sha1` (f) * :py:func:`sha256` (f) * "
":py:func:`sha512` (f) * :py:func:`adler32` (f) * :py:func:`crc32` (f) * "
":py:func:`damerau_levenshtein_dist` (f) (requires cython) * "
":py:func:`levenshtein_dist` (f) (requires cython) * :py:func:`str_dist` "
"(f) (requires cython) * :py:func:`regex_search` (t)"
msgstr ""

#: ../../peewee/playhouse.rst:1067
msgid "apsw, an advanced sqlite driver"
msgstr "apsw、高度なsqliteドライバ"

#: ../../peewee/playhouse.rst:1069
msgid ""
"The ``apsw_ext`` module contains a database class suitable for use with "
"the apsw sqlite driver."
msgstr ""

#: ../../peewee/playhouse.rst:1072
msgid "APSW Project page: https://github.com/rogerbinns/apsw"
msgstr ""

#: ../../peewee/playhouse.rst:1074
msgid ""
"APSW is a really neat library that provides a thin wrapper on top of "
"SQLite's C interface, making it possible to use all of SQLite's advanced "
"features."
msgstr ""

#: ../../peewee/playhouse.rst:1077
msgid "Here are just a few reasons to use APSW, taken from the documentation:"
msgstr ""

#: ../../peewee/playhouse.rst:1079
msgid ""
"APSW gives all functionality of SQLite, including virtual tables, virtual"
" file system, blob i/o, backups and file control."
msgstr ""

#: ../../peewee/playhouse.rst:1083
msgid "APSW can handle nested transactions."
msgstr ""

#: ../../peewee/playhouse.rst:1084
msgid "Unicode is handled correctly."
msgstr ""

#: ../../peewee/playhouse.rst:1085
msgid "APSW is faster."
msgstr ""

#: ../../peewee/playhouse.rst:1087
msgid ""
"For more information on the differences between apsw and pysqlite, check "
"`the apsw docs <http://rogerbinns.github.io/apsw/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1091
msgid "How to use the APSWDatabase"
msgstr ""

#: ../../peewee/playhouse.rst:1109
msgid "apsw_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:1111
msgid ""
":py:class:`APSWDatabase` extends the :py:class:`SqliteExtDatabase` and "
"inherits its advanced features."
msgstr ""

#: ../../peewee/playhouse.rst:1115
msgid "filename of sqlite database"
msgstr ""

#: ../../peewee/playhouse.rst:1116
msgid "keyword arguments passed to apsw when opening a connection"
msgstr ""

#: ../../peewee/playhouse.rst:1120
msgid ""
"Provides a way of globally registering a module.  For more information, "
"see the `documentation on virtual tables "
"<http://rogerbinns.github.io/apsw/vtable.html>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1123 ../../peewee/playhouse.rst:1130
msgid "name to use for module"
msgstr ""

#: ../../peewee/playhouse.rst:1124
msgid ""
"an object implementing the `Virtual Table "
"<http://rogerbinns.github.io/apsw/vtable.html#vttable-class>`_ interface"
msgstr ""

#: ../../peewee/playhouse.rst:1128
msgid "Unregister a module."
msgstr ""

#: ../../peewee/playhouse.rst:1133
msgid ""
"Be sure to use the ``Field`` subclasses defined in the ``apsw_ext`` "
"module, as they will properly handle adapting the data types for storage."
msgstr ""

#: ../../peewee/playhouse.rst:1136
msgid ""
"For example, instead of using ``peewee.DateTimeField``, be sure you are "
"importing and using ``playhouse.apsw_ext.DateTimeField``."
msgstr ""

#: ../../peewee/playhouse.rst:1142
msgid "BerkeleyDB backend"
msgstr "BerkeleyDBバックエンド"

#: ../../peewee/playhouse.rst:1144
msgid ""
"BerkeleyDB provides a `SQLite-compatible API "
"<http://www.oracle.com/technetwork/database/database-"
"technologies/berkeleydb/overview/sql-160887.html>`_. BerkeleyDB's SQL API"
" has many advantages over SQLite:"
msgstr ""

#: ../../peewee/playhouse.rst:1146
msgid "Higher transactions-per-second in multi-threaded environments."
msgstr ""

#: ../../peewee/playhouse.rst:1147
msgid "Built-in replication and hot backup."
msgstr ""

#: ../../peewee/playhouse.rst:1148
msgid "Fewer system calls, less resource utilization."
msgstr ""

#: ../../peewee/playhouse.rst:1149
msgid "Multi-version concurrency control."
msgstr ""

#: ../../peewee/playhouse.rst:1151
msgid ""
"For more details, Oracle has published a short `technical overview "
"<http://www.oracle.com/technetwork/database/berkeleydb/learnmore"
"/bdbvssqlite-wp-186779.pdf>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1153
msgid ""
"In order to use peewee with BerkeleyDB, you need to compile BerkeleyDB "
"with the SQL API enabled. Then compile the Python SQLite driver against "
"BerkeleyDB's sqlite replacement."
msgstr ""

#: ../../peewee/playhouse.rst:1155
msgid "Begin by downloading and compiling BerkeleyDB:"
msgstr ""

#: ../../peewee/playhouse.rst:1167
msgid ""
"Then get a copy of the standard library SQLite driver and build it "
"against BerkeleyDB:"
msgstr ""

#: ../../peewee/playhouse.rst:1177
msgid ""
"You can also find up-to-date `step by step instructions "
"<http://charlesleifer.com/blog/building-the-python-sqlite-driver-for-use-"
"with-berkeleydb/>`_ on my blog."
msgstr ""

#: ../../peewee/playhouse.rst:1181
msgid "Enable multiversion concurrency control. Default is ``False``."
msgstr ""

#: ../../peewee/playhouse.rst:1182
msgid "Set the page size ``PRAGMA``. This option only works on new databases."
msgstr ""

#: ../../peewee/playhouse.rst:1183
msgid "Set the cache size ``PRAGMA``."
msgstr ""

#: ../../peewee/playhouse.rst:1185
msgid ""
"Subclass of the :py:class:`SqliteExtDatabase` that supports connecting to"
" BerkeleyDB-backed version of SQLite."
msgstr ""

#: ../../peewee/playhouse.rst:1189
msgid ""
"Check whether ``pysqlite2`` was compiled against the BerkeleyDB SQLite. "
"Returns ``True`` or ``False``."
msgstr ""

#: ../../peewee/playhouse.rst:1193
msgid ""
"Check whether ``libsqlite3`` is the BerkeleyDB SQLite implementation. "
"Returns ``True`` or ``False``."
msgstr ""

#: ../../peewee/playhouse.rst:1199
msgid "Sqlcipher backend"
msgstr "Sqlcipherバックエンド"

#: ../../peewee/playhouse.rst:1201
msgid ""
"Although this extention's code is short, it has not been properly peer-"
"reviewed yet and may have introduced vulnerabilities."
msgstr ""

#: ../../peewee/playhouse.rst:1203
msgid ""
"The code contains minimum values for `passphrase` length and `kdf_iter`, "
"as well as a default value for the later. **Do not** regard these numbers"
" as advice. Consult the docs at http://sqlcipher.net/sqlcipher-api/ and "
"security experts."
msgstr ""

#: ../../peewee/playhouse.rst:1208
msgid ""
"Also note that this code relies on pysqlcipher_ and sqlcipher_, and the "
"code there might have vulnerabilities as well, but since these are widely"
" used crypto modules, we can expect \"short zero days\" there."
msgstr ""

#: ../../peewee/playhouse.rst:1216
msgid "sqlcipher_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:1220
msgid ""
"Subclass of :py:class:`SqliteDatabase` that stores the database "
"encrypted. Instead of the standard ``sqlite3`` backend, it uses "
"pysqlcipher_: a python wrapper for sqlcipher_, which -- in turn -- is an "
"encrypted wrapper around ``sqlite3``, so the API is *identical* to "
":py:class:`SqliteDatabase`'s, except for object construction parameters:"
msgstr ""

#: ../../peewee/playhouse.rst:1226
msgid "Path to encrypted database filename to open [or create]."
msgstr ""

#: ../../peewee/playhouse.rst:1227
msgid ""
"Database encryption passphrase: should be at least 8 character long (or "
"an error is raised), but it is *strongly advised* to enforce better "
"`passphrase strength`_ criteria in your implementation."
msgstr ""

#: ../../peewee/playhouse.rst:1230
msgid "[Optional] number of PBKDF2_ iterations."
msgstr ""

#: ../../peewee/playhouse.rst:1232
msgid ""
"If the ``database`` file doesn't exist, it will be *created* with "
"encryption by a key derived from ``passhprase`` with ``kdf_iter`` PBKDF2_"
" iterations."
msgstr ""

#: ../../peewee/playhouse.rst:1235
msgid ""
"When trying to open an existing database, ``passhprase`` and ``kdf_iter``"
" should be *identical* to the ones used when it was created."
msgstr ""

#: ../../peewee/playhouse.rst:1241
msgid "Notes:"
msgstr ""

#: ../../peewee/playhouse.rst:1243
msgid ""
"[Hopefully] there's no way to tell whether the passphrase is wrong or the"
" file is corrupt. In both cases -- *the first time we try to acces the "
"database* -- a :py:class:`DatabaseError` error is raised, with the "
"*exact* message: ``\"file is encrypted or is not a database\"``."
msgstr ""

#: ../../peewee/playhouse.rst:1249
msgid ""
"As mentioned above, this only happens when you *access* the databse, so "
"if you need to know *right away* whether the passphrase was correct, you "
"can trigger this check by calling [e.g.] "
":py:meth:`~Database.get_tables()` (see example below)."
msgstr ""

#: ../../peewee/playhouse.rst:1254
msgid ""
"Most applications can expect failed attempts to open the database (common"
" case: prompting the user for ``passphrase``), so the database can't be "
"hardwired into the :py:class:`Meta` of model classes. To defer "
"initialization, pass `None` in to the database."
msgstr ""

#: ../../peewee/playhouse.rst:1295
msgid ""
"See also: a slightly more elaborate `example "
"<https://gist.github.com/thedod/11048875#file-testpeeweesqlcipher-py>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1301
msgid "Postgresql Extensions"
msgstr "PostgreSQLの拡張機能"

#: ../../peewee/playhouse.rst:1303
msgid ""
"The postgresql extensions module provides a number of \"postgres-only\" "
"functions, currently:"
msgstr ""

#: ../../peewee/playhouse.rst:1306
msgid ":ref:`hstore support <hstore>`"
msgstr ""

#: ../../peewee/playhouse.rst:1307
msgid ":ref:`json support <pgjson>`, including ``jsonb`` for Postgres 9.4."
msgstr ""

#: ../../peewee/playhouse.rst:1308
msgid ":ref:`server-side cursors <server_side_cursors>`"
msgstr ""

#: ../../peewee/playhouse.rst:1309
msgid ":ref:`full-text search <pg_fts>`"
msgstr ""

#: ../../peewee/playhouse.rst:1310
msgid ":py:class:`ArrayField` field type, for storing arrays."
msgstr ""

#: ../../peewee/playhouse.rst:1311
msgid ":py:class:`HStoreField` field type, for storing key/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:1312
msgid ":py:class:`IntervalField` field type, for storing ``timedelta`` objects."
msgstr ""

#: ../../peewee/playhouse.rst:1313
msgid ":py:class:`JSONField` field type, for storing JSON data."
msgstr ""

#: ../../peewee/playhouse.rst:1314
msgid ":py:class:`BinaryJSONField` field type for the ``jsonb`` JSON data type."
msgstr ""

#: ../../peewee/playhouse.rst:1315
msgid ":py:class:`TSVectorField` field type, for storing full-text search data."
msgstr ""

#: ../../peewee/playhouse.rst:1316
msgid ":py:class:`DateTimeTZ` field type, a timezone-aware datetime field."
msgstr ""

#: ../../peewee/playhouse.rst:1318
msgid ""
"In the future I would like to add support for more of postgresql's "
"features. If there is a particular feature you would like to see added, "
"please `open a Github issue "
"<https://github.com/coleifer/peewee/issues>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1322
msgid ""
"In order to start using the features described below, you will need to "
"use the extension :py:class:`PostgresqlExtDatabase` class instead of "
":py:class:`PostgresqlDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:1324
msgid ""
"The code below will assume you are using the following database and base "
"model:"
msgstr ""

#: ../../peewee/playhouse.rst:1339
msgid "hstore support"
msgstr ""

#: ../../peewee/playhouse.rst:1341
msgid ""
"`Postgresql hstore "
"<http://www.postgresql.org/docs/current/static/hstore.html>`_ is an "
"embedded key/value store.  With hstore, you can store arbitrary key/value"
" pairs in your database alongside structured relational data."
msgstr ""

#: ../../peewee/playhouse.rst:1345
msgid "Currently the ``postgres_ext`` module supports the following operations:"
msgstr ""

#: ../../peewee/playhouse.rst:1347
msgid "Store and retrieve arbitrary dictionaries"
msgstr ""

#: ../../peewee/playhouse.rst:1348
msgid "Filter by key(s) or partial dictionary"
msgstr ""

#: ../../peewee/playhouse.rst:1349
msgid "Update/add one or more keys to an existing dictionary"
msgstr ""

#: ../../peewee/playhouse.rst:1350
msgid "Delete one or more keys from an existing dictionary"
msgstr ""

#: ../../peewee/playhouse.rst:1351
msgid "Select keys, values, or zip keys and values"
msgstr ""

#: ../../peewee/playhouse.rst:1352
msgid "Retrieve a slice of keys/values"
msgstr ""

#: ../../peewee/playhouse.rst:1353
msgid "Test for the existence of a key"
msgstr ""

#: ../../peewee/playhouse.rst:1354
msgid "Test that a key has a non-NULL value"
msgstr ""

#: ../../peewee/playhouse.rst:1358
msgid "Using hstore"
msgstr ""

#: ../../peewee/playhouse.rst:1360
msgid ""
"To start with, you will need to import the custom database class and the "
"hstore functions from ``playhouse.postgres_ext`` (see above code "
"snippet).  Then, it is as simple as adding a :py:class:`HStoreField` to "
"your model:"
msgstr ""

#: ../../peewee/playhouse.rst:1371
msgid "You can now store arbitrary key/value pairs on ``House`` instances:"
msgstr ""

#: ../../peewee/playhouse.rst:1381
msgid "You can filter by keys or partial dictionary:"
msgstr ""

#: ../../peewee/playhouse.rst:1390
msgid "Suppose you want to do an atomic update to the house:"
msgstr ""

#: ../../peewee/playhouse.rst:1404
msgid "Or, alternatively an atomic delete:"
msgstr ""

#: ../../peewee/playhouse.rst:1416
msgid "Multiple keys can be deleted at the same time:"
msgstr ""

#: ../../peewee/playhouse.rst:1422
msgid "You can select just keys, just values, or zip the two:"
msgstr ""

#: ../../peewee/playhouse.rst:1442
msgid "You can retrieve a slice of data, for example, all the garage data:"
msgstr ""

#: ../../peewee/playhouse.rst:1452
msgid "You can check for the existence of a key and filter rows accordingly:"
msgstr ""

#: ../../peewee/playhouse.rst:1468
#, fuzzy
msgid "Interval support"
msgstr "シグナルサポート"

#: ../../peewee/playhouse.rst:1470
msgid ""
"Postgres supports durations through the ``INTERVAL`` data-type (`docs "
"<https://www.postgresql.org/docs/current/static/datatype-"
"datetime.html>`_)."
msgstr ""

#: ../../peewee/playhouse.rst:1474
msgid "Field class capable of storing Python ``datetime.timedelta`` instances."
msgstr ""

#: ../../peewee/playhouse.rst:1501
msgid "JSON Support"
msgstr ""

#: ../../peewee/playhouse.rst:1503
msgid ""
"peewee has basic support for Postgres' native JSON data type, in the form"
" of :py:class:`JSONField`. As of version 2.4.7, peewee also supports the "
"Postgres 9.4 binary json ``jsonb`` type, via :py:class:`BinaryJSONField`."
msgstr ""

#: ../../peewee/playhouse.rst:1507
msgid ""
"Postgres supports a JSON data type natively as of 9.2 (full support in "
"9.3). In order to use this functionality you must be using the correct "
"version of Postgres with `psycopg2` version 2.5 or greater."
msgstr ""

#: ../../peewee/playhouse.rst:1511
msgid ""
"To use :py:class:`BinaryJSONField`, which has many performance and "
"querying advantages, you must have Postgres 9.4 or later."
msgstr ""

#: ../../peewee/playhouse.rst:1514
msgid ""
"You must be sure your database is an instance of "
":py:class:`PostgresqlExtDatabase` in order to use the `JSONField`."
msgstr ""

#: ../../peewee/playhouse.rst:1517
msgid "Here is an example of how you might declare a model with a JSON field:"
msgstr ""

#: ../../peewee/playhouse.rst:1561
msgid ""
"The :py:class:`BinaryJSONField` works the same and supports the same "
"operations as the regular :py:class:`JSONField`, but provides several "
"additional operations for testing *containment*. Using the binary json "
"field, you can test whether your JSON data contains other partial JSON "
"structures (:py:meth:`~BinaryJSONField.contains`, "
":py:meth:`~BinaryJSONField.contains_any`, "
":py:meth:`~BinaryJSONField.contains_all`), or whether it is a subset of a"
" larger JSON document (:py:meth:`~BinaryJSONField.contained_by`)."
msgstr ""

#: ../../peewee/playhouse.rst:1563
msgid ""
"For more examples, see the :py:class:`JSONField` and "
":py:class:`BinaryJSONField` API documents below."
msgstr ""

#: ../../peewee/playhouse.rst:1568
msgid "Server-side cursors"
msgstr ""

#: ../../peewee/playhouse.rst:1570
msgid ""
"When psycopg2 executes a query, normally all results are fetched and "
"returned to the client by the backend.  This can cause your application "
"to use a lot of memory when making large queries.  Using server-side "
"cursors, results are returned a little at a time (by default 2000 "
"records).  For the definitive reference, please see the `psycopg2 "
"documentation <http://initd.org/psycopg/docs/usage.html#server-side-"
"cursors>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1575
msgid ""
"To use server-side (or named) cursors, you must be using "
":py:class:`PostgresqlExtDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:1577
msgid ""
"To execute a query using a server-side cursor, simply wrap your select "
"query using the :py:func:`ServerSide` helper:"
msgstr ""

#: ../../peewee/playhouse.rst:1591
msgid ""
"If you would like all ``SELECT`` queries to automatically use a server-"
"side cursor, you can specify this when creating your "
":py:class:`PostgresqlExtDatabase`:"
msgstr ""

#: ../../peewee/playhouse.rst:1601
msgid ""
"Server-side cursors live only as long as the transaction, so for this "
"reason peewee will not automatically call ``commit()`` after executing a "
"``SELECT`` query.  If you do not ``commit`` after you are done iterating,"
" you will not release the server-side resources until the connection is "
"closed (or the transaction is committed later).  Furthermore, since "
"peewee will by default cache rows returned by the cursor, you should "
"always call ``.iterator()`` when iterating over a large query."
msgstr ""

#: ../../peewee/playhouse.rst:1609
msgid ""
"If you are using the :py:func:`ServerSide` helper, the transaction and "
"call to ``iterator()`` will be handled transparently."
msgstr ""

#: ../../peewee/playhouse.rst:1616
msgid "Full-text search"
msgstr ""

#: ../../peewee/playhouse.rst:1618
msgid ""
"Postgresql provides `sophisticated full-text search "
"<http://www.postgresql.org/docs/9.3/static/textsearch.html>`_ using "
"special data-types (``tsvector`` and ``tsquery``). Documents should be "
"stored or converted to the ``tsvector`` type, and search queries should "
"be converted to ``tsquery``."
msgstr ""

#: ../../peewee/playhouse.rst:1620
msgid ""
"For simple cases, you can simply use the :py:func:`Match` function, which"
" will automatically perform the appropriate conversions, and requires no "
"schema changes:"
msgstr ""

#: ../../peewee/playhouse.rst:1629
msgid ""
"The :py:func:`Match` function will automatically convert the left-hand "
"operand to a ``tsvector``, and the right-hand operand to a ``tsquery``. "
"For better performance, it is recommended you create a ``GIN`` index on "
"the column you plan to search:"
msgstr ""

#: ../../peewee/playhouse.rst:1635
msgid ""
"Alternatively, you can use the :py:class:`TSVectorField` to maintain a "
"dedicated column for storing ``tsvector`` data:"
msgstr ""

#: ../../peewee/playhouse.rst:1643
msgid ""
"You will need to explicitly convert the incoming text data to "
"``tsvector`` when inserting or updating the ``search_content`` field:"
msgstr ""

#: ../../peewee/playhouse.rst:1652
msgid ""
"If you are using the :py:class:`TSVectorField`, it will automatically be "
"created with a GIN index."
msgstr ""

#: ../../peewee/playhouse.rst:1656
msgid "postgres_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:1660
msgid ""
"Identical to :py:class:`PostgresqlDatabase` but required in order to "
"support:"
msgstr ""

#: ../../peewee/playhouse.rst:1662
msgid ":ref:`server_side_cursors`"
msgstr ""

#: ../../peewee/playhouse.rst:1663
msgid ":py:class:`ArrayField`"
msgstr ""

#: ../../peewee/playhouse.rst:1664
msgid ":py:class:`DateTimeTZField`"
msgstr ""

#: ../../peewee/playhouse.rst:1665
msgid ":py:class:`JSONField`"
msgstr ""

#: ../../peewee/playhouse.rst:1666
msgid ":py:class:`BinaryJSONField`"
msgstr ""

#: ../../peewee/playhouse.rst:1667
msgid ":py:class:`HStoreField`"
msgstr ""

#: ../../peewee/playhouse.rst:1668
msgid ":py:class:`TSVectorField`"
msgstr ""

#: ../../peewee/playhouse.rst:1670
msgid "Name of database to connect to."
msgstr ""

#: ../../peewee/playhouse.rst:1671
msgid "Whether ``SELECT`` queries should utilize server-side cursors."
msgstr ""

#: ../../peewee/playhouse.rst:1673
msgid "Register the HStore extension with the connection."
msgstr ""

#: ../../peewee/playhouse.rst:1675
msgid ""
"If using ``server_side_cursors``, also be sure to wrap your queries with "
":py:func:`ServerSide`."
msgstr ""

#: ../../peewee/playhouse.rst:1678
msgid ""
"If you do not wish to use the HStore extension, you can specify "
"``register_hstore=False``."
msgstr ""

#: ../../peewee/playhouse.rst:1681
msgid ""
"The :py:class:`PostgresqlExtDatabase` by default will attempt to register"
" the ``HSTORE`` extension. Most distributions and recent versions include"
" this, but in some cases the extension may not be available. If you **do "
"not** plan to use the :ref:`HStore features of peewee <hstore>`, you can "
"pass ``register_hstore=False`` when initializing your "
":py:class:`PostgresqlExtDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:1685
msgid ""
"Wrap the given select query in a transaction, and call it's "
":py:meth:`~SelectQuery.iterator` method to avoid caching row instances.  "
"In order for the server-side resources to be released, be sure to exhaust"
" the generator (iterate over all the rows)."
msgstr ""

#: ../../peewee/playhouse.rst:1689
msgid "a :py:class:`SelectQuery` instance."
msgstr ""

#: ../../peewee/playhouse.rst:1690
msgid "``generator``"
msgstr ""

#: ../../peewee/playhouse.rst:1707
msgid "Field capable of storing arrays of the provided `field_class`."
msgstr ""

#: ../../peewee/playhouse.rst:1709
msgid "a subclass of :py:class:`Field`, e.g. :py:class:`IntegerField`."
msgstr ""

#: ../../peewee/playhouse.rst:1710
msgid "dimensions of array."
msgstr ""

#: ../../peewee/playhouse.rst:1712
msgid "You can store and retrieve lists (or lists-of-lists):"
msgstr ""

#: ../../peewee/playhouse.rst:1723
msgid ""
"Additionally, you can use the ``__getitem__`` API to query values or "
"slices in the database:"
msgstr ""

#: ../../peewee/playhouse.rst:1737
msgid "Get a slice of values:"
msgstr ""

#: ../../peewee/playhouse.rst:1750
msgid "One or more items that must be in the given array field."
msgstr ""

#: ../../peewee/playhouse.rst:1759
msgid "One or more items to search for in the given array field."
msgstr ""

#: ../../peewee/playhouse.rst:1761
msgid ""
"Like :py:meth:`~ArrayField.contains`, except will match rows where the "
"array contains *any* of the given items."
msgstr ""

#: ../../peewee/playhouse.rst:1771
msgid "A timezone-aware subclass of :py:class:`DateTimeField`."
msgstr ""

#: ../../peewee/playhouse.rst:1775
msgid ""
"A field for storing and retrieving arbitrary key/value pairs.  For "
"details on usage, see :ref:`hstore`."
msgstr ""

#: ../../peewee/playhouse.rst:1780
msgid "Returns the keys for a given row."
msgstr ""

#: ../../peewee/playhouse.rst:1792
msgid "Return the values for a given row."
msgstr ""

#: ../../peewee/playhouse.rst:1803
msgid "Like python's ``dict``, return the keys and values in a list-of-lists:"
msgstr ""

#: ../../peewee/playhouse.rst:1814
msgid "Return a slice of data given a list of keys."
msgstr ""

#: ../../peewee/playhouse.rst:1826
msgid "Query for whether the given key exists."
msgstr ""

#: ../../peewee/playhouse.rst:1842
msgid "Query for whether the given key has a value associated with it."
msgstr ""

#: ../../peewee/playhouse.rst:1846
msgid "Perform an atomic update to the keys/values for a given row or rows."
msgstr ""

#: ../../peewee/playhouse.rst:1857
msgid "Delete the provided keys for a given row or rows."
msgstr ""

#: ../../peewee/playhouse.rst:1859
msgid "We will use an ``UPDATE`` query."
msgstr ""

#: ../../peewee/playhouse.rst:1869
msgid "Either a ``dict``, a ``list`` of keys, or a single key."
msgstr ""

#: ../../peewee/playhouse.rst:1871
msgid "Query rows for the existence of either:"
msgstr ""

#: ../../peewee/playhouse.rst:1873
msgid "a partial dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:1874
msgid "a list of keys."
msgstr ""

#: ../../peewee/playhouse.rst:1875
msgid "a single key."
msgstr ""

#: ../../peewee/playhouse.rst:1886
msgid "One or more keys to search for."
msgstr ""

#: ../../peewee/playhouse.rst:1888
msgid "Query rows for the existince of *any* key."
msgstr ""

#: ../../peewee/playhouse.rst:1892
msgid ""
"Field class suitable for storing and querying arbitrary JSON.  When using"
" this on a model, set the field's value to a Python object (either a "
"``dict`` or a ``list``).  When you retrieve your value from the database "
"it will be returned as a Python data structure."
msgstr ""

#: ../../peewee/playhouse.rst:1897 ../../peewee/playhouse.rst:1996
msgid ""
"The default is to call json.dumps() or the dumps function. You can "
"override this method to create a customized JSON wrapper."
msgstr ""

#: ../../peewee/playhouse.rst:1899
msgid "You must be using Postgres 9.2 / psycopg2 2.5 or greater."
msgstr ""

#: ../../peewee/playhouse.rst:1901
msgid ""
"If you are using Postgres 9.4, strongly consider using the "
":py:class:`BinaryJSONField` instead as it offers better performance and "
"more powerful querying options."
msgstr ""

#: ../../peewee/playhouse.rst:1903
msgid "Example model declaration:"
msgstr ""

#: ../../peewee/playhouse.rst:1916
msgid "Example of storing JSON data:"
msgstr ""

#: ../../peewee/playhouse.rst:1926
msgid ""
"To query, use Python's ``[]`` operators to specify nested key or array "
"lookups:"
msgstr ""

#: ../../peewee/playhouse.rst:1933
msgid ""
"To illustrate the use of the ``[]`` operators, imagine we have the "
"following data stored in an ``APIResponse``:"
msgstr ""

#: ../../peewee/playhouse.rst:1947
msgid "Here are the results of a few queries:"
msgstr ""

#: ../../peewee/playhouse.rst:1992
msgid ""
"Store and query arbitrary JSON documents. Data should be stored using "
"normal Python ``dict`` and ``list`` objects, and when data is returned "
"from the database, it will be returned using ``dict`` and ``list`` as "
"well."
msgstr ""

#: ../../peewee/playhouse.rst:1994
msgid ""
"For examples of basic query operations, see the above code samples for "
":py:class:`JSONField`. The example queries below will use the same "
"``APIResponse`` model described above."
msgstr ""

#: ../../peewee/playhouse.rst:1998
msgid ""
"You must be using Postgres 9.4 / psycopg2 2.5 or newer. If you are using "
"Postgres 9.2 or 9.3, you can use the regular :py:class:`JSONField` "
"instead."
msgstr ""

#: ../../peewee/playhouse.rst:2002
msgid "Test whether the given JSON data contains the given JSON fragment or key."
msgstr ""

#: ../../peewee/playhouse.rst:2022
msgid ""
"We can pass in simple keys as well. To find APIResponses that contain the"
" key ``foo`` at the top-level:"
msgstr ""

#: ../../peewee/playhouse.rst:2028
msgid "We can also search sub-keys using square-brackets:"
msgstr ""

#: ../../peewee/playhouse.rst:2037
msgid "Search for the presence of one or more of the given items."
msgstr ""

#: ../../peewee/playhouse.rst:2044
msgid "Like :py:meth:`~BinaryJSONField.contains`, we can also search sub-keys:"
msgstr ""

#: ../../peewee/playhouse.rst:2053
msgid "Search for the presence of all of the given items."
msgstr ""

#: ../../peewee/playhouse.rst:2060
msgid ""
"Like :py:meth:`~BinaryJSONField.contains_any`, we can also search sub-"
"keys:"
msgstr ""

#: ../../peewee/playhouse.rst:2069
msgid ""
"Test whether the given JSON document is contained by (is a subset of) the"
" given JSON document. This method is the inverse of "
":py:meth:`~BinaryJSONField.contains`."
msgstr ""

#: ../../peewee/playhouse.rst:2089
msgid ""
"Generate a full-text search expression, automatically converting the "
"left-hand operand to a ``tsvector``, and the right-hand operand to a "
"``tsquery``."
msgstr ""

#: ../../peewee/playhouse.rst:2102
msgid ""
"Field type suitable for storing ``tsvector`` data. This field will "
"automatically be created with a ``GIN`` index for improved search "
"performance."
msgstr ""

#: ../../peewee/playhouse.rst:2105
msgid ""
"Data stored in this field will still need to be manually converted to the"
" ``tsvector`` type."
msgstr ""

#: ../../peewee/playhouse.rst:2124
msgid "DataSet"
msgstr "データセット"

#: ../../peewee/playhouse.rst:2126
msgid ""
"The *dataset* module contains a high-level API for working with databases"
" modeled after the popular `project of the same name "
"<https://dataset.readthedocs.io/en/latest/index.html>`_. The aims of the "
"*dataset* module are to provide:"
msgstr ""

#: ../../peewee/playhouse.rst:2128
msgid ""
"A simplified API for working with relational data, along the lines of "
"working with JSON."
msgstr ""

#: ../../peewee/playhouse.rst:2129
msgid "An easy way to export relational data as JSON or CSV."
msgstr ""

#: ../../peewee/playhouse.rst:2130
msgid "An easy way to import JSON or CSV data into a relational database."
msgstr ""

#: ../../peewee/playhouse.rst:2132
msgid "A minimal data-loading script might look like this:"
msgstr ""

#: ../../peewee/playhouse.rst:2153
msgid ""
"You can export or import data using :py:meth:`~DataSet.freeze` and "
":py:meth:`~DataSet.thaw`:"
msgstr ""

#: ../../peewee/playhouse.rst:2166
msgid "Getting started"
msgstr ""

#: ../../peewee/playhouse.rst:2168
msgid ""
":py:class:`DataSet` objects are initialized by passing in a database URL "
"of the format ``dialect://user:password@host/dbname``. See the "
":ref:`db_url` section for examples of connecting to various databases."
msgstr ""

#: ../../peewee/playhouse.rst:2176 ../../peewee/quickstart.rst:82
msgid "Storing data"
msgstr "データの保存"

#: ../../peewee/playhouse.rst:2178
msgid ""
"To store data, we must first obtain a reference to a table. If the table "
"does not exist, it will be created automatically:"
msgstr ""

#: ../../peewee/playhouse.rst:2185
msgid ""
"We can now :py:meth:`~Table.insert` new rows into the table. If the "
"columns do not exist, they will be created automatically:"
msgstr ""

#: ../../peewee/playhouse.rst:2192
msgid ""
"To update existing entries in the table, pass in a dictionary containing "
"the new values and filter conditions. The list of columns to use as "
"filters is specified in the *columns* argument. If no filter columns are "
"specified, then all rows will be updated."
msgstr ""

#: ../../peewee/playhouse.rst:2203
msgid "Importing data"
msgstr ""

#: ../../peewee/playhouse.rst:2205
msgid ""
"To import data from an external source, such as a JSON or CSV file, you "
"can use the :py:meth:`~Table.thaw` method. By default, new columns will "
"be created for any attributes encountered. If you wish to only populate "
"columns that are already defined on a table, you can pass in "
"``strict=True``."
msgstr ""

#: ../../peewee/playhouse.rst:2221
msgid "Using transactions"
msgstr ""

#: ../../peewee/playhouse.rst:2223
msgid "DataSet supports nesting transactions using a simple context manager."
msgstr ""

#: ../../peewee/playhouse.rst:2239
msgid "Inspecting the database"
msgstr ""

#: ../../peewee/playhouse.rst:2241
msgid ""
"You can use the :py:meth:`tables` method to list the tables in the "
"current database:"
msgstr ""

#: ../../peewee/playhouse.rst:2248
msgid "And for a given table, you can print the columns:"
msgstr ""

#: ../../peewee/playhouse.rst:2256
msgid "We can also find out how many rows are in a table:"
msgstr ""

#: ../../peewee/playhouse.rst:2264
msgid "Reading data"
msgstr ""

#: ../../peewee/playhouse.rst:2266
msgid "To retrieve all rows, you can use the :py:meth:`~Table.all` method:"
msgstr ""

#: ../../peewee/playhouse.rst:2277
msgid ""
"Specific objects can be retrieved using :py:meth:`~Table.find` and "
":py:meth:`~Table.find_one`."
msgstr ""

#: ../../peewee/playhouse.rst:2288
msgid "Exporting data"
msgstr ""

#: ../../peewee/playhouse.rst:2290
msgid ""
"To export data, use the :py:meth:`~DataSet.freeze` method, passing in the"
" query you wish to export:"
msgstr ""

#: ../../peewee/playhouse.rst:2298
msgid "API"
msgstr ""

#: ../../peewee/playhouse.rst:2302
msgid ""
"The *DataSet* class provides a high-level API for working with relational"
" databases."
msgstr ""

#: ../../peewee/playhouse.rst:2304
msgid "A database URL. See :ref:`db_url` for examples."
msgstr ""

#: ../../peewee/playhouse.rst:2308
msgid ""
"Return a list of tables stored in the database. This list is computed "
"dynamically each time it is accessed."
msgstr ""

#: ../../peewee/playhouse.rst:2312
msgid ""
"Provide a :py:class:`Table` reference to the specified table. If the "
"table does not exist, it will be created."
msgstr ""

#: ../../peewee/playhouse.rst:2316
msgid "A SQL query."
msgstr ""

#: ../../peewee/playhouse.rst:2317
msgid "Optional parameters for the query."
msgstr ""

#: ../../peewee/playhouse.rst:2318
msgid "Whether the query should be committed upon execution."
msgstr ""

#: ../../peewee/playhouse.rst:2319
msgid "A database cursor."
msgstr ""

#: ../../peewee/playhouse.rst:2321
msgid "Execute the provided query against the database."
msgstr ""

#: ../../peewee/playhouse.rst:2325
msgid "Create a context manager representing a new transaction (or savepoint)."
msgstr ""

#: ../../peewee/playhouse.rst:2329
msgid ""
"A :py:class:`SelectQuery`, generated using :py:meth:`~Table.all` or "
"`~Table.find`."
msgstr ""

#: ../../peewee/playhouse.rst:2330 ../../peewee/playhouse.rst:2423
msgid "Output format. By default, *csv* and *json* are supported."
msgstr ""

#: ../../peewee/playhouse.rst:2331 ../../peewee/playhouse.rst:2424
msgid "Filename to write output to."
msgstr ""

#: ../../peewee/playhouse.rst:2332 ../../peewee/playhouse.rst:2425
msgid "File-like object to write output to."
msgstr ""

#: ../../peewee/playhouse.rst:2333 ../../peewee/playhouse.rst:2426
msgid "Arbitrary parameters for export-specific functionality."
msgstr ""

#: ../../peewee/playhouse.rst:2337
msgid "The name of the table to load data into."
msgstr ""

#: ../../peewee/playhouse.rst:2338 ../../peewee/playhouse.rst:2430
msgid "Input format. By default, *csv* and *json* are supported."
msgstr ""

#: ../../peewee/playhouse.rst:2339 ../../peewee/playhouse.rst:2431
msgid "Filename to read data from."
msgstr ""

#: ../../peewee/playhouse.rst:2340 ../../peewee/playhouse.rst:2432
msgid "File-like object to read data from."
msgstr ""

#: ../../peewee/playhouse.rst:2341 ../../peewee/playhouse.rst:2433
msgid ""
"Whether to store values for columns that do not already exist on the "
"table."
msgstr ""

#: ../../peewee/playhouse.rst:2342 ../../peewee/playhouse.rst:2434
msgid "Arbitrary parameters for import-specific functionality."
msgstr ""

#: ../../peewee/playhouse.rst:2346
msgid ""
"Open a connection to the underlying database. If a connection is not "
"opened explicitly, one will be opened the first time a query is executed."
msgstr ""

#: ../../peewee/playhouse.rst:2350
msgid "Close the connection to the underlying database."
msgstr ""

#: ../../peewee/playhouse.rst:2354
msgid ""
"The *Table* class provides a high-level API for working with rows in a "
"given table."
msgstr ""

#: ../../peewee/playhouse.rst:2358
msgid "Return a list of columns in the given table."
msgstr ""

#: ../../peewee/playhouse.rst:2362
msgid "A dynamically-created :py:class:`Model` class."
msgstr ""

#: ../../peewee/playhouse.rst:2366
msgid "Create an index on the given columns:"
msgstr ""

#: ../../peewee/playhouse.rst:2375
msgid ""
"Insert the given data dictionary into the table, creating new columns as "
"needed."
msgstr ""

#: ../../peewee/playhouse.rst:2379
msgid ""
"Update the table using the provided data. If one or more columns are "
"specified in the *columns* parameter, then those columns' values in the "
"*data* dictionary will be used to determine which rows to update."
msgstr ""

#: ../../peewee/playhouse.rst:2391
msgid ""
"Query the table for rows matching the specified equality conditions. If "
"no query is specified, then all rows are returned."
msgstr ""

#: ../../peewee/playhouse.rst:2399
msgid ""
"Return a single row matching the specified equality conditions. If no "
"matching row is found then ``None`` will be returned."
msgstr ""

#: ../../peewee/playhouse.rst:2407
msgid "Return all rows in the given table."
msgstr ""

#: ../../peewee/playhouse.rst:2411
msgid ""
"Delete all rows matching the given equality conditions. If no query is "
"provided, then all rows will be deleted."
msgstr ""

#: ../../peewee/playhouse.rst:2440
msgid "Django Integration"
msgstr "Djangoの統合"

#: ../../peewee/playhouse.rst:2442
msgid ""
"The Django ORM provides a very high-level abstraction over SQL and as a "
"consequence is in some ways `limited in terms of flexibility or "
"expressiveness <http://charlesleifer.com/blog/shortcomings-in-the-django-"
"orm-and-a-look-at-peewee-a-lightweight-alternative/>`_. I wrote a `blog "
"post <http://charlesleifer.com/blog/the-search-for-the-missing-link-what-"
"lies-between-sql-and-django-s-orm-/>`_ describing my search for a "
"\"missing link\" between Django's ORM and the SQL it generates, "
"concluding that no such layer exists.  The ``djpeewee`` module attempts "
"to provide an easy-to-use, structured layer for generating SQL queries "
"for use with Django's ORM."
msgstr ""

#: ../../peewee/playhouse.rst:2450
msgid "A couple use-cases might be:"
msgstr ""

#: ../../peewee/playhouse.rst:2452
msgid ""
"Joining on fields that are not related by foreign key (for example UUID "
"fields)."
msgstr ""

#: ../../peewee/playhouse.rst:2453
msgid "Performing aggregate queries on calculated values."
msgstr ""

#: ../../peewee/playhouse.rst:2454
msgid "Features that Django does not support such as ``CASE`` statements."
msgstr ""

#: ../../peewee/playhouse.rst:2455
msgid "Utilizing SQL functions that Django does not support, such as ``SUBSTR``."
msgstr ""

#: ../../peewee/playhouse.rst:2456
msgid ""
"Replacing nearly-identical SQL queries with reusable, composable data-"
"structures."
msgstr ""

#: ../../peewee/playhouse.rst:2458
msgid "Below is an example of how you might use this:"
msgstr ""

#: ../../peewee/playhouse.rst:2482
msgid "Foreign keys and Many-to-many relationships"
msgstr ""

#: ../../peewee/playhouse.rst:2484
msgid ""
"The :py:func:`translate` function will recursively traverse the graph of "
"models and return a dictionary populated with everything it finds.  Back-"
"references are not searched by default, but can be included by specifying"
" ``backrefs=True``."
msgstr ""

#: ../../peewee/playhouse.rst:2503
msgid ""
"As you can see in the example above, although only `User` and `Group` "
"were passed in to :py:func:`translate`, several other models which are "
"related by foreign key were also created. Additionally, the many-to-many "
"\"through\" tables were created as separate models since peewee does not "
"abstract away these types of relationships."
msgstr ""

#: ../../peewee/playhouse.rst:2508
msgid ""
"Using the above models it is possible to construct joins.  The following "
"example will get all users who belong to a group that starts with the "
"letter \"A\":"
msgstr ""

#: ../../peewee/playhouse.rst:2525
msgid "djpeewee API"
msgstr ""

#: ../../peewee/playhouse.rst:2529
msgid ""
"Translate the given Django models into roughly equivalent peewee models "
"suitable for use constructing queries. Foreign keys and many-to-many "
"relationships will be followed and models generated, although back "
"references are not traversed."
msgstr ""

#: ../../peewee/playhouse.rst:2533
msgid "One or more Django model classes."
msgstr ""

#: ../../peewee/playhouse.rst:2534
msgid "A dictionary of options, see note below."
msgstr ""

#: ../../peewee/playhouse.rst:2535
msgid ""
"A dict-like object containing the generated models, but which supports "
"dotted-name style lookups."
msgstr ""

#: ../../peewee/playhouse.rst:2538
msgid "The following are valid options:"
msgstr ""

#: ../../peewee/playhouse.rst:2540
msgid "``recurse``: Follow foreign keys and many to many (default: ``True``)."
msgstr ""

#: ../../peewee/playhouse.rst:2541
msgid "``max_depth``: Maximum depth to recurse (default: ``None``, unlimited)."
msgstr ""

#: ../../peewee/playhouse.rst:2542
msgid "``backrefs``: Follow backrefs (default: ``False``)."
msgstr ""

#: ../../peewee/playhouse.rst:2543
msgid "``exclude``: A list of models to exclude."
msgstr ""

#: ../../peewee/playhouse.rst:2551
msgid ""
"This module also contains several field classes that implement additional"
" logic like encryption and compression. There is also a "
":py:class:`ManyToManyField` that makes it easy to work with simple many-"
"to-many relationships."
msgstr ""

#: ../../peewee/playhouse.rst:2553
msgid "These fields can be found in the ``playhouse.fields`` module."
msgstr ""

#: ../../peewee/playhouse.rst:2558
msgid ""
"Name for the automatically-created backref. If not provided, the "
"pluralized version of the model will be used."
msgstr ""

#: ../../peewee/playhouse.rst:2560
msgid ""
":py:class:`Model` to use for the intermediary table. If not provided, a "
"simple through table will be automatically created."
msgstr ""

#: ../../peewee/playhouse.rst:2563
msgid ""
"The :py:class:`ManyToManyField` provides a simple interface for working "
"with many-to-many relationships, inspired by Django. A many-to-many "
"relationship is typically implemented by creating a junction table with "
"foreign keys to the two models being related. For instance, if you were "
"building a syllabus manager for college students, the relationship "
"between students and courses would be many-to-many. Here is the schema "
"using standard APIs:"
msgstr ""

#: ../../peewee/playhouse.rst:2577
msgid ""
"To query the courses for a particular student, you would join through the"
" junction table:"
msgstr ""

#: ../../peewee/playhouse.rst:2590
msgid ""
"The :py:class:`ManyToManyField` is designed to simplify this use-case by "
"providing a *field-like* API for querying and modifying data in the "
"junction table. Here is how our code looks using "
":py:class:`ManyToManyField`:"
msgstr ""

#: ../../peewee/playhouse.rst:2601
msgid ""
"It does not matter from Peewee's perspective which model the "
":py:class:`ManyToManyField` goes on, since the back-reference is just the"
" mirror image. In order to write valid Python, though, you will need to "
"add the ``ManyToManyField`` on the second model so that the name of the "
"first model is in the scope."
msgstr ""

#: ../../peewee/playhouse.rst:2603
msgid ""
"We still need a junction table to store the relationships between "
"students and courses. This model can be accessed by calling the "
":py:meth:`~ManyToManyField.get_through_model` method. This is useful when"
" creating tables."
msgstr ""

#: ../../peewee/playhouse.rst:2614
msgid ""
"When accessed from a model instance, the :py:class:`ManyToManyField` "
"exposes a :py:class:`SelectQuery` representing the set of related "
"objects. Let's use the interactive shell to see how all this works:"
msgstr ""

#: ../../peewee/playhouse.rst:2626
msgid ""
"To add new relationships between objects, you can either assign the "
"objects directly to the ``ManyToManyField`` attribute, or call the "
":py:meth:`~ManyToManyField.add` method. The difference between the two is"
" that simply assigning will clear out any existing relationships, whereas"
" ``add()`` can preserve existing relationships."
msgstr ""

#: ../../peewee/playhouse.rst:2645
msgid ""
"This is quite a few courses, so let's remove the 200-level english "
"courses. To remove objects, use the :py:meth:`~ManyToManyField.remove` "
"method."
msgstr ""

#: ../../peewee/playhouse.rst:2654
msgid ""
"To remove all relationships from a collection, you can use the "
":py:meth:`~SelectQuery.clear` method. Let's say that English 101 is "
"canceled, so we need to remove all the students from it:"
msgstr ""

#: ../../peewee/playhouse.rst:2661
msgid ""
"For an overview of implementing many-to-many relationships using standard"
" Peewee APIs, check out the :ref:`manytomany` section. For all but the "
"most simple cases, you will be better off implementing many-to-many using"
" the standard APIs."
msgstr ""

#: ../../peewee/playhouse.rst:2665 ../../peewee/playhouse.rst:2690
msgid ""
"Either a :py:class:`Model` instance, a list of model instances, or a "
":py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:2666
msgid "Whether to remove existing relationships first."
msgstr ""

#: ../../peewee/playhouse.rst:2668
msgid ""
"Associate ``value`` with the current instance. You can pass in a single "
"model instance, a list of model instances, or even a "
":py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:2692
msgid ""
"Disassociate ``value`` from the current instance. Like "
":py:meth:`~ManyToManyField.add`, you can pass in a model instance, a list"
" of model instances, or even a :py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:2712
msgid "Remove all associated objects."
msgstr ""

#: ../../peewee/playhouse.rst:2725
msgid ""
"Return the :py:class:`Model` representing the many-to-many junction "
"table. This can be specified manually when the field is being "
"instantiated using the ``through_model`` parameter. If a "
"``through_model`` is not specified, one will automatically be created."
msgstr ""

#: ../../peewee/playhouse.rst:2727
msgid ""
"When creating tables for an application that uses "
":py:class:`ManyToManyField`, **you must create the through table "
"expicitly**."
msgstr ""

#: ../../peewee/playhouse.rst:2742
msgid ""
"In some instances, you may need to obtain a reference to a through model "
"before that model is actually defined. In order to avoid weird circular "
"logic, you can use the ``DeferredThroughModel`` as a placeholder, then "
"\"fill it in\" when you're ready."
msgstr ""

#: ../../peewee/playhouse.rst:2768
msgid "Initialize the deferred placeholder with the appropriate model class."
msgstr ""

#: ../../peewee/playhouse.rst:2772
msgid ""
"``CompressedField`` stores compressed data using the specified algorithm."
" This field extends :py:class:`BlobField`, transparently storing a "
"compressed representation of the data in the database."
msgstr ""

#: ../../peewee/playhouse.rst:2774
msgid "A value from 0 to 9."
msgstr ""

#: ../../peewee/playhouse.rst:2775
msgid "Either ``'zlib'`` or ``'bz2'``."
msgstr ""

#: ../../peewee/playhouse.rst:2779
msgid ""
"``PasswordField`` stores a password hash and lets you verify it. The "
"password is hashed when it is saved to the database and after reading it "
"from the database you can call ``check_password (password) -> bool`` on "
"it."
msgstr ""

#: ../../peewee/playhouse.rst:2781
msgid "Indicates the work factor, it does 2^n iterations."
msgstr ""

#: ../../peewee/playhouse.rst:2783
msgid ""
"This field requires `bcrypt <https://github.com/pyca/bcrypt/>`_, which "
"can be installed by running ``pip install bcrypt``."
msgstr ""

#: ../../peewee/playhouse.rst:2788
msgid "A field capable of storing arbitrary Python objects."
msgstr ""

#: ../../peewee/playhouse.rst:2790
msgid "If the ``cPickle`` module is available, it will be used."
msgstr ""

#: ../../peewee/playhouse.rst:2795
msgid "Generic foreign keys"
msgstr "一般的な外部キー"

#: ../../peewee/playhouse.rst:2797
msgid ""
"The ``gfk`` module provides a Generic ForeignKey (GFK), similar to "
"Django.  A GFK is composed of two columns: an object ID and an object "
"type identifier.  The object types are collected in a global registry "
"(``all_models``)."
msgstr ""

#: ../../peewee/playhouse.rst:2801
msgid "How a :py:class:`GFKField` is resolved:"
msgstr ""

#: ../../peewee/playhouse.rst:2803
msgid "Look up the object type in the global registry (returns a model class)"
msgstr ""

#: ../../peewee/playhouse.rst:2804
msgid "Look up the model instance by object ID"
msgstr ""

#: ../../peewee/playhouse.rst:2806
msgid ""
"In order to use Generic ForeignKeys, your application's models *must* "
"subclass ``playhouse.gfk.Model``.  This ensures that the model class will"
" be added to the global registry."
msgstr ""

#: ../../peewee/playhouse.rst:2810
msgid ""
"GFKs themselves are not actually a field and will not add a column to "
"your table."
msgstr ""

#: ../../peewee/playhouse.rst:2813
msgid ""
"Like regular ForeignKeys, GFKs support a \"back-reference\" via the "
":py:class:`ReverseGFK` descriptor."
msgstr ""

#: ../../peewee/playhouse.rst:2817
msgid "How to use GFKs"
msgstr ""

#: ../../peewee/playhouse.rst:2819
msgid "Be sure your model subclasses ``playhouse.gfk.Model``"
msgstr ""

#: ../../peewee/playhouse.rst:2820
msgid "Add a :py:class:`CharField` to store the ``object_type``"
msgstr ""

#: ../../peewee/playhouse.rst:2821
msgid ""
"Add a field to store the ``object_id`` (usually a "
":py:class:`IntegerField`)"
msgstr ""

#: ../../peewee/playhouse.rst:2822
msgid ""
"Add a :py:class:`GFKField` and instantiate it with the names of the "
"``object_type`` and ``object_id`` fields."
msgstr ""

#: ../../peewee/playhouse.rst:2824
msgid "(optional) On any other models, add a :py:class:`ReverseGFK` descriptor"
msgstr ""

#: ../../peewee/playhouse.rst:2844
msgid "How you use these is pretty straightforward hopefully:"
msgstr ""

#: ../../peewee/playhouse.rst:2880
msgid "GFK API"
msgstr ""

#: ../../peewee/playhouse.rst:2884
msgid ""
"Provide a clean API for storing \"generic\" foreign keys.  Generic "
"foreign keys are comprised of an object type, which maps to a model "
"class, and an object id, which maps to the primary key of the related "
"model class."
msgstr ""

#: ../../peewee/playhouse.rst:2888
msgid ""
"Setting the GFKField on a model will automatically populate the "
"``model_type_field`` and ``model_id_field``.  Similarly, getting the "
"GFKField on a model instance will \"resolve\" the two fields, first "
"looking up the model class, then looking up the instance by ID."
msgstr ""

#: ../../peewee/playhouse.rst:2895
msgid "Back-reference support for :py:class:`GFKField`."
msgstr ""

#: ../../peewee/playhouse.rst:2900
msgid "Hybrid Attributes"
msgstr "ハイブリッド属性"

#: ../../peewee/playhouse.rst:2902
msgid ""
"Hybrid attributes encapsulate functionality that operates at both the "
"Python *and* SQL levels. The idea for hybrid attributes comes from a "
"feature of the `same name in SQLAlchemy "
"<http://docs.sqlalchemy.org/en/improve_toc/orm/extensions/hybrid.html>`_."
" Consider the following example:"
msgstr ""

#: ../../peewee/playhouse.rst:2918
msgid ""
"The *hybrid attribute* gets its name from the fact that the ``length`` "
"attribute will behave differently depending on whether it is accessed via"
" the ``Interval`` class or an ``Interval`` instance."
msgstr ""

#: ../../peewee/playhouse.rst:2920
msgid "If accessed via an instance, then it behaves just as you would expect."
msgstr ""

#: ../../peewee/playhouse.rst:2922
msgid ""
"If accessed via the ``Interval.length`` class attribute, however, the "
"length calculation will be expressed as a SQL expression. For example:"
msgstr ""

#: ../../peewee/playhouse.rst:2928
msgid "This query will be equivalent to the following SQL:"
msgstr ""

#: ../../peewee/playhouse.rst:2936
msgid ""
"The ``hybrid`` module also contains a decorator for implementing hybrid "
"methods which can accept parameters. As with hybrid properties, when "
"accessed via a model instance, then the function executes normally as-"
"written. When the hybrid method is called on the class, however, it will "
"generate a SQL expression."
msgstr ""

#: ../../peewee/playhouse.rst:2944 ../../peewee/playhouse.rst:2980
#: ../../peewee/querying.rst:677
msgid "This query is equivalent to the following SQL:"
msgstr ""

#: ../../peewee/playhouse.rst:2952
msgid ""
"There is an additional API for situations where the python implementation"
" differs slightly from the SQL implementation. Let's add a ``radius`` "
"method to the ``Interval`` model. Because this method calculates an "
"absolute value, we will use the Python ``abs()`` function for the "
"instance portion and the ``fn.ABS()`` SQL function for the class portion."
msgstr ""

#: ../../peewee/playhouse.rst:2972
msgid ""
"What is neat is that both the ``radius`` implementations refer to the "
"``length`` hybrid attribute! When accessed via an ``Interval`` instance, "
"the radius calculation will be executed in Python. When invoked via an "
"``Interval`` class, we will get the appropriate SQL."
msgstr ""

#: ../../peewee/playhouse.rst:2988
msgid "Pretty neat, right? Thanks for the cool idea, SQLAlchemy!"
msgstr ""

#: ../../peewee/playhouse.rst:2991
msgid "Hybrid API"
msgstr ""

#: ../../peewee/playhouse.rst:2995
msgid ""
"Method decorator that allows the definition of a Python object method "
"with both instance-level and class-level behavior."
msgstr ""

#: ../../peewee/playhouse.rst:3009
msgid ""
"When called with an ``Interval`` instance, the ``contains`` method will "
"behave as you would expect. When called as a classmethod, though, a SQL "
"expression will be generated:"
msgstr ""

#: ../../peewee/playhouse.rst:3015 ../../peewee/playhouse.rst:3061
msgid "Would generate the following SQL:"
msgstr ""

#: ../../peewee/playhouse.rst:3025
msgid "Method decorator for specifying the SQL-expression producing method."
msgstr ""

#: ../../peewee/playhouse.rst:3029
msgid ""
"Method decorator that allows the definition of a Python object property "
"with both instance-level and class-level behavior."
msgstr ""

#: ../../peewee/playhouse.rst:3051
msgid ""
"When accessed on an ``Interval`` instance, the ``length`` and ``radius`` "
"properties will behave as you would expect. When accessed as class "
"attributes, though, a SQL expression will be generated instead:"
msgstr ""

#: ../../peewee/playhouse.rst:3075
msgid "Key/Value Store"
msgstr "キーバリューストア"

#: ../../peewee/playhouse.rst:3077
msgid ""
"Provides a simple key/value store, using a dictionary API.  By default "
"the the :py:class:`KeyStore` will use an in-memory sqlite database, but "
"any database will work."
msgstr ""

#: ../../peewee/playhouse.rst:3081
msgid ""
"To start using the key-store, create an instance and pass it a field to "
"use for the values."
msgstr ""

#: ../../peewee/playhouse.rst:3092
msgid ""
"To store arbitrary python objects, use the :py:class:`PickledKeyStore`, "
"which stores values in a pickled :py:class:`BlobField`."
msgstr ""

#: ../../peewee/playhouse.rst:3095
msgid ""
"If your objects are JSON-serializable, you can also use the "
":py:class:`JSONKeyStore`, which stores the values as JSON-encoded "
"strings."
msgstr ""

#: ../../peewee/playhouse.rst:3097
msgid ""
"Using the :py:class:`KeyStore` it is possible to use \"expressions\" to "
"retrieve values from the dictionary.  For instance, imagine you want to "
"get all keys which contain a certain substring:"
msgstr ""

#: ../../peewee/playhouse.rst:3107
msgid "KeyStore API"
msgstr ""

#: ../../peewee/playhouse.rst:3111
msgid ""
"Lightweight dictionary interface to a model containing a key and value. "
"Implements common dictionary methods, such as ``__getitem__``, "
"``__setitem__``, ``get``, ``pop``, ``items``, ``keys``, and ``values``."
msgstr ""

#: ../../peewee/playhouse.rst:3115
msgid ""
"Field instance to use as value field, e.g. an instance of "
":py:class:`TextField`."
msgstr ""

#: ../../peewee/playhouse.rst:3117
msgid "Whether the keys should be returned in sorted order"
msgstr ""

#: ../../peewee/playhouse.rst:3118
msgid ""
":py:class:`Database` class to use for the storage backend.  If none is "
"supplied, an in-memory Sqlite DB will be used."
msgstr ""

#: ../../peewee/playhouse.rst:3139
msgid ""
"Identical to the :py:class:`KeyStore` except the values are stored as "
"JSON-encoded strings, so you can store complex data-types like "
"dictionaries and lists."
msgstr ""

#: ../../peewee/playhouse.rst:3154
msgid ""
"Identical to the :py:class:`KeyStore` except *anything* can be stored as "
"a value in the dictionary.  The storage for the value will be a pickled "
":py:class:`BlobField`."
msgstr ""

#: ../../peewee/playhouse.rst:3172
msgid "Shortcuts"
msgstr "ショートカット"

#: ../../peewee/playhouse.rst:3174
msgid ""
"This module contains helper functions for expressing things that would "
"otherwise be somewhat verbose or cumbersome using peewee's APIs. There "
"are also helpers for serializing models to dictionaries and vice-versa."
msgstr ""

#: ../../peewee/playhouse.rst:3178
msgid "A SQL expression or can be ``None``."
msgstr ""

#: ../../peewee/playhouse.rst:3179
msgid ""
"An iterable containing one or more 2-tuples comprised of an expression "
"and return value."
msgstr ""

#: ../../peewee/playhouse.rst:3181
msgid "default if none of the cases match."
msgstr ""

#: ../../peewee/playhouse.rst:3183
msgid "Example SQL case statements:"
msgstr ""

#: ../../peewee/playhouse.rst:3205
msgid "Equivalent function invocations:"
msgstr ""

#: ../../peewee/playhouse.rst:3217
msgid ""
"You can specify a value for the CASE expression using the ``alias()`` "
"method:"
msgstr ""

#: ../../peewee/playhouse.rst:3229
msgid ""
"A peewee :py:class:`Node`, for instance a :py:class:`Field` or an "
":py:class:`Expression`."
msgstr ""

#: ../../peewee/playhouse.rst:3230
msgid "The type name to cast to, e.g. ``'int'``."
msgstr ""

#: ../../peewee/playhouse.rst:3231
msgid "a function call to cast the node as the given type."
msgstr ""

#: ../../peewee/playhouse.rst:3249
msgid ""
"Convert a model instance (and optionally any related instances) to a "
"dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3252
msgid "Whether foreign-keys should be recursed."
msgstr ""

#: ../../peewee/playhouse.rst:3253
msgid "Whether lists of related objects should be recursed."
msgstr ""

#: ../../peewee/playhouse.rst:3254
msgid ""
"A list (or set) of field instances which should be included in the result"
" dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3255
msgid ""
"A list (or set) of field instances which should be excluded from the "
"result dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3256
msgid ""
"A list of attribute or method names on the instance which should be "
"included in the dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3257
msgid ""
"The :py:class:`SelectQuery` that created this model instance. Only the "
"fields and values explicitly selected by the query will be serialized."
msgstr ""

#: ../../peewee/playhouse.rst:3297
msgid ""
"Convert a dictionary of data to a model instance, creating related "
"instances where appropriate."
msgstr ""

#: ../../peewee/playhouse.rst:3300
msgid "The model class to construct."
msgstr ""

#: ../../peewee/playhouse.rst:3301
msgid ""
"A dictionary of data. Foreign keys can be included as nested "
"dictionaries, and back-references as lists of dictionaries."
msgstr ""

#: ../../peewee/playhouse.rst:3302
msgid "Whether to allow unrecognized (non-field) attributes."
msgstr ""

#: ../../peewee/playhouse.rst:3335
msgid ""
"When mixed-in with a vendor-specific :py:class:`Database` subclass, this "
"class overrides the :py:meth:`~Database.execute_sql` method to "
"automatically reconnect and retry queries that fail due to an "
"``OperationalError``. The query that failed will be retried only once, "
"and if it fails twice an exception will be raised."
msgstr ""

#: ../../peewee/playhouse.rst:3354
msgid "Signal support"
msgstr "シグナルサポート"

#: ../../peewee/playhouse.rst:3356
msgid ""
"Models with hooks for signals (a-la django) are provided in "
"``playhouse.signals``. To use the signals, you will need all of your "
"project's models to be a subclass of ``playhouse.signals.Model``, which "
"overrides the necessary methods to provide support for the various "
"signals."
msgstr ""

#: ../../peewee/playhouse.rst:3372
msgid ""
"For what I hope are obvious reasons, Peewee signals do not work when you "
"use the :py:meth:`Model.insert`, :py:meth:`Model.update`, or "
":py:meth:`Model.delete` methods. These methods generate queries that "
"execute beyond the scope of the ORM, and the ORM does not know about "
"which model instances might or might not be affected when the query "
"executes."
msgstr ""

#: ../../peewee/playhouse.rst:3374
msgid ""
"Signals work by hooking into the higher-level peewee APIs like "
":py:meth:`Model.save` and :py:meth:`Model.delete_instance`, where the "
"affected model instance is known ahead of time."
msgstr ""

#: ../../peewee/playhouse.rst:3376
msgid "The following signals are provided:"
msgstr ""

#: ../../peewee/playhouse.rst:3380
msgid "``pre_save``"
msgstr ""

#: ../../peewee/playhouse.rst:3379
msgid ""
"Called immediately before an object is saved to the database.  Provides "
"an additional keyword argument ``created``, indicating whether the model "
"is being saved for the first time or updated."
msgstr ""

#: ../../peewee/playhouse.rst:3384
msgid "``post_save``"
msgstr ""

#: ../../peewee/playhouse.rst:3383
msgid ""
"Called immediately after an object is saved to the database.  Provides an"
" additional keyword argument ``created``, indicating whether the model is"
" being saved for the first time or updated."
msgstr ""

#: ../../peewee/playhouse.rst:3387
msgid "``pre_delete``"
msgstr ""

#: ../../peewee/playhouse.rst:3387
msgid ""
"Called immediately before an object is deleted from the database when "
":py:meth:`Model.delete_instance` is used."
msgstr ""

#: ../../peewee/playhouse.rst:3390
msgid "``post_delete``"
msgstr ""

#: ../../peewee/playhouse.rst:3390
msgid ""
"Called immediately after an object is deleted from the database when "
":py:meth:`Model.delete_instance` is used."
msgstr ""

#: ../../peewee/playhouse.rst:3392
msgid "``pre_init``"
msgstr ""

#: ../../peewee/playhouse.rst:3393
msgid "Called when a model class is first instantiated"
msgstr ""

#: ../../peewee/playhouse.rst:3397
msgid "``post_init``"
msgstr ""

#: ../../peewee/playhouse.rst:3395
msgid ""
"Called after a model class has been instantiated and the fields have been"
" populated, for example when being selected as part of a database query."
msgstr ""

#: ../../peewee/playhouse.rst:3400
msgid "Connecting handlers"
msgstr ""

#: ../../peewee/playhouse.rst:3402
msgid ""
"Whenever a signal is dispatched, it will call any handlers that have been"
" registered. This allows totally separate code to respond to events like "
"model save and delete."
msgstr ""

#: ../../peewee/playhouse.rst:3405
msgid ""
"The :py:class:`Signal` class provides a :py:meth:`~Signal.connect` "
"method, which takes a callback function and two optional parameters for "
"\"sender\" and \"name\".  If specified, the \"sender\" parameter should "
"be a single model class and allows your callback to only receive signals "
"from that one model class.  The \"name\" parameter is used as a "
"convenient alias in the event you wish to unregister your signal handler."
msgstr ""

#: ../../peewee/playhouse.rst:3423
msgid ""
"All signal handlers accept as their first two arguments ``sender`` and "
"``instance``, where ``sender`` is the model class and ``instance`` is the"
" actual model being acted upon."
msgstr ""

#: ../../peewee/playhouse.rst:3427
msgid ""
"If you'd like, you can also use a decorator to connect signal handlers.  "
"This is functionally equivalent to the above example:"
msgstr ""

#: ../../peewee/playhouse.rst:3438
msgid "Signal API"
msgstr ""

#: ../../peewee/playhouse.rst:3442
msgid ""
"Stores a list of receivers (callbacks) and calls them when the \"send\" "
"method is invoked."
msgstr ""

#: ../../peewee/playhouse.rst:3446
msgid ""
"Add the receiver to the internal list of receivers, which will be called "
"whenever the signal is sent."
msgstr ""

#: ../../peewee/playhouse.rst:3449
msgid ""
"a callable that takes at least two parameters, a \"sender\", which is the"
" Model subclass that triggered the signal, and an \"instance\", which is "
"the actual model instance."
msgstr ""

#: ../../peewee/playhouse.rst:3452
msgid ""
"if specified, only instances of this model class will trigger the "
"receiver callback."
msgstr ""

#: ../../peewee/playhouse.rst:3454 ../../peewee/playhouse.rst:3470
msgid "a short alias"
msgstr ""

#: ../../peewee/playhouse.rst:3465
msgid ""
"Disconnect the given receiver (or the receiver with the given name alias)"
" so that it no longer is called.  Either the receiver or the name must be"
" provided."
msgstr ""

#: ../../peewee/playhouse.rst:3469
msgid "the callback to disconnect"
msgstr ""

#: ../../peewee/playhouse.rst:3478
msgid ""
"Iterates over the receivers and will call them in the order in which they"
" were connected.  If the receiver specified a sender, it will only be "
"called if the instance is an instance of the sender."
msgstr ""

#: ../../peewee/playhouse.rst:3482
msgid "a model instance"
msgstr ""

#: ../../peewee/playhouse.rst:3501
msgid "pwiz, a model generator"
msgstr "pwiz、モデルジェネレータ"

#: ../../peewee/playhouse.rst:3503
msgid ""
"``pwiz`` is a little script that ships with peewee and is capable of "
"introspecting an existing database and generating model code suitable for"
" interacting with the underlying data.  If you have a database already, "
"pwiz can give you a nice boost by generating skeleton code with correct "
"column affinities and foreign keys."
msgstr ""

#: ../../peewee/playhouse.rst:3508
msgid ""
"If you install peewee using ``setup.py install``, pwiz will be installed "
"as a \"script\" and you can just run:"
msgstr ""

#: ../../peewee/playhouse.rst:3516
msgid "This will print a bunch of models to standard output.  So you can do this:"
msgstr ""

#: ../../peewee/playhouse.rst:3532 ../../peewee/querying.rst:919
msgid "Example"
msgstr ""

#: ../../peewee/playhouse.rst:3534
msgid "-h"
msgstr ""

#: ../../peewee/playhouse.rst:3534
msgid "show help"
msgstr ""

#: ../../peewee/playhouse.rst:3535
msgid "-e"
msgstr ""

#: ../../peewee/playhouse.rst:3535
msgid "database backend"
msgstr ""

#: ../../peewee/playhouse.rst:3535
msgid "-e mysql"
msgstr ""

#: ../../peewee/playhouse.rst:3536
msgid "-H"
msgstr ""

#: ../../peewee/playhouse.rst:3536
msgid "host to connect to"
msgstr ""

#: ../../peewee/playhouse.rst:3536
msgid "-H remote.db.server"
msgstr ""

#: ../../peewee/playhouse.rst:3537
msgid "-p"
msgstr ""

#: ../../peewee/playhouse.rst:3537
msgid "port to connect on"
msgstr ""

#: ../../peewee/playhouse.rst:3537
msgid "-p 9001"
msgstr ""

#: ../../peewee/playhouse.rst:3538
msgid "-u"
msgstr ""

#: ../../peewee/playhouse.rst:3538
msgid "database user"
msgstr ""

#: ../../peewee/playhouse.rst:3538
msgid "-u postgres"
msgstr ""

#: ../../peewee/playhouse.rst:3539
msgid "-P"
msgstr ""

#: ../../peewee/playhouse.rst:3539
msgid "database password"
msgstr ""

#: ../../peewee/playhouse.rst:3539
msgid "-P secret"
msgstr ""

#: ../../peewee/playhouse.rst:3540
msgid "-s"
msgstr ""

#: ../../peewee/playhouse.rst:3540
msgid "postgres schema"
msgstr ""

#: ../../peewee/playhouse.rst:3540
msgid "-s public"
msgstr ""

#: ../../peewee/playhouse.rst:3543
msgid "The following are valid parameters for the engine:"
msgstr ""

#: ../../peewee/playhouse.rst:3545 ../../peewee/playhouse.rst:4246
msgid "sqlite"
msgstr ""

#: ../../peewee/playhouse.rst:3546
msgid "mysql"
msgstr ""

#: ../../peewee/playhouse.rst:3547
msgid "postgresql"
msgstr ""

#: ../../peewee/playhouse.rst:3552
msgid "Schema Migrations"
msgstr "スキーママイグレーション"

#: ../../peewee/playhouse.rst:3554
msgid ""
"Peewee now supports schema migrations, with well-tested support for "
"Postgresql, SQLite and MySQL. Unlike other schema migration tools, "
"peewee's migrations do not handle introspection and database "
"\"versioning\". Rather, peewee provides a number of helper functions for "
"generating and running schema-altering statements. This engine provides "
"the basis on which a more sophisticated tool could some day be built."
msgstr ""

#: ../../peewee/playhouse.rst:3560
msgid ""
"Migrations can be written as simple python scripts and executed from the "
"command-line. Since the migrations only depend on your applications "
":py:class:`Database` object, it should be easy to manage changing your "
"model definitions and maintaining a set of migration scripts without "
"introducing dependencies."
msgstr ""

#: ../../peewee/playhouse.rst:3566
msgid "Example usage"
msgstr ""

#: ../../peewee/playhouse.rst:3568
msgid "Begin by importing the helpers from the `migrate` module:"
msgstr ""

#: ../../peewee/playhouse.rst:3574
msgid ""
"Instantiate a ``migrator``. The :py:class:`SchemaMigrator` class is "
"responsible for generating schema altering operations, which can then be "
"run sequentially by the :py:func:`migrate` helper."
msgstr ""

#: ../../peewee/playhouse.rst:3588
msgid "Use :py:func:`migrate` to execute one or more operations:"
msgstr ""

#: ../../peewee/playhouse.rst:3602
msgid ""
"Migrations are not run inside a transaction. If you wish the migration to"
" run in a transaction you will need to wrap the call to `migrate` in a "
"transaction block, e.g."
msgstr ""

#: ../../peewee/playhouse.rst:3612
msgid "Supported Operations"
msgstr ""

#: ../../peewee/playhouse.rst:3614
msgid "Add new field(s) to an existing model:"
msgstr ""

#: ../../peewee/playhouse.rst:3629
msgid "Renaming a field:"
msgstr ""

#: ../../peewee/playhouse.rst:3639
msgid "Dropping a field:"
msgstr ""

#: ../../peewee/playhouse.rst:3647
msgid "Making a field nullable or not nullable:"
msgstr ""

#: ../../peewee/playhouse.rst:3661
msgid "Renaming a table:"
msgstr ""

#: ../../peewee/playhouse.rst:3669
msgid "Adding an index:"
msgstr ""

#: ../../peewee/playhouse.rst:3686
msgid "Dropping an index:"
msgstr ""

#: ../../peewee/playhouse.rst:3695
msgid "Migrations API"
msgstr ""

#: ../../peewee/playhouse.rst:3699
msgid "Execute one or more schema altering operations."
msgstr ""

#: ../../peewee/playhouse.rst:3714
msgid ""
"The :py:class:`SchemaMigrator` is responsible for generating schema-"
"altering statements."
msgstr ""

#: ../../peewee/playhouse.rst:3719
msgid "Name of the table to add column to."
msgstr ""

#: ../../peewee/playhouse.rst:3720
msgid "Name of the new column."
msgstr ""

#: ../../peewee/playhouse.rst:3721
msgid "A :py:class:`Field` instance."
msgstr ""

#: ../../peewee/playhouse.rst:3723
msgid ""
"Add a new column to the provided table. The ``field`` provided will be "
"used to generate the appropriate column definition."
msgstr ""

#: ../../peewee/playhouse.rst:3726
msgid "If the field is not nullable it must specify a default value."
msgstr ""

#: ../../peewee/playhouse.rst:3729
msgid ""
"For non-null fields, the field will initially be added as a null field, "
"then an ``UPDATE`` statement will be executed to populate the column with"
" the default value. Finally, the column will be marked as not null."
msgstr ""

#: ../../peewee/playhouse.rst:3735
msgid "Name of the table to drop column from."
msgstr ""

#: ../../peewee/playhouse.rst:3736
msgid "Name of the column to drop."
msgstr ""

#: ../../peewee/playhouse.rst:3737
msgid "Whether the column should be dropped with `CASCADE`."
msgstr ""

#: ../../peewee/playhouse.rst:3741
msgid "Name of the table containing column to rename."
msgstr ""

#: ../../peewee/playhouse.rst:3742
msgid "Current name of the column."
msgstr ""

#: ../../peewee/playhouse.rst:3743
msgid "New name for the column."
msgstr ""

#: ../../peewee/playhouse.rst:3747 ../../peewee/playhouse.rst:3752
msgid "Name of table containing column."
msgstr ""

#: ../../peewee/playhouse.rst:3748
msgid "Name of the column to make not nullable."
msgstr ""

#: ../../peewee/playhouse.rst:3753
msgid "Name of the column to make nullable."
msgstr ""

#: ../../peewee/playhouse.rst:3757
msgid "Current name of the table."
msgstr ""

#: ../../peewee/playhouse.rst:3758
msgid "New name for the table."
msgstr ""

#: ../../peewee/playhouse.rst:3762
msgid "Name of table on which to create the index."
msgstr ""

#: ../../peewee/playhouse.rst:3763
msgid "List of columns which should be indexed."
msgstr ""

#: ../../peewee/playhouse.rst:3764
msgid "Whether the new index should specify a unique constraint."
msgstr ""

#: ../../peewee/playhouse.rst:3768
msgid ""
":param str table Name of the table containing the index to be dropped. "
":param str index_name: Name of the index to be dropped."
msgstr ""

#: ../../peewee/playhouse.rst:3773
msgid "Generate migrations for Postgresql databases."
msgstr ""

#: ../../peewee/playhouse.rst:3777
msgid "Generate migrations for SQLite databases."
msgstr ""

#: ../../peewee/playhouse.rst:3781
msgid "Generate migrations for MySQL databases."
msgstr ""

#: ../../peewee/playhouse.rst:3787
msgid "Reflection"
msgstr "リフレクション"

#: ../../peewee/playhouse.rst:3789
msgid ""
"The reflection module contains helpers for introspecting existing "
"databases. This module is used internally by several other modules in the"
" playhouse, including :ref:`dataset` and :ref:`pwiz`."
msgstr ""

#: ../../peewee/playhouse.rst:3793
msgid ""
"Metadata can be extracted from a database by instantiating an "
":py:class:`Introspector`. Rather than instantiating this class directly, "
"it is recommended to use the factory method "
":py:meth:`~Introspector.from_database`."
msgstr ""

#: ../../peewee/playhouse.rst:3797
msgid ""
"Creates an :py:class:`Introspector` instance suitable for use with the "
"given database."
msgstr ""

#: ../../peewee/playhouse.rst:3800
msgid "an optional schema (supported by some databases)."
msgstr ""

#: ../../peewee/playhouse.rst:3817
msgid ""
"Introspect the database, reading in the tables, columns, and foreign key "
"constraints, then generate a dictionary mapping each database table to a "
"dynamically-generated :py:class:`Model` class."
msgstr ""

#: ../../peewee/playhouse.rst:3819
msgid "A dictionary mapping table-names to model classes."
msgstr ""

#: ../../peewee/playhouse.rst:3825
msgid "Database URL"
msgstr "データベースのURL"

#: ../../peewee/playhouse.rst:3827
msgid ""
"This module contains a helper function to generate a database connection "
"from a URL connection string."
msgstr ""

#: ../../peewee/playhouse.rst:3831
msgid "Create a :py:class:`Database` instance from the given connection URL."
msgstr ""

#: ../../peewee/playhouse.rst:3839
msgid ""
"*mysql+pool://user:passwd@ip:port/my_db?max_connections=20&stale_timeout=300*"
" will create a :py:class:`PooledMySQLDatabase` instance for the local "
"MySQL database *my_db* with max_connections set to 20 and a stale_timeout"
" setting of 300 seconds."
msgstr ""

#: ../../peewee/playhouse.rst:3841
msgid "Supported schemes:"
msgstr ""

#: ../../peewee/playhouse.rst:3843
msgid "``apsw``: :py:class:`APSWDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3844
msgid "``mysql``: :py:class:`MySQLDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3845
msgid "``mysql+pool``: :py:class:`PooledMySQLDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3846
msgid "``postgres``: :py:class:`PostgresqlDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3847
msgid "``postgres+pool``: :py:class:`PooledPostgresqlDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3848
msgid "``postgresext``: :py:class:`PostgresqlExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3849
msgid "``postgresext+pool``: :py:class:`PooledPostgresqlExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3850
msgid "``sqlite``: :py:class:`SqliteDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3851
msgid "``sqliteext``: :py:class:`SqliteExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3852
msgid "``sqlite+pool``: :py:class:`PooledSqliteDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3853
msgid "``sqliteext+pool``: :py:class:`PooledSqliteExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3868
msgid ""
"Parse the information in the given URL into a dictionary containing "
"``database``, ``host``, ``port``, ``user`` and/or ``password``. "
"Additional connection arguments can be passed in the URL query string."
msgstr ""

#: ../../peewee/playhouse.rst:3870
msgid ""
"If you are using a custom database class, you can use the ``parse()`` "
"function to extract information from a URL which can then be passed in to"
" your database object."
msgstr ""

#: ../../peewee/playhouse.rst:3874
msgid "A subclass of :py:class:`Database`."
msgstr ""

#: ../../peewee/playhouse.rst:3875
msgid ""
"A list of names to use as the scheme in the URL, e.g. 'sqlite' or "
"'firebird'"
msgstr ""

#: ../../peewee/playhouse.rst:3877
msgid ""
"Register additional database class under the specified names. This "
"function can be used to extend the ``connect()`` function to support "
"additional schemes. Suppose you have a custom database class for "
"``Firebird`` named ``FirebirdDatabase``."
msgstr ""

#: ../../peewee/playhouse.rst:3889
msgid "CSV Utils"
msgstr ""

#: ../../peewee/playhouse.rst:3891
msgid ""
"This module contains helpers for dumping queries into CSV, and for "
"loading CSV data into a database.  CSV files can be introspected to "
"generate an appropriate model class for working with the data. This makes"
" it really easy to explore the data in a CSV file using Peewee and SQL."
msgstr ""

#: ../../peewee/playhouse.rst:3893
msgid ""
"Here is how you would load a CSV file into an in-memory SQLite database."
"  The call to :py:func:`load_csv` returns a :py:class:`Model` instance "
"suitable for working with the CSV data:"
msgstr ""

#: ../../peewee/playhouse.rst:3902
msgid "Now we can run queries using the new model."
msgstr ""

#: ../../peewee/playhouse.rst:3915
msgid ""
"For more information and examples check out this `blog post "
"<http://charlesleifer.com/blog/using-peewee-to-explore-csv-files/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:3918
msgid "CSV Loader API"
msgstr ""

#: ../../peewee/playhouse.rst:3922
msgid ""
"Load a CSV file into the provided database or model class, returning a "
":py:class:`Model` suitable for working with the CSV data."
msgstr ""

#: ../../peewee/playhouse.rst:3925
msgid ""
"Either a :py:class:`Database` instance or a :py:class:`Model` class.  If "
"a model is not provided, one will be automatically generated for you."
msgstr ""

#: ../../peewee/playhouse.rst:3926
msgid "Path of CSV file to load."
msgstr ""

#: ../../peewee/playhouse.rst:3927
msgid ""
"A list of :py:class:`Field` instances mapping to each column in the CSV."
"  This allows you to manually specify the column types.  If not provided,"
" and a model is not provided, the field types will be determined "
"automatically."
msgstr ""

#: ../../peewee/playhouse.rst:3928
msgid ""
"A list of strings to use as field names for each column in the CSV.  If "
"not provided, and a model is not provided, the field names will be "
"determined by looking at the header row of the file.  If no header "
"exists, then the fields will be given generic names."
msgstr ""

#: ../../peewee/playhouse.rst:3929
msgid "Whether the first row is a header."
msgstr ""

#: ../../peewee/playhouse.rst:3930
msgid ""
"Number of rows to look at when introspecting data types.  If set to "
"``0``, then a generic field type will be used for all fields."
msgstr ""

#: ../../peewee/playhouse.rst:3931
msgid ""
"a :py:class:`RowConverter` instance to use for introspecting the CSV.  If"
" not provided, one will be created."
msgstr ""

#: ../../peewee/playhouse.rst:3932
msgid ""
"The name of the database table to load data into.  If this value is not "
"provided, it will be determined using the filename of the CSV file.  If a"
" model is provided, this value is ignored."
msgstr ""

#: ../../peewee/playhouse.rst:3933
msgid ""
"Arbitrary keyword arguments to pass to the ``csv.reader`` object, such as"
" the dialect, separator, etc."
msgstr ""

#: ../../peewee/playhouse.rst:3934
msgid "A :py:class:`Model` suitable for querying the CSV data."
msgstr ""

#: ../../peewee/playhouse.rst:3936
msgid "Basic example -- field names and types will be introspected:"
msgstr ""

#: ../../peewee/playhouse.rst:3945
msgid "Using a pre-defined model:"
msgstr ""

#: ../../peewee/playhouse.rst:3955
msgid "Specifying fields:"
msgstr ""

#: ../../peewee/playhouse.rst:3964
msgid "Dumping CSV"
msgstr ""

#: ../../peewee/playhouse.rst:3968
msgid "A peewee :py:class:`SelectQuery` to dump as CSV."
msgstr ""

#: ../../peewee/playhouse.rst:3969
msgid "Either a filename or a file-like object."
msgstr ""

#: ../../peewee/playhouse.rst:3970
msgid ""
"Whether to generate a CSV header row consisting of the names of the "
"selected columns."
msgstr ""

#: ../../peewee/playhouse.rst:3971
msgid "Whether the file should be closed after writing the query data."
msgstr ""

#: ../../peewee/playhouse.rst:3972
msgid "Whether new data should be appended to the end of the file."
msgstr ""

#: ../../peewee/playhouse.rst:3973
msgid "A python ``csv.writer`` instance to use."
msgstr ""

#: ../../peewee/playhouse.rst:3987
msgid "Connection pool"
msgstr "コネクションプール"

#: ../../peewee/playhouse.rst:3989
msgid ""
"The ``pool`` module contains a number of :py:class:`Database` classes "
"that provide connection pooling for PostgreSQL and MySQL databases. The "
"pool works by overriding the methods on the :py:class:`Database` class "
"that open and close connections to the backend. The pool can specify a "
"timeout after which connections are recycled, as well as an upper bound "
"on the number of open connections."
msgstr ""

#: ../../peewee/playhouse.rst:3991
msgid ""
"In a multi-threaded application, up to `max_connections` will be opened. "
"Each thread (or, if using gevent, greenlet) will have it's own "
"connection."
msgstr ""

#: ../../peewee/playhouse.rst:3993
msgid ""
"In a single-threaded application, only one connection will be created. It"
" will be continually recycled until either it exceeds the stale timeout "
"or is closed explicitly (using `.manual_close()`)."
msgstr ""

#: ../../peewee/playhouse.rst:3995
msgid ""
"**By default, all your application needs to do is ensure that connections"
" are closed when you are finished with them, and they will be returned to"
" the pool**. For web applications, this typically means that at the "
"beginning of a request, you will open a connection, and when you return a"
" response, you will close the connection."
msgstr ""

#: ../../peewee/playhouse.rst:3997
msgid "Simple Postgres pool example code:"
msgstr ""

#: ../../peewee/playhouse.rst:4014
msgid ""
"That's it! If you would like finer-grained control over the pool of "
"connections, check out the :ref:`advanced_connection_management` section."
msgstr ""

#: ../../peewee/playhouse.rst:4017
msgid "Pool APIs"
msgstr ""

#: ../../peewee/playhouse.rst:4021
msgid "Mixin class intended to be used with a subclass of :py:class:`Database`."
msgstr ""

#: ../../peewee/playhouse.rst:4023
msgid "The name of the database or database file."
msgstr ""

#: ../../peewee/playhouse.rst:4024
msgid "Maximum number of connections. Provide ``None`` for unlimited."
msgstr ""

#: ../../peewee/playhouse.rst:4025
msgid "Number of seconds to allow connections to be used."
msgstr ""

#: ../../peewee/playhouse.rst:4026
msgid ""
"Number of seconds block when pool is full. By default peewee does not "
"block when the pool is full but simply throws an exception. To block "
"indefinitely set this value to ``0``."
msgstr ""

#: ../../peewee/playhouse.rst:4027
msgid "Arbitrary keyword arguments passed to database class."
msgstr ""

#: ../../peewee/playhouse.rst:4029
msgid ""
"Connections will not be closed exactly when they exceed their "
"`stale_timeout`. Instead, stale connections are only closed when a new "
"connection is requested."
msgstr ""

#: ../../peewee/playhouse.rst:4031
msgid ""
"If the number of open connections exceeds `max_connections`, a "
"`ValueError` will be raised."
msgstr ""

#: ../../peewee/playhouse.rst:4035
msgid ""
"Request a connection from the pool. If there are no available connections"
" a new one will be opened."
msgstr ""

#: ../../peewee/playhouse.rst:4039
msgid ""
"By default `conn` will not be closed and instead will be returned to the "
"pool of available connections. If `close_conn=True`, then `conn` will be "
"closed and *not* be returned to the pool."
msgstr ""

#: ../../peewee/playhouse.rst:4043
msgid "Close the currently-open connection without returning it to the pool."
msgstr ""

#: ../../peewee/playhouse.rst:4047
msgid ""
"Subclass of :py:class:`PostgresqlDatabase` that mixes in the "
":py:class:`PooledDatabase` helper."
msgstr ""

#: ../../peewee/playhouse.rst:4051
msgid ""
"Subclass of :py:class:`PostgresqlExtDatabase` that mixes in the "
":py:class:`PooledDatabase` helper. The :py:class:`PostgresqlExtDatabase` "
"is a part of the :ref:`postgres_ext` module and provides support for many"
" Postgres-specific features."
msgstr ""

#: ../../peewee/playhouse.rst:4057
msgid ""
"Subclass of :py:class:`MySQLDatabase` that mixes in the "
":py:class:`PooledDatabase` helper."
msgstr ""

#: ../../peewee/playhouse.rst:4061
msgid "Persistent connections for SQLite apps."
msgstr ""

#: ../../peewee/playhouse.rst:4065
msgid ""
"Persistent connections for SQLite apps, using the :ref:`sqlite_ext` "
"advanced database driver :py:class:`SqliteExtDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:4073
msgid ""
"The ``read_slave`` module contains a :py:class:`Model` subclass that can "
"be used to automatically execute ``SELECT`` queries against different "
"database(s). This might be useful if you have your databases in a master "
"/ slave configuration."
msgstr ""

#: ../../peewee/playhouse.rst:4079
msgid "Model subclass that will route ``SELECT`` queries to a different database."
msgstr ""

#: ../../peewee/playhouse.rst:4081
msgid "Master and read-slaves are specified using ``Model.Meta``:"
msgstr ""

#: ../../peewee/playhouse.rst:4100
msgid ""
"When you execute writes (or deletes), they will be executed against the "
"master database:"
msgstr ""

#: ../../peewee/playhouse.rst:4107
msgid "When you execute a read query, it will run against one of the replicas:"
msgstr ""

#: ../../peewee/playhouse.rst:4114
msgid ""
"To force a ``SELECT`` query against the master database, manually create "
"the :py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:4122
msgid ""
"Queries will be dispatched among the ``read_slaves`` in round-robin "
"fashion."
msgstr ""

#: ../../peewee/playhouse.rst:4127
msgid "Test Utils"
msgstr ""

#: ../../peewee/playhouse.rst:4129
msgid "Contains utilities helpful when testing peewee projects."
msgstr ""

#: ../../peewee/playhouse.rst:4133
msgid ""
"Context manager that lets you use a different database with a set of "
"models.  Models can also be automatically created and dropped."
msgstr ""

#: ../../peewee/playhouse.rst:4136
msgid ""
"This context manager helps make it possible to test your peewee models "
"using a \"test-only\" database."
msgstr ""

#: ../../peewee/playhouse.rst:4139
msgid "Database to use with the given models"
msgstr ""

#: ../../peewee/playhouse.rst:4140
msgid ""
"a ``list`` or ``tuple`` of :py:class:`Model` classes to use with the "
"``db``"
msgstr ""

#: ../../peewee/playhouse.rst:4141
msgid "Whether tables should be automatically created and dropped."
msgstr ""

#: ../../peewee/playhouse.rst:4143
msgid "Whether the table create / drop should fail silently."
msgstr ""

#: ../../peewee/playhouse.rst:4181
msgid ""
"Context manager that will count the number of queries executed within the"
" context."
msgstr ""

#: ../../peewee/playhouse.rst:4184
msgid "Only count *SELECT* queries."
msgstr ""

#: ../../peewee/playhouse.rst:4196
msgid "The number of queries executed."
msgstr ""

#: ../../peewee/playhouse.rst:4200
msgid ""
"Return a list of 2-tuples consisting of the SQL query and a list of "
"parameters."
msgstr ""

#: ../../peewee/playhouse.rst:4206
msgid ""
"Function or method decorator that will raise an ``AssertionError`` if the"
" number of queries executed in the decorated function does not equal the "
"expected number."
msgstr ""

#: ../../peewee/playhouse.rst:4220
msgid "This function can also be used as a context manager:"
msgstr ""

#: ../../peewee/playhouse.rst:4232
msgid "pskel"
msgstr ""

#: ../../peewee/playhouse.rst:4234
msgid ""
"I often find myself writing very small scripts with peewee. *pskel* will "
"generate the boilerplate code for a basic peewee script."
msgstr ""

#: ../../peewee/playhouse.rst:4236
msgid "Usage::"
msgstr ""

#: ../../peewee/playhouse.rst:4240
msgid "*pskel* accepts the following options:"
msgstr ""

#: ../../peewee/playhouse.rst:4243
msgid "Default"
msgstr ""

#: ../../peewee/playhouse.rst:4243
msgid "Description"
msgstr ""

#: ../../peewee/playhouse.rst:4245
msgid "``-l,--logging``"
msgstr ""

#: ../../peewee/playhouse.rst:4245
msgid "False"
msgstr ""

#: ../../peewee/playhouse.rst:4245
msgid "Log all queries to stdout."
msgstr ""

#: ../../peewee/playhouse.rst:4246
msgid "``-e,--engine``"
msgstr ""

#: ../../peewee/playhouse.rst:4246
msgid "Database driver to use."
msgstr ""

#: ../../peewee/playhouse.rst:4247
msgid "``-d,--database``"
msgstr ""

#: ../../peewee/playhouse.rst:4247
msgid "``:memory:``"
msgstr ""

#: ../../peewee/playhouse.rst:4247
msgid "Database to connect to."
msgstr ""

#: ../../peewee/playhouse.rst:4250
msgid "Example::"
msgstr ""

#: ../../peewee/playhouse.rst:4254
msgid ""
"This will print the following code to *stdout* (which you can redirect "
"into a file using ``>``):"
msgstr ""

#: ../../peewee/playhouse.rst:4287
msgid "Flask Utils"
msgstr ""

#: ../../peewee/playhouse.rst:4289
msgid ""
"The ``playhouse.flask_utils`` module contains several helpers for "
"integrating peewee with the `Flask <http://flask.pocoo.org/>`_ web "
"framework."
msgstr ""

#: ../../peewee/playhouse.rst:4292
#, fuzzy
msgid "Database Wrapper"
msgstr "データベースエラー"

#: ../../peewee/playhouse.rst:4294
msgid ""
"The :py:class:`FlaskDB` class is a wrapper for configuring and "
"referencing a Peewee database from within a Flask application. Don't let "
"it's name fool you: it is **not the same thing as a peewee database**. "
"``FlaskDB`` is designed to remove the following boilerplate from your "
"flask app:"
msgstr ""

#: ../../peewee/playhouse.rst:4299
msgid "Dynamically create a Peewee database instance based on app config data."
msgstr ""

#: ../../peewee/playhouse.rst:4300
msgid "Create a base class from which all your application's models will descend."
msgstr ""

#: ../../peewee/playhouse.rst:4301
msgid ""
"Register hooks at the start and end of a request to handle opening and "
"closing a database connection."
msgstr ""

#: ../../peewee/playhouse.rst:4304
msgid "Basic usage:"
msgstr ""

#: ../../peewee/playhouse.rst:4328
msgid ""
"The above code example will create and instantiate a peewee "
":py:class:`PostgresqlDatabase` specified by the given database URL. "
"Request hooks will be configured to establish a connection when a request"
" is received, and automatically close the connection when the response is"
" sent. Lastly, the :py:class:`FlaskDB` class exposes a "
":py:attr:`FlaskDB.Model` property which can be used as a base for your "
"application's models."
msgstr ""

#: ../../peewee/playhouse.rst:4330
msgid ""
"Here is how you can access the wrapped Peewee database instance that is "
"configured for you by the ``FlaskDB`` wrapper:"
msgstr ""

#: ../../peewee/playhouse.rst:4345
msgid ""
"The actual peewee database can be accessed using the ``FlaskDB.database``"
" attribute."
msgstr ""

#: ../../peewee/playhouse.rst:4347
msgid "Here is another way to configure a Peewee database using ``FlaskDB``:"
msgstr ""

#: ../../peewee/playhouse.rst:4354
msgid ""
"While the above examples show using a database URL, for more advanced "
"usages you can specify a dictionary of configuration options, or simply "
"pass in a peewee :py:class:`Database` instance:"
msgstr ""

#: ../../peewee/playhouse.rst:4372
msgid "Using a peewee :py:class:`Database` object:"
msgstr ""

#: ../../peewee/playhouse.rst:4382
msgid "Database with Application Factory"
msgstr ""

#: ../../peewee/playhouse.rst:4384
msgid ""
"If you prefer to use the `application factory pattern "
"<http://flask.pocoo.org/docs/0.10/patterns/appfactories/>`_, the "
":py:class:`FlaskDB` class implements an ``init_app()`` method."
msgstr ""

#: ../../peewee/playhouse.rst:4386
msgid "Using as a factory:"
msgstr ""

#: ../../peewee/playhouse.rst:4405
msgid "Query utilities"
msgstr ""

#: ../../peewee/playhouse.rst:4407
msgid ""
"The ``flask_utils`` module provides several helpers for managing queries "
"in your web app. Some common patterns include:"
msgstr ""

#: ../../peewee/playhouse.rst:4411
msgid ""
"Retrieve the object matching the given query, or return a 404 not found "
"response. A common use-case might be a detail page for a weblog. You want"
" to either retrieve the post matching the given URL, or return a 404."
msgstr ""

#: ../../peewee/playhouse.rst:4413
msgid ""
"Either a :py:class:`Model` class or a pre-filtered "
":py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:4414
msgid "An arbitrarily complex peewee expression."
msgstr ""

#: ../../peewee/playhouse.rst:4428
msgid ""
"Retrieve a paginated list of objects specified by the given query. The "
"paginated object list will be dropped into the context using the given "
"``context_variable``, as well as metadata about the current page and "
"total number of pages, and finally any arbitrary context data passed as "
"keyword-arguments."
msgstr ""

#: ../../peewee/playhouse.rst:4430
msgid ""
"The page is specified using the ``page`` ``GET`` argument, e.g. ``/my-"
"object-list/?page=3`` would return the third page of objects."
msgstr ""

#: ../../peewee/playhouse.rst:4432
msgid "The name of the template to render."
msgstr ""

#: ../../peewee/playhouse.rst:4433
msgid "A :py:class:`SelectQuery` instance to paginate."
msgstr ""

#: ../../peewee/playhouse.rst:4434
msgid "The context variable name to use for the paginated object list."
msgstr ""

#: ../../peewee/playhouse.rst:4435 ../../peewee/playhouse.rst:4468
msgid "Number of objects per-page."
msgstr ""

#: ../../peewee/playhouse.rst:4436 ../../peewee/playhouse.rst:4469
msgid "The name of the ``GET`` argument which contains the page."
msgstr ""

#: ../../peewee/playhouse.rst:4437 ../../peewee/playhouse.rst:4470
msgid ""
"Whether to check that the given page is a valid page. If ``check_bounds``"
" is ``True`` and an invalid page is specified, then a 404 will be "
"returned."
msgstr ""

#: ../../peewee/playhouse.rst:4438
msgid "Arbitrary key/value pairs to pass into the template context."
msgstr ""

#: ../../peewee/playhouse.rst:4457
msgid "The template will have the following context:"
msgstr ""

#: ../../peewee/playhouse.rst:4459
msgid "``post_list``, which contains a list of up to 10 posts."
msgstr ""

#: ../../peewee/playhouse.rst:4460
msgid ""
"``page``, which contains the current page based on the value of the "
"``page`` ``GET`` parameter."
msgstr ""

#: ../../peewee/playhouse.rst:4461
msgid "``pagination``, a :py:class:`PaginatedQuery` instance."
msgstr ""

#: ../../peewee/playhouse.rst:4465
msgid "Helper class to perform pagination based on ``GET`` arguments."
msgstr ""

#: ../../peewee/playhouse.rst:4467
msgid ""
"Either a :py:class:`Model` or a :py:class:`SelectQuery` instance "
"containing the collection of records you wish to paginate."
msgstr ""

#: ../../peewee/playhouse.rst:4474
msgid ""
"Return the currently selected page, as indicated by the value of the "
"``page_var`` ``GET`` parameter. If no page is explicitly selected, then "
"this method will return 1, indicating the first page."
msgstr ""

#: ../../peewee/playhouse.rst:4478
msgid "Return the total number of possible pages."
msgstr ""

#: ../../peewee/playhouse.rst:4482
msgid ""
"Using the value of :py:meth:`~PaginatedQuery.get_page`, return the page "
"of objects requested by the user. The return value is a "
":py:class:`SelectQuery` with the appropriate ``LIMIT`` and ``OFFSET`` "
"clauses."
msgstr ""

#: ../../peewee/playhouse.rst:4484
msgid ""
"If ``check_bounds`` was set to ``True`` and the requested page contains "
"no objects, then a 404 will be raised."
msgstr ""

#: ../../peewee/querying.rst:4
msgid "Querying"
msgstr "クエリ"

#: ../../peewee/querying.rst:6
msgid ""
"This section will cover the basic CRUD operations commonly performed on a"
" relational database:"
msgstr ""

#: ../../peewee/querying.rst:8
msgid ":py:meth:`Model.create`, for executing *INSERT* queries."
msgstr ""

#: ../../peewee/querying.rst:9
msgid ""
":py:meth:`Model.save` and :py:meth:`Model.update`, for executing *UPDATE*"
" queries."
msgstr ""

#: ../../peewee/querying.rst:10
msgid ""
":py:meth:`Model.delete_instance` and :py:meth:`Model.delete`, for "
"executing *DELETE* queries."
msgstr ""

#: ../../peewee/querying.rst:11
msgid ":py:meth:`Model.select`, for executing *SELECT* queries."
msgstr ""

#: ../../peewee/querying.rst:14
msgid "Creating a new record"
msgstr "新しいレコードの作成"

#: ../../peewee/querying.rst:16
msgid ""
"You can use :py:meth:`Model.create` to create a new model instance. This "
"method accepts keyword arguments, where the keys correspond to the names "
"of the model's fields. A new instance is returned and a row is added to "
"the table."
msgstr ""

#: ../../peewee/querying.rst:23
msgid ""
"This will *INSERT* a new row into the database. The primary key will "
"automatically be retrieved and stored on the model instance."
msgstr ""

#: ../../peewee/querying.rst:25
msgid ""
"Alternatively, you can build up a model instance programmatically and "
"then call :py:meth:`~Model.save`:"
msgstr ""

#: ../../peewee/querying.rst:41
msgid ""
"When a model has a foreign key, you can directly assign a model instance "
"to the foreign key field when creating a new record."
msgstr ""

#: ../../peewee/querying.rst:47
msgid "You can also use the value of the related object's primary key:"
msgstr ""

#: ../../peewee/querying.rst:53
msgid ""
"If you simply wish to insert data and do not need to create a model "
"instance, you can use :py:meth:`Model.insert`:"
msgstr ""

#: ../../peewee/querying.rst:60
msgid ""
"After executing the insert query, the primary key of the new row is "
"returned."
msgstr ""

#: ../../peewee/querying.rst:63
msgid ""
"There are several ways you can speed up bulk insert operations. Check out"
" the :ref:`bulk_inserts` recipe section for more information."
msgstr ""

#: ../../peewee/querying.rst:69
msgid "Bulk inserts"
msgstr "一括挿入"

#: ../../peewee/querying.rst:71
msgid ""
"There are a couple of ways you can load lots of data quickly. The naive "
"approach is to simply call :py:meth:`Model.create` in a loop:"
msgstr ""

#: ../../peewee/querying.rst:84
msgid "The above approach is slow for a couple of reasons:"
msgstr ""

#: ../../peewee/querying.rst:86
msgid ""
"If you are using autocommit (the default), then each call to "
":py:meth:`~Model.create` happens in its own transaction. That is going to"
" be really slow!"
msgstr ""

#: ../../peewee/querying.rst:87
msgid ""
"There is a decent amount of Python logic getting in your way, and each "
":py:class:`InsertQuery` must be generated and parsed into SQL."
msgstr ""

#: ../../peewee/querying.rst:88
msgid ""
"That's a lot of data (in terms of raw bytes of SQL) you are sending to "
"your database to parse."
msgstr ""

#: ../../peewee/querying.rst:89
msgid ""
"We are retrieving the *last insert id*, which causes an additional query "
"to be executed in some cases."
msgstr ""

#: ../../peewee/querying.rst:91
msgid ""
"You can get a **very significant speedup** by simply wrapping this in a "
":py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/querying.rst:100
msgid ""
"The above code still suffers from points 2, 3 and 4. We can get another "
"big boost by calling :py:meth:`~Model.insert_many`. This method accepts a"
" list of dictionaries to insert."
msgstr ""

#: ../../peewee/querying.rst:108
msgid ""
"Depending on the number of rows in your data source, you may need to "
"break it up into chunks:"
msgstr ""

#: ../../peewee/querying.rst:118
msgid ""
"SQLite users should be aware of some caveats when using bulk inserts. "
"Specifically, your SQLite3 version must be 3.7.11.0 or newer to take "
"advantage of the bulk insert API. Additionally, by default SQLite limits "
"the number of bound variables in a SQL query to ``999``. This value can "
"be modified by setting the ``SQLITE_MAX_VARIABLE_NUMBER`` flag."
msgstr ""

#: ../../peewee/querying.rst:124
msgid ""
"If the data you would like to bulk load is stored in another table, you "
"can also create *INSERT* queries whose source is a *SELECT* query. Use "
"the :py:meth:`Model.insert_from` method:"
msgstr ""

#: ../../peewee/querying.rst:135
msgid "Updating existing records"
msgstr "既存レコードの更新"

#: ../../peewee/querying.rst:137
msgid ""
"Once a model instance has a primary key, any subsequent call to "
":py:meth:`~Model.save` will result in an *UPDATE* rather than another "
"*INSERT*. The model's primary key will not change:"
msgstr ""

#: ../../peewee/querying.rst:153
msgid ""
"If you want to update multiple records, issue an *UPDATE* query. The "
"following example will update all ``Tweet`` objects, marking them as "
"*published*, if they were created before today. :py:meth:`Model.update` "
"accepts keyword arguments where the keys correspond to the model's field "
"names:"
msgstr ""

#: ../../peewee/querying.rst:162
msgid ""
"For more information, see the documentation on :py:meth:`Model.update` "
"and :py:class:`UpdateQuery`."
msgstr ""

#: ../../peewee/querying.rst:165
msgid ""
"If you would like more information on performing atomic updates (such as "
"incrementing the value of a column), check out the :ref:`atomic update "
"<atomic_updates>` recipes."
msgstr ""

#: ../../peewee/querying.rst:172
msgid "Atomic updates"
msgstr "アトミックアップデート"

#: ../../peewee/querying.rst:174
msgid ""
"Peewee allows you to perform atomic updates. Let's suppose we need to "
"update some counters. The naive approach would be to write something like"
" this:"
msgstr "Peeweeはアトミックアップデートが実行することができます。いくつかのカウンターを更新する必要があるとしましょう。素朴なアプローチだと、このように書きます:"

#: ../../peewee/querying.rst:182
msgid ""
"**Do not do this!** Not only is this slow, but it is also vulnerable to "
"race conditions if multiple processes are updating the counter at the "
"same time."
msgstr "**これをしないで！** これは遅いだけでなく、複数のプロセスが同時にカウンタを更新している場合、競合状態に対しても脆弱です。"

#: ../../peewee/querying.rst:184
msgid ""
"Instead, you can update the counters atomically using "
":py:meth:`~Model.update`:"
msgstr "代わりに :py:meth:`Model.update` を使用するとカウンターをアトミックに更新できます:"

#: ../../peewee/querying.rst:191
#, python-format
msgid ""
"You can make these update statements as complex as you like. Let's give "
"all our employees a bonus equal to their previous bonus plus 10% of their"
" salary:"
msgstr "これらの更新ステートメントを好きなだけ複雑にすることができます。すべての従業員に前回のボーナスに加えて給与の10％のボーナスを加えましょう:"

#: ../../peewee/querying.rst:198
msgid ""
"We can even use a subquery to update the value of a column. Suppose we "
"had a denormalized column on the ``User`` model that stored the number of"
" tweets a user had made, and we updated this value periodically. Here is "
"how you might write such a query:"
msgstr ""
"サブクエリを使用してカラムの値を更新することもできます。ユーザが作成したツイートの数を格納した ``Userl`` "
"モデルの非正規化カラムを持ち、この値を定期的に更新したとします。このようなクエリを書く方法は次のとおりです:"

#: ../../peewee/querying.rst:207
msgid "Deleting records"
msgstr "レコードの削除"

#: ../../peewee/querying.rst:209
msgid ""
"To delete a single model instance, you can use the "
":py:meth:`Model.delete_instance` shortcut. "
":py:meth:`~Model.delete_instance` will delete the given model instance "
"and can optionally delete any dependent objects recursively (by "
"specifying `recursive=True`)."
msgstr ""

#: ../../peewee/querying.rst:222
msgid ""
"To delete an arbitrary set of rows, you can issue a *DELETE* query. The "
"following will delete all ``Tweet`` objects that are over one year old:"
msgstr ""

#: ../../peewee/querying.rst:230 ../../peewee/querying.rst:271
msgid "For more information, see the documentation on:"
msgstr ""

#: ../../peewee/querying.rst:232
msgid ":py:meth:`Model.delete_instance`"
msgstr ""

#: ../../peewee/querying.rst:233
msgid ":py:meth:`Model.delete`"
msgstr ""

#: ../../peewee/querying.rst:237
msgid "Selecting a single record"
msgstr "一つのレコードを選択"

#: ../../peewee/querying.rst:239
msgid ""
"You can use the :py:meth:`Model.get` method to retrieve a single instance"
" matching the given query."
msgstr ""

#: ../../peewee/querying.rst:241
msgid ""
"This method is a shortcut that calls :py:meth:`Model.select` with the "
"given query, but limits the result set to a single row. Additionally, if "
"no model matches the given query, a ``DoesNotExist`` exception will be "
"raised."
msgstr ""

#: ../../peewee/querying.rst:259
msgid ""
"For more advanced operations, you can use :py:meth:`SelectQuery.get`. The"
" following query retrieves the latest tweet from the user named "
"*charlie*:"
msgstr ""

#: ../../peewee/querying.rst:273
msgid ":py:meth:`Model.get`"
msgstr ""

#: ../../peewee/querying.rst:274
msgid ":py:meth:`Model.select`"
msgstr ""

#: ../../peewee/querying.rst:275
msgid ":py:meth:`SelectQuery.get`"
msgstr ""

#: ../../peewee/querying.rst:278
msgid "Create or get"
msgstr "作成するか取得する"

#: ../../peewee/querying.rst:280
msgid ""
"Peewee has one helper method for performing \"get/create\" type "
"operations:"
msgstr ""

#: ../../peewee/querying.rst:282
msgid ""
":py:meth:`Model.get_or_create`, which first attempts to retrieve the "
"matching row. Failing that, a new row will be created."
msgstr ""

#: ../../peewee/querying.rst:284
msgid ""
"For \"create or get\" type logic, typically one would rely on a *unique* "
"constraint or primary key to prevent the creation of duplicate objects. "
"As an example, let's say we wish to implement registering a new user "
"account using the :ref:`example User model <blog-models>`. The *User* "
"model has a *unique* constraint on the username field, so we will rely on"
" the database's integrity guarantees to ensure we don't end up with "
"duplicate usernames:"
msgstr ""

#: ../../peewee/querying.rst:301
msgid ""
"You can easily encapsulate this type of logic as a ``classmethod`` on "
"your own ``Model`` classes."
msgstr ""

#: ../../peewee/querying.rst:304
msgid ""
"The above example first attempts at creation, then falls back to "
"retrieval, relying on the database to enforce a unique constraint. If you"
" prefer to attempt to retrieve the record first, you can use "
":py:meth:`~Model.get_or_create`. This method is implemented along the "
"same lines as the Django function of the same name. You can use the "
"Django-style keyword argument filters to specify your ``WHERE`` "
"conditions. The function returns a 2-tuple containing the instance and a "
"boolean value indicating if the object was created."
msgstr ""

#: ../../peewee/querying.rst:313
msgid ""
"Here is how you might implement user account creation using "
":py:meth:`~Model.get_or_create`:"
msgstr ""

#: ../../peewee/querying.rst:319
msgid ""
"Suppose we have a different model ``Person`` and would like to get or "
"create a person object. The only conditions we care about when retrieving"
" the ``Person`` are their first and last names, **but** if we end up "
"needing to create a new record, we will also specify their date-of-birth "
"and favorite color:"
msgstr ""

#: ../../peewee/querying.rst:331
msgid ""
"Any keyword argument passed to :py:meth:`~Model.get_or_create` will be "
"used in the ``get()`` portion of the logic, except for the ``defaults`` "
"dictionary, which will be used to populate values on newly-created "
"instances."
msgstr ""

#: ../../peewee/querying.rst:335
msgid ""
"For more details check out the documentation for "
":py:meth:`Model.get_or_create`."
msgstr ""

#: ../../peewee/querying.rst:338
msgid "Selecting multiple records"
msgstr "複数のレコード選択"

#: ../../peewee/querying.rst:340
msgid ""
"We can use :py:meth:`Model.select` to retrieve rows from the table. When "
"you construct a *SELECT* query, the database will return any rows that "
"correspond to your query. Peewee allows you to iterate over these rows, "
"as well as use indexing and slicing operations."
msgstr ""

#: ../../peewee/querying.rst:342
msgid ""
"In the following example, we will simply call :py:meth:`~Model.select` "
"and iterate over the return value, which is an instance of "
":py:class:`SelectQuery`. This will return all the rows in the *User* "
"table:"
msgstr ""

#: ../../peewee/querying.rst:354
msgid ""
"Subsequent iterations of the same query will not hit the database as the "
"results are cached. To disable this behavior (to reduce memory usage), "
"call :py:meth:`SelectQuery.iterator` when iterating."
msgstr ""

#: ../../peewee/querying.rst:356
msgid ""
"When iterating over a model that contains a foreign key, be careful with "
"the way you access values on related models. Accidentally resolving a "
"foreign key or iterating over a back-reference can cause :ref:`N+1 query "
"behavior <nplusone>`."
msgstr ""

#: ../../peewee/querying.rst:358
msgid ""
"When you create a foreign key, such as ``Tweet.user``, you can use the "
"*related_name* to create a back-reference (``User.tweets``). Back-"
"references are exposed as :py:class:`SelectQuery` instances:"
msgstr ""

#: ../../peewee/querying.rst:370
msgid ""
"You can iterate over the ``user.tweets`` back-reference just like any "
"other :py:class:`SelectQuery`:"
msgstr ""

#: ../../peewee/querying.rst:382
msgid "Filtering records"
msgstr "レコードのフィルタリング"

#: ../../peewee/querying.rst:384
msgid ""
"You can filter for particular records using normal python operators. "
"Peewee supports a wide variety of :ref:`query operators <query-"
"operators>`."
msgstr ""

#: ../../peewee/querying.rst:400
msgid "You can also filter across joins:"
msgstr ""

#: ../../peewee/querying.rst:410
msgid ""
"If you want to express a complex query, use parentheses and python's "
"bitwise *or* and *and* operators:"
msgstr ""

#: ../../peewee/querying.rst:419
msgid ""
"Check out :ref:`the table of query operations <query-operators>` to see "
"what types of queries are possible."
msgstr ""

#: ../../peewee/querying.rst:423
msgid "A lot of fun things can go in the where clause of a query, such as:"
msgstr ""

#: ../../peewee/querying.rst:425
msgid "A field expression, e.g. ``User.username == 'Charlie'``"
msgstr ""

#: ../../peewee/querying.rst:426
msgid ""
"A function expression, e.g. ``fn.Lower(fn.Substr(User.username, 1, 1)) =="
" 'a'``"
msgstr ""

#: ../../peewee/querying.rst:427
msgid ""
"A comparison of one column to another, e.g. ``Employee.salary < "
"(Employee.tenure * 1000) + 40000``"
msgstr ""

#: ../../peewee/querying.rst:429
msgid ""
"You can also nest queries, for example tweets by users whose username "
"starts with \"a\":"
msgstr ""

#: ../../peewee/querying.rst:440
msgid "More query examples"
msgstr ""

#: ../../peewee/querying.rst:442
msgid "Get active users:"
msgstr ""

#: ../../peewee/querying.rst:448
msgid "Get users who are either staff or superusers:"
msgstr ""

#: ../../peewee/querying.rst:455
msgid "Get tweets by user named \"charlie\":"
msgstr ""

#: ../../peewee/querying.rst:461
msgid "Get tweets by staff or superusers (assumes FK relationship):"
msgstr ""

#: ../../peewee/querying.rst:468
msgid "Get tweets by staff or superusers using a subquery:"
msgstr ""

#: ../../peewee/querying.rst:477
msgid "Sorting records"
msgstr "レコードのソート"

#: ../../peewee/querying.rst:479
msgid "To return rows in order, use the :py:meth:`~SelectQuery.order_by` method:"
msgstr ""

#: ../../peewee/querying.rst:497
msgid "You can also use ``+`` and ``-`` prefix operators to indicate ordering:"
msgstr ""

#: ../../peewee/querying.rst:509
msgid ""
"You can also order across joins. Assuming you want to order tweets by the"
" username of the author, then by created_date:"
msgstr ""

#: ../../peewee/querying.rst:523
msgid ""
"When sorting on a calculated value, you can either include the necessary "
"SQL expressions, or reference the alias assigned to the value. Here are "
"two examples illustrating these methods:"
msgstr ""

#: ../../peewee/querying.rst:535
msgid ""
"You can order using the same COUNT expression used in the ``select`` "
"clause. In the example below we are ordering by the ``COUNT()`` of tweet "
"ids descending:"
msgstr ""

#: ../../peewee/querying.rst:545
msgid ""
"Alternatively, you can reference the alias assigned to the calculated "
"value in the ``select`` clause. This method has the benefit of being a "
"bit easier to read. Note that we are not referring to the named alias "
"directly, but are wrapping it using the :py:class:`SQL` helper:"
msgstr ""

#: ../../peewee/querying.rst:556
msgid "Getting random records"
msgstr "ランダムにレコードを取得"

#: ../../peewee/querying.rst:558
msgid ""
"Occasionally you may want to pull a random record from the database. You "
"can accomplish this by ordering by the *random* or *rand* function "
"(depending on your database):"
msgstr ""

#: ../../peewee/querying.rst:560
msgid "Postgresql and Sqlite use the *Random* function:"
msgstr ""

#: ../../peewee/querying.rst:567
msgid "MySQL uses *Rand*:"
msgstr ""

#: ../../peewee/querying.rst:575
msgid "Paginating records"
msgstr "レコードのページネーション"

#: ../../peewee/querying.rst:577
msgid ""
"The :py:meth:`~SelectQuery.paginate` method makes it easy to grab a "
"*page* or records. :py:meth:`~SelectQuery.paginate` takes two parameters,"
" ``page_number``, and ``items_per_page``."
msgstr ""

#: ../../peewee/querying.rst:580
msgid "Page numbers are 1-based, so the first page of results will be page 1."
msgstr ""

#: ../../peewee/querying.rst:598
msgid ""
"If you would like more granular control, you can always use "
":py:meth:`~SelectQuery.limit` and :py:meth:`~SelectQuery.offset`."
msgstr ""

#: ../../peewee/querying.rst:601
msgid "Counting records"
msgstr "レコードのカウント"

#: ../../peewee/querying.rst:603
msgid "You can count the number of rows in any select query:"
msgstr ""

#: ../../peewee/querying.rst:612
msgid ""
"In some cases it may be necessary to wrap your query and apply a count to"
" the rows of the inner query (such as when using *DISTINCT* or *GROUP "
"BY*). Peewee will usually do this automatically, but in some cases you "
"may need to manually call :py:meth:`~SelectQuery.wrapped_count` instead."
msgstr ""

#: ../../peewee/querying.rst:615
msgid "Aggregating records"
msgstr "レコードの集計"

#: ../../peewee/querying.rst:617
msgid ""
"Suppose you have some users and want to get a list of them along with the"
" count of tweets in each. The :py:meth:`~SelectQuery.annotate` method "
"provides a short-hand for creating these types of queries:"
msgstr ""

#: ../../peewee/querying.rst:623
msgid "The above query is equivalent to:"
msgstr ""

#: ../../peewee/querying.rst:632
msgid ""
"The resulting query will return *User* objects with all their normal "
"attributes plus an additional attribute *count* which will contain the "
"count of tweets for each user. By default it uses an inner join if the "
"foreign key is not nullable, which means users without tweets won't "
"appear in the list. To remedy this, manually specify the type of join to "
"include users with 0 tweets:"
msgstr ""

#: ../../peewee/querying.rst:642
msgid "You can also specify a custom aggregator, such as *MIN* or *MAX*:"
msgstr ""

#: ../../peewee/querying.rst:652
msgid ""
"Let's assume you have a tagging application and want to find tags that "
"have a certain number of related objects. For this example we'll use some"
" different models in a :ref:`many-to-many <manytomany>` configuration:"
msgstr ""

#: ../../peewee/querying.rst:666
msgid ""
"Now say we want to find tags that have at least 5 photos associated with "
"them:"
msgstr ""

#: ../../peewee/querying.rst:688
msgid "Suppose we want to grab the associated count and store it on the tag:"
msgstr ""

#: ../../peewee/querying.rst:700
msgid "Retrieving Scalar Values"
msgstr "スカラー値の取得"

#: ../../peewee/querying.rst:702
msgid ""
"You can retrieve scalar values by calling :py:meth:`Query.scalar`. For "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:709
msgid "You can retrieve multiple scalar values by passing ``as_tuple=True``:"
msgstr ""

#: ../../peewee/querying.rst:719
msgid "SQL Functions, Subqueries and \"Raw expressions\""
msgstr "SQL関数、サブクエリ、および \"生の式\""

#: ../../peewee/querying.rst:721
msgid ""
"Suppose you need to want to get a list of all users whose username begins"
" with *a*. There are a couple ways to do this, but one method might be to"
" use some SQL functions like *LOWER* and *SUBSTR*. To use arbitrary SQL "
"functions, use the special :py:func:`fn` object to construct queries:"
msgstr ""

#: ../../peewee/querying.rst:734
msgid ""
"There are times when you may want to simply pass in some arbitrary sql. "
"You can do this using the special :py:class:`SQL` class. One use-case is "
"when referencing an alias:"
msgstr ""

#: ../../peewee/querying.rst:745
msgid "There are two ways to execute hand-crafted SQL statements with peewee:"
msgstr ""

#: ../../peewee/querying.rst:747
msgid ":py:meth:`Database.execute_sql` for executing any type of query"
msgstr ""

#: ../../peewee/querying.rst:748
msgid ""
":py:class:`RawQuery` for executing ``SELECT`` queries and *returning "
"model instances*."
msgstr ""

#: ../../peewee/querying.rst:771
msgid "Security and SQL Injection"
msgstr "セキュリティとSQLインジェクション"

#: ../../peewee/querying.rst:773
msgid ""
"By default peewee will parameterize queries, so any parameters passed in "
"by the user will be escaped. The only exception to this rule is if you "
"are writing a raw SQL query or are passing in a ``SQL`` object which may "
"contain untrusted data. To mitigate this, ensure that any user-defined "
"data is passed in as a query parameter and not part of the actual SQL "
"query:"
msgstr ""

#: ../../peewee/querying.rst:790
#, python-format
msgid ""
"MySQL and Postgresql use ``'%s'`` to denote parameters. SQLite, on the "
"other hand, uses ``'?'``. Be sure to use the character appropriate to "
"your database. You can also find this parameter by checking "
":py:attr:`Database.interpolation`."
msgstr ""

#: ../../peewee/querying.rst:797
msgid ""
"peewee comes with basic support for SQL window functions, which can be "
"created by calling :py:meth:`fn.over` and passing in your partitioning or"
" ordering parameters."
msgstr ""

#: ../../peewee/querying.rst:819
msgid ""
"For general information on window functions, check out the `postgresql "
"docs <http://www.postgresql.org/docs/9.1/static/tutorial-window.html>`_."
msgstr ""

#: ../../peewee/querying.rst:822
msgid "Retrieving raw tuples / dictionaries"
msgstr "生のタプル/辞書の取得"

#: ../../peewee/querying.rst:824
msgid ""
"Sometimes you do not need the overhead of creating model instances and "
"simply want to iterate over the row tuples. To do this, call "
":py:meth:`SelectQuery.tuples` or :py:meth:`RawQuery.tuples`:"
msgstr ""

#: ../../peewee/querying.rst:834
msgid ""
"Similarly, you can return the rows from the cursor as dictionaries using "
":py:meth:`SelectQuery.dicts` or :py:meth:`RawQuery.dicts`:"
msgstr ""

#: ../../peewee/querying.rst:847
msgid "Returning Clause"
msgstr "Returing句"

#: ../../peewee/querying.rst:849
msgid ""
":py:class:`PostgresqlDatabase` supports a ``RETURNING`` clause on "
"``UPDATE``, ``INSERT`` and ``DELETE`` queries. Specifying a ``RETURNING``"
" clause allows you to iterate over the rows accessed by the query."
msgstr ""

#: ../../peewee/querying.rst:851
msgid ""
"For example, let's say you have an :py:class:`UpdateQuery` that "
"deactivates all user accounts whose registration has expired. After "
"deactivating them, you want to send each user an email letting them know "
"their account was deactivated. Rather than writing two queries, a "
"``SELECT`` and an ``UPDATE``, you can do this in a single ``UPDATE`` "
"query with a ``RETURNING`` clause:"
msgstr ""

#: ../../peewee/querying.rst:864
msgid ""
"The ``RETURNING`` clause is also available on :py:class:`InsertQuery` and"
" :py:class:`DeleteQuery`. When used with ``INSERT``, the newly-created "
"rows will be returned. When used with ``DELETE``, the deleted rows will "
"be returned."
msgstr ""

#: ../../peewee/querying.rst:866
msgid ""
"The only limitation of the ``RETURNING`` clause is that it can only "
"consist of columns from tables listed in the query's ``FROM`` clause. To "
"select all columns from a particular table, you can simply pass in the "
":py:class:`Model` class."
msgstr ""

#: ../../peewee/querying.rst:868
msgid "For more information, see:"
msgstr ""

#: ../../peewee/querying.rst:878
msgid "Query operators"
msgstr "クエリ演算子"

#: ../../peewee/querying.rst:880
msgid "The following types of comparisons are supported by peewee:"
msgstr ""

#: ../../peewee/querying.rst:883
msgid "Comparison"
msgstr ""

#: ../../peewee/querying.rst:885
msgid "``==``"
msgstr ""

#: ../../peewee/querying.rst:885
msgid "x equals y"
msgstr ""

#: ../../peewee/querying.rst:886
msgid "``<``"
msgstr ""

#: ../../peewee/querying.rst:886
msgid "x is less than y"
msgstr ""

#: ../../peewee/querying.rst:887
msgid "``<=``"
msgstr ""

#: ../../peewee/querying.rst:887
msgid "x is less than or equal to y"
msgstr ""

#: ../../peewee/querying.rst:888
msgid "``>``"
msgstr ""

#: ../../peewee/querying.rst:888
msgid "x is greater than y"
msgstr ""

#: ../../peewee/querying.rst:889
msgid "``>=``"
msgstr ""

#: ../../peewee/querying.rst:889
msgid "x is greater than or equal to y"
msgstr ""

#: ../../peewee/querying.rst:890
msgid "``!=``"
msgstr ""

#: ../../peewee/querying.rst:890
msgid "x is not equal to y"
msgstr ""

#: ../../peewee/querying.rst:891
msgid "``<<``"
msgstr ""

#: ../../peewee/querying.rst:891
msgid "x IN y, where y is a list or query"
msgstr ""

#: ../../peewee/querying.rst:892
msgid "``>>``"
msgstr ""

#: ../../peewee/querying.rst:892
msgid "x IS y, where y is None/NULL"
msgstr ""

#: ../../peewee/querying.rst:893
msgid "``%``"
msgstr ""

#: ../../peewee/querying.rst:893
msgid "x LIKE y where y may contain wildcards"
msgstr ""

#: ../../peewee/querying.rst:894
msgid "``**``"
msgstr ""

#: ../../peewee/querying.rst:894
msgid "x ILIKE y where y may contain wildcards"
msgstr ""

#: ../../peewee/querying.rst:895 ../../peewee/querying.rst:923
msgid "``~``"
msgstr ""

#: ../../peewee/querying.rst:895
msgid "Negation"
msgstr ""

#: ../../peewee/querying.rst:898
msgid ""
"Because I ran out of operators to override, there are some additional "
"query operations available as methods:"
msgstr ""

#: ../../peewee/querying.rst:901
msgid "Method"
msgstr ""

#: ../../peewee/querying.rst:903
msgid "``.contains(substr)``"
msgstr ""

#: ../../peewee/querying.rst:903
msgid "Wild-card search for substring."
msgstr ""

#: ../../peewee/querying.rst:904
msgid "``.startswith(prefix)``"
msgstr ""

#: ../../peewee/querying.rst:904
msgid "Search for values beginning with ``prefix``."
msgstr ""

#: ../../peewee/querying.rst:905
msgid "``.endswith(suffix)``"
msgstr ""

#: ../../peewee/querying.rst:905
msgid "Search for values ending with ``suffix``."
msgstr ""

#: ../../peewee/querying.rst:906
msgid "``.between(low, high)``"
msgstr ""

#: ../../peewee/querying.rst:906
msgid "Search for values between ``low`` and ``high``."
msgstr ""

#: ../../peewee/querying.rst:907
msgid "``.regexp(exp)``"
msgstr ""

#: ../../peewee/querying.rst:907
msgid "Regular expression match."
msgstr ""

#: ../../peewee/querying.rst:908
msgid "``.bin_and(value)``"
msgstr ""

#: ../../peewee/querying.rst:908
msgid "Binary AND."
msgstr ""

#: ../../peewee/querying.rst:909
msgid "``.bin_or(value)``"
msgstr ""

#: ../../peewee/querying.rst:909
msgid "Binary OR."
msgstr ""

#: ../../peewee/querying.rst:910
msgid "``.in_(value)``"
msgstr ""

#: ../../peewee/querying.rst:910
msgid "IN lookup (identical to ``<<``)."
msgstr ""

#: ../../peewee/querying.rst:911
msgid "``.not_in(value)``"
msgstr ""

#: ../../peewee/querying.rst:911
msgid "NOT IN lookup."
msgstr ""

#: ../../peewee/querying.rst:912
msgid "``.is_null(is_null)``"
msgstr ""

#: ../../peewee/querying.rst:912
msgid "IS NULL or IS NOT NULL. Accepts boolean param."
msgstr ""

#: ../../peewee/querying.rst:913
msgid "``.concat(other)``"
msgstr ""

#: ../../peewee/querying.rst:913
msgid "Concatenate two strings using ``||``."
msgstr ""

#: ../../peewee/querying.rst:916
msgid "To combine clauses using logical operators, use:"
msgstr ""

#: ../../peewee/querying.rst:919
msgid "Operator"
msgstr ""

#: ../../peewee/querying.rst:921
msgid "``&``"
msgstr ""

#: ../../peewee/querying.rst:921
msgid "AND"
msgstr ""

#: ../../peewee/querying.rst:921
msgid "``(User.is_active == True) & (User.is_admin == True)``"
msgstr ""

#: ../../peewee/querying.rst:922
msgid "``|`` (pipe)"
msgstr ""

#: ../../peewee/querying.rst:922
msgid "OR"
msgstr ""

#: ../../peewee/querying.rst:922
msgid "``(User.is_admin) | (User.is_superuser)``"
msgstr ""

#: ../../peewee/querying.rst:923
msgid "NOT (unary negation)"
msgstr ""

#: ../../peewee/querying.rst:923
msgid "``~(User.username << ['foo', 'bar', 'baz'])``"
msgstr ""

#: ../../peewee/querying.rst:926
msgid "Here is how you might use some of these query operators:"
msgstr ""

#: ../../peewee/querying.rst:942
msgid ""
"Here is how you might combine expressions. Comparisons can be arbitrarily"
" complex."
msgstr ""

#: ../../peewee/querying.rst:946
msgid ""
"Note that the actual comparisons are wrapped in parentheses. Python's "
"operator precedence necessitates that comparisons be wrapped in "
"parentheses."
msgstr ""

#: ../../peewee/querying.rst:972
msgid ""
"Although you may be tempted to use python's ``in``, ``and``, ``or`` and "
"``not`` operators in your query expressions, these **will not work.** The"
" return value of an ``in`` expression is always coerced to a boolean "
"value. Similarly, ``and``, ``or`` and ``not`` all treat their arguments "
"as boolean values and cannot be overloaded."
msgstr ""

#: ../../peewee/querying.rst:978
msgid "So just remember:"
msgstr ""

#: ../../peewee/querying.rst:980
msgid "Use ``<<`` instead of ``in``"
msgstr ""

#: ../../peewee/querying.rst:981
msgid "Use ``&`` instead of ``and``"
msgstr ""

#: ../../peewee/querying.rst:982
msgid "Use ``|`` instead of ``or``"
msgstr ""

#: ../../peewee/querying.rst:983
msgid "Use ``~`` instead of ``not``"
msgstr ""

#: ../../peewee/querying.rst:984
msgid ""
"Don't forget to wrap your comparisons in parentheses when using logical "
"operators."
msgstr ""

#: ../../peewee/querying.rst:987
msgid "For more examples, see the :ref:`expressions` section."
msgstr ""

#: ../../peewee/querying.rst:990
msgid "**LIKE and ILIKE with SQLite**"
msgstr ""

#: ../../peewee/querying.rst:992
msgid ""
"Because SQLite's ``LIKE`` operation is case-insensitive by default, "
"peewee will use the SQLite ``GLOB`` operation for case-sensitive "
"searches. The glob operation uses asterisks for wildcards as opposed to "
"the usual percent-sign. If you are using SQLite and want case-sensitive "
"partial string matching, remember to use asterisks for the wildcard."
msgstr ""

#: ../../peewee/querying.rst:999
msgid "Three valued logic"
msgstr "3つの論理"

#: ../../peewee/querying.rst:1001
msgid ""
"Because of the way SQL handles ``NULL``, there are some special "
"operations available for expressing:"
msgstr ""

#: ../../peewee/querying.rst:1003
msgid "``IS NULL``"
msgstr ""

#: ../../peewee/querying.rst:1004
msgid "``IS NOT NULL``"
msgstr ""

#: ../../peewee/querying.rst:1005
msgid "``IN``"
msgstr ""

#: ../../peewee/querying.rst:1006
msgid "``NOT IN``"
msgstr ""

#: ../../peewee/querying.rst:1008
msgid ""
"While it would be possible to use the ``IS NULL`` and ``IN`` operators "
"with the negation operator (``~``), sometimes to get the correct "
"semantics you will need to explicitly use ``IS NOT NULL`` and ``NOT IN``."
msgstr ""

#: ../../peewee/querying.rst:1010
msgid ""
"The simplest way to use ``IS NULL`` and ``IN`` is to use the operator "
"overloads:"
msgstr ""

#: ../../peewee/querying.rst:1021
msgid ""
"If you don't like operator overloads, you can call the Field methods "
"instead:"
msgstr ""

#: ../../peewee/querying.rst:1032
msgid ""
"To negate the above queries, you can use unary negation, but for the "
"correct semantics you may need to use the special ``IS NOT`` and ``NOT "
"IN`` operators:"
msgstr ""

#: ../../peewee/querying.rst:1053
msgid "Adding user-defined operators"
msgstr "ユーザー定義演算子の追加"

#: ../../peewee/querying.rst:1055
msgid ""
"Because I ran out of python operators to overload, there are some missing"
" operators in peewee, for instance `modulo "
"<https://github.com/coleifer/peewee/issues/177>`_. If you find that you "
"need to support an operator that is not in the table above, it is very "
"easy to add your own."
msgstr ""

#: ../../peewee/querying.rst:1057
msgid "Here is how you might add support for ``modulo`` in SQLite:"
msgstr ""

#: ../../peewee/querying.rst:1071
msgid "Now you can use these custom operators to build richer queries:"
msgstr ""

#: ../../peewee/querying.rst:1078
msgid ""
"For more examples check out the source to the "
"``playhouse.postgresql_ext`` module, as it contains numerous operators "
"specific to postgresql's hstore."
msgstr ""

#: ../../peewee/querying.rst:1083
msgid "Expressions"
msgstr "式"

#: ../../peewee/querying.rst:1085
msgid ""
"Peewee is designed to provide a simple, expressive, and pythonic way of "
"constructing SQL queries. This section will provide a quick overview of "
"some common types of expressions."
msgstr ""

#: ../../peewee/querying.rst:1087
msgid ""
"There are two primary types of objects that can be composed to create "
"expressions:"
msgstr ""

#: ../../peewee/querying.rst:1089
msgid ":py:class:`Field` instances"
msgstr ""

#: ../../peewee/querying.rst:1090
msgid "SQL aggregations and functions using :py:class:`fn`"
msgstr ""

#: ../../peewee/querying.rst:1092
msgid ""
"We will assume a simple \"User\" model with fields for username and other"
" things. It looks like this:"
msgstr ""

#: ../../peewee/querying.rst:1106
msgid "Comparisons use the :ref:`query-operators`:"
msgstr ""

#: ../../peewee/querying.rst:1116
msgid ""
"Comparisons can be combined using bitwise *and* and *or*.  Operator "
"precedence is controlled by python and comparisons can be nested to an "
"arbitrary depth:"
msgstr ""

#: ../../peewee/querying.rst:1126
msgid "Comparisons can be used with functions as well:"
msgstr ""

#: ../../peewee/querying.rst:1133
msgid ""
"We can do some fairly interesting things, as expressions can be compared "
"against other expressions.  Expressions also support arithmetic "
"operations:"
msgstr ""

#: ../../peewee/querying.rst:1142
msgid "Expressions allow us to do atomic updates:"
msgstr ""

#: ../../peewee/querying.rst:1149
msgid "Expressions can be used in all parts of a query, so experiment!"
msgstr ""

#: ../../peewee/querying.rst:1152
msgid "Foreign Keys"
msgstr "外部キー"

#: ../../peewee/querying.rst:1154
msgid ""
"Foreign keys are created using a special field class "
":py:class:`ForeignKeyField`. Each foreign key also creates a back-"
"reference on the related model using the specified *related_name*."
msgstr ""

#: ../../peewee/querying.rst:1157
msgid "Traversing foreign keys"
msgstr "外部キーのトラバース"

#: ../../peewee/querying.rst:1159
msgid ""
"Referring back to the :ref:`User and Tweet models <blog-models>`, note "
"that there is a :py:class:`ForeignKeyField` from *Tweet* to *User*. The "
"foreign key can be traversed, allowing you access to the associated user "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:1167
msgid ""
"Unless the *User* model was explicitly selected when retrieving the "
"*Tweet*, an additional query will be required to load the *User* data. To"
" learn how to avoid the extra query, see the :ref:`N+1 query "
"documentation <nplusone>`."
msgstr ""

#: ../../peewee/querying.rst:1169
msgid ""
"The reverse is also true, and we can iterate over the tweets associated "
"with a given *User* instance:"
msgstr ""

#: ../../peewee/querying.rst:1178
msgid ""
"Under the hood, the *tweets* attribute is just a :py:class:`SelectQuery` "
"with the *WHERE* clause pre-populated to point to the given *User* "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:1186
msgid "Joining tables"
msgstr "テーブルの結合"

#: ../../peewee/querying.rst:1188
msgid ""
"Use the :py:meth:`~Query.join` method to *JOIN* additional tables. When a"
" foreign key exists between the source model and the join model, you do "
"not need to specify any additional parameters:"
msgstr ""

#: ../../peewee/querying.rst:1194
msgid ""
"By default peewee will use an *INNER* join, but you can use *LEFT OUTER*,"
" *RIGHT OUTER*, *FULL*, or *CROSS* joins as well:"
msgstr ""

#: ../../peewee/querying.rst:1207
msgid "Multiple Foreign Keys to the Same Model"
msgstr ""

#: ../../peewee/querying.rst:1209
msgid ""
"When there are multiple foreign keys to the same model, it is good "
"practice to explicitly specify which field you are joining on."
msgstr ""

#: ../../peewee/querying.rst:1211
msgid ""
"Referring back to the :ref:`example app's models <example-app-models>`, "
"consider the *Relationship* model, which is used to denote when one user "
"follows another. Here is the model definition:"
msgstr ""

#: ../../peewee/querying.rst:1225
msgid ""
"Since there are two foreign keys to *User*, we should always specify "
"which field we are using in a join."
msgstr ""

#: ../../peewee/querying.rst:1227
msgid "For example, to determine which users I am following, I would write:"
msgstr ""

#: ../../peewee/querying.rst:1236
msgid ""
"On the other hand, if I wanted to determine which users are following me,"
" I would instead join on the *from_user* column and filter on the "
"relationship's *to_user*:"
msgstr ""

#: ../../peewee/querying.rst:1246
msgid "Joining on arbitrary fields"
msgstr ""

#: ../../peewee/querying.rst:1248
msgid ""
"If a foreign key does not exist between two tables you can still perform "
"a join, but you must manually specify the join predicate."
msgstr ""

#: ../../peewee/querying.rst:1250
msgid ""
"In the following example, there is no explicit foreign-key between *User*"
" and *ActivityLog*, but there is an implied relationship between the "
"*ActivityLog.object_id* field and *User.id*. Rather than joining on a "
"specific :py:class:`Field`, we will join using an :py:class:`Expression`."
msgstr ""

#: ../../peewee/querying.rst:1274
msgid ""
"By specifying an alias on the join condition, you can control the "
"attribute peewee will assign the joined instance to. In the previous "
"example, we used the following *join*:"
msgstr ""

#: ../../peewee/querying.rst:1280
msgid ""
"Then when iterating over the query, we were able to directly access the "
"joined *ActivityLog* without incurring an additional query:"
msgstr ""

#: ../../peewee/querying.rst:1288
msgid "Joining on Multiple Tables"
msgstr ""

#: ../../peewee/querying.rst:1290
msgid ""
"When calling :py:meth:`~Query.join`, peewee will use the *last joined "
"table* as the source table. For example:"
msgstr ""

#: ../../peewee/querying.rst:1296
msgid ""
"This query will result in a join from *User* to *Tweet*, and another join"
" from *Tweet* to *Comment*."
msgstr ""

#: ../../peewee/querying.rst:1298
msgid ""
"If you would like to join the same table twice, use the "
":py:meth:`~Query.switch` method:"
msgstr ""

#: ../../peewee/querying.rst:1308
msgid "Implementing Many to Many"
msgstr "多対多の実装"

#: ../../peewee/querying.rst:1310
msgid ""
"Peewee does not provide a *field* for many to many relationships the way "
"that django does -- this is because the field really is hiding an "
"intermediary table.  To implement many-to-many with peewee, you will "
"therefore create the intermediary table yourself and query through it:"
msgstr ""

#: ../../peewee/querying.rst:1324
msgid ""
"To query, let's say we want to find students who are enrolled in math "
"class:"
msgstr ""

#: ../../peewee/querying.rst:1336
msgid "To query what classes a given student is enrolled in:"
msgstr ""

#: ../../peewee/querying.rst:1349
msgid ""
"To efficiently iterate over a many-to-many relation, i.e., list all "
"students and their respective courses, we will query the *through* model "
"``StudentCourse`` and *precompute* the Student and Course:"
msgstr ""

#: ../../peewee/querying.rst:1360
msgid "To print a list of students and their courses you might do the following:"
msgstr ""

#: ../../peewee/querying.rst:1372
msgid ""
"Since we selected all fields from ``Student`` and ``Course`` in the "
"*select* clause of the query, these foreign key traversals are \"free\" "
"and we've done the whole iteration with just 1 query."
msgstr ""

#: ../../peewee/querying.rst:1375
msgid "ManyToManyField"
msgstr ""

#: ../../peewee/querying.rst:1377
msgid ""
"The :py:class:`ManyToManyField` provides a *field-like* API over many-to-"
"many fields. For all but the simplest many-to-many situations, you're "
"better off using the standard peewee APIs. But, if your models are very "
"simple and your querying needs are not very complex, you can get a big "
"boost by using :py:class:`ManyToManyField`. Check out the :ref:`extra-"
"fields` extension module for details."
msgstr ""

#: ../../peewee/querying.rst:1379
msgid "Modeling students and courses using :py:class:`ManyToManyField`:"
msgstr ""

#: ../../peewee/querying.rst:1434
msgid "For more examples, see:"
msgstr ""

#: ../../peewee/querying.rst:1436
msgid ":py:meth:`ManyToManyField.add`"
msgstr ""

#: ../../peewee/querying.rst:1437
msgid ":py:meth:`ManyToManyField.remove`"
msgstr ""

#: ../../peewee/querying.rst:1438
msgid ":py:meth:`ManyToManyField.clear`"
msgstr ""

#: ../../peewee/querying.rst:1439
msgid ":py:meth:`ManyToManyField.get_through_model`"
msgstr ""

#: ../../peewee/querying.rst:1443
msgid "Self-joins"
msgstr "自己結合"

#: ../../peewee/querying.rst:1445
msgid ""
"Peewee supports several methods for constructing queries containing a "
"self-join."
msgstr ""

#: ../../peewee/querying.rst:1448
msgid "Using model aliases"
msgstr ""

#: ../../peewee/querying.rst:1450
msgid ""
"To join on the same model (table) twice, it is necessary to create a "
"model alias to represent the second instance of the table in a query. "
"Consider the following model:"
msgstr ""

#: ../../peewee/querying.rst:1458
msgid ""
"What if we wanted to query all categories whose parent category is "
"*Electronics*. One way would be to perform a self-join:"
msgstr ""

#: ../../peewee/querying.rst:1468
msgid ""
"When performing a join that uses a :py:class:`ModelAlias`, it is "
"necessary to specify the join condition using the ``on`` keyword "
"argument. In this case we are joining the category with its parent "
"category."
msgstr ""

#: ../../peewee/querying.rst:1471
msgid "Using subqueries"
msgstr ""

#: ../../peewee/querying.rst:1473
msgid ""
"Another less common approach involves the use of subqueries. Here is "
"another way we might construct a query to get all the categories whose "
"parent category is *Electronics* using a subquery:"
msgstr ""

#: ../../peewee/querying.rst:1486
msgid "This will generate the following SQL query:"
msgstr ""

#: ../../peewee/querying.rst:1498
msgid ""
"To access the ``id`` value from the subquery, we use the ``.c`` magic "
"lookup which will generate the appropriate SQL expression:"
msgstr ""

#: ../../peewee/querying.rst:1506
msgid "Performance Techniques"
msgstr "パフォーマンステクニック"

#: ../../peewee/querying.rst:1508
msgid ""
"This section outlines some techniques for improving performance when "
"using peewee."
msgstr ""

#: ../../peewee/querying.rst:1513
msgid "Avoiding N+1 queries"
msgstr "N+1クエリを避ける"

#: ../../peewee/querying.rst:1515
msgid ""
"The term *N+1 queries* refers to a situation where an application "
"performs a query, then for each row of the result set, the application "
"performs at least one other query (another way to conceptualize this is "
"as a nested loop). In many cases, these *n* queries can be avoided "
"through the use of a SQL join or subquery. The database itself may do a "
"nested loop, but it will usually be more performant than doing *n* "
"queries in your application code, which involves latency communicating "
"with the database and may not take advantage of indices or other "
"optimizations employed by the database when joining or executing a "
"subquery."
msgstr ""

#: ../../peewee/querying.rst:1517
msgid ""
"Peewee provides several APIs for mitigating *N+1* query behavior. "
"Recollecting the models used throughout this document, *User* and "
"*Tweet*, this section will try to outline some common *N+1* scenarios, "
"and how peewee can help you avoid them."
msgstr ""

#: ../../peewee/querying.rst:1520
msgid ""
"In some cases, N+1 queries will not result in a significant or measurable"
" performance hit. It all depends on the data you are querying, the "
"database you are using, and the latency involved in executing queries and"
" retrieving results. As always when making optimizations, profile before "
"and after to ensure the changes do what you expect them to."
msgstr ""

#: ../../peewee/querying.rst:1523
msgid "List recent tweets"
msgstr ""

#: ../../peewee/querying.rst:1525
msgid ""
"The twitter timeline displays a list of tweets from multiple users. In "
"addition to the tweet's content, the username of the tweet's author is "
"also displayed. The N+1 scenario here would be:"
msgstr ""

#: ../../peewee/querying.rst:1527
msgid "Fetch the 10 most recent tweets."
msgstr ""

#: ../../peewee/querying.rst:1528
msgid "For each tweet, select the author (10 queries)."
msgstr ""

#: ../../peewee/querying.rst:1530
msgid ""
"By selecting both tables and using a *join*, peewee makes it possible to "
"accomplish this in a single query:"
msgstr ""

#: ../../peewee/querying.rst:1543
msgid ""
"Without the join, accessing ``tweet.user.username`` would trigger a query"
" to resolve the foreign key ``tweet.user`` and retrieve the associated "
"user. But since we have selected and joined on ``User``, peewee will "
"automatically resolve the foreign-key for us."
msgstr ""

#: ../../peewee/querying.rst:1546
msgid "List users and all their tweets"
msgstr ""

#: ../../peewee/querying.rst:1548
msgid ""
"Let's say you want to build a page that shows several users and all of "
"their tweets. The N+1 scenario would be:"
msgstr ""

#: ../../peewee/querying.rst:1550
msgid "Fetch some users."
msgstr ""

#: ../../peewee/querying.rst:1551
msgid "For each user, fetch their tweets."
msgstr ""

#: ../../peewee/querying.rst:1553
msgid ""
"This situation is similar to the previous example, but there is one "
"important difference: when we selected tweets, they only have a single "
"associated user, so we could directly assign the foreign key. The reverse"
" is not true, however, as one user may have any number of tweets (or none"
" at all)."
msgstr ""

#: ../../peewee/querying.rst:1555
msgid ""
"Peewee provides two approaches to avoiding *O(n)* queries in this "
"situation. We can either:"
msgstr ""

#: ../../peewee/querying.rst:1557
msgid ""
"Fetch users first, then fetch all the tweets associated with those users."
" Once peewee has the big list of tweets, it will assign them out, "
"matching them with the appropriate user. This method is usually faster "
"but will involve a query for each table being selected."
msgstr ""

#: ../../peewee/querying.rst:1558
msgid ""
"Fetch both users and tweets in a single query. User data will be "
"duplicated, so peewee will de-dupe it and aggregate the tweets as it "
"iterates through the result set. This method involves a lot of data being"
" transferred over the wire and a lot of logic in Python to de-duplicate "
"rows."
msgstr ""

#: ../../peewee/querying.rst:1560
msgid ""
"Each solution has its place and, depending on the size and shape of the "
"data you are querying, one may be more performant than the other."
msgstr ""

#: ../../peewee/querying.rst:1565
msgid "Using prefetch"
msgstr ""

#: ../../peewee/querying.rst:1567
msgid ""
"peewee supports pre-fetching related data using sub-queries. This method "
"requires the use of a special API, :py:func:`prefetch`. Pre-fetch, as its"
" name indicates, will eagerly load the appropriate tweets for the given "
"users using subqueries. This means instead of *O(n)* queries for *n* "
"rows, we will do *O(k)* queries for *k* tables."
msgstr ""

#: ../../peewee/querying.rst:1569
msgid ""
"Here is an example of how we might fetch several users and any tweets "
"they created within the past week."
msgstr ""

#: ../../peewee/querying.rst:1590
msgid ""
"Note that neither the ``User`` query, nor the ``Tweet`` query contained a"
" JOIN clause. When using :py:func:`prefetch` you do not need to specify "
"the join."
msgstr ""

#: ../../peewee/querying.rst:1594
msgid ""
":py:func:`prefetch` can be used to query an arbitrary number of tables. "
"Check the API documentation for more examples."
msgstr ""

#: ../../peewee/querying.rst:1596
msgid "Some things to consider when using :py:func:`prefetch`:"
msgstr ""

#: ../../peewee/querying.rst:1598
msgid "Foreign keys must exist between the models being prefetched."
msgstr ""

#: ../../peewee/querying.rst:1599
msgid ""
"In general it is more performant than "
":py:meth:`~SelectQuery.aggregate_rows`."
msgstr ""

#: ../../peewee/querying.rst:1600
msgid ""
"Typically a lot less data is transferred over the wire since data is not "
"duplicated."
msgstr ""

#: ../../peewee/querying.rst:1601
msgid "There is less Python overhead since we don't have to de-dupe things."
msgstr ""

#: ../../peewee/querying.rst:1602
msgid ""
"`LIMIT` works as you'd expect on the outer-most query, but may be "
"difficult to implement correctly if trying to limit the size of the sub-"
"selects."
msgstr ""

#: ../../peewee/querying.rst:1607
msgid "Using aggregate_rows"
msgstr ""

#: ../../peewee/querying.rst:1609
msgid ""
"The :py:meth:`~SelectQuery.aggregate_rows` approach selects all data in "
"one go and de-dupes things in-memory. Like :py:func:`prefetch`, it can "
"work with arbitrarily complex queries. To use this feature We will use a "
"special flag, :py:meth:`~SelectQuery.aggregate_rows`, when creating our "
"query. This method tells peewee to de-duplicate any rows that, due to the"
" structure of the JOINs, may be duplicated."
msgstr ""

#: ../../peewee/querying.rst:1612
msgid ""
"Because there is a lot of computation involved in de-duping data, it is "
"possible that for some queries :py:meth:`~SelectQuery.aggregate_rows` "
"will be **significantly less performant** than using :py:func:`prefetch` "
"(described in the previous section) or even issuing *O(n)* simple "
"queries! Profile your code if you're not sure."
msgstr ""

#: ../../peewee/querying.rst:1627
msgid ""
"Ordinarily, ``user.tweets`` would be a :py:class:`SelectQuery` and "
"iterating over it would trigger an additional query. By using "
":py:meth:`~SelectQuery.aggregate_rows`, though, ``user.tweets`` is a "
"Python ``list`` and no additional query occurs."
msgstr ""

#: ../../peewee/querying.rst:1630
msgid ""
"We used a *LEFT OUTER* join to ensure that users with zero tweets would "
"also be included in the result set."
msgstr ""

#: ../../peewee/querying.rst:1632
msgid ""
"Below is an example of how we might fetch several users and any tweets "
"they created within the past week. Because we are filtering the tweets "
"and the user may not have any tweets, we need our *WHERE* clause to allow"
" *NULL* tweet IDs."
msgstr ""

#: ../../peewee/querying.rst:1652
msgid "Some things to consider when using :py:meth:`~SelectQuery.aggregate_rows`:"
msgstr ""

#: ../../peewee/querying.rst:1654
msgid ""
"You must specify an ordering for each table that is joined on so the rows"
" can be aggregated correctly, sort of similar to `itertools.groupby "
"<https://docs.python.org/2/library/itertools.html#itertools.groupby>`_."
msgstr ""

#: ../../peewee/querying.rst:1655
msgid ""
"Do not mix calls to :py:meth:`~SelectQuery.aggregate_rows` with ``LIMIT``"
" or ``OFFSET`` clauses, or with :py:meth:`~SelectQuery.get` (which "
"applies a ``LIMIT 1`` SQL clause). Since the aggregate result set may "
"contain more than one item due to rows being duplicated, limits can lead "
"to incorrect behavior. Imagine you have three users, each of whom has 10 "
"tweets. If you run a query with a ``LIMIT 5``, then you will only receive"
" the first user and their first 5 tweets."
msgstr ""

#: ../../peewee/querying.rst:1656
msgid ""
"In general the Python overhead of de-duplicating data can make this "
"method less performant than :py:func:`prefetch`, and sometimes even less "
"performan than simply issuing *O(n)* simple queries! When in doubt "
"profile."
msgstr ""

#: ../../peewee/querying.rst:1657
msgid ""
"Because every column from every table is included in each row tuple "
"returned by the cursor, this approach can use a lot more bandwidth than "
":py:func:`prefetch`."
msgstr ""

#: ../../peewee/querying.rst:1660
msgid "Iterating over lots of rows"
msgstr "たくさんの行を繰り返す"

#: ../../peewee/querying.rst:1662
msgid ""
"By default peewee will cache the rows returned when iterating of a "
":py:class:`SelectQuery`. This is an optimization to allow multiple "
"iterations as well as indexing and slicing without causing additional "
"queries. This caching can be problematic, however, when you plan to "
"iterate over a large number of rows."
msgstr ""

#: ../../peewee/querying.rst:1664
msgid ""
"To reduce the amount of memory used by peewee when iterating over a "
"query, use the :py:meth:`~SelectQuery.iterator` method. This method "
"allows you to iterate without caching each model returned, using much "
"less memory when iterating over large result sets."
msgstr ""

#: ../../peewee/querying.rst:1678
msgid ""
"For simple queries you can see further speed improvements by using the "
":py:meth:`~SelectQuery.naive` method. This method speeds up the "
"construction of peewee model instances from raw cursor data. See the "
":py:meth:`~SelectQuery.naive` documentation for more details on this "
"optimization."
msgstr ""

#: ../../peewee/querying.rst:1685
msgid ""
"You can also see performance improvements by using the "
":py:meth:`~SelectQuery.dicts` and :py:meth:`~SelectQuery.tuples` methods."
msgstr ""

#: ../../peewee/querying.rst:1687
msgid ""
"When iterating over a large number of rows that contain columns from "
"multiple tables, peewee will reconstruct the model graph for each row "
"returned. This operation can be slow for complex graphs. To speed up "
"model creation, you can:"
msgstr ""

#: ../../peewee/querying.rst:1689
msgid ""
"Call :py:meth:`~SelectQuery.naive`, which will not construct a graph and "
"simply patch all attributes from the row directly onto a model instance."
msgstr ""

#: ../../peewee/querying.rst:1690
msgid "Use :py:meth:`~SelectQuery.dicts` or :py:meth:`~SelectQuery.tuples`."
msgstr ""

#: ../../peewee/querying.rst:1693
msgid "Speeding up Bulk Inserts"
msgstr "バルクインサートの高速化"

#: ../../peewee/querying.rst:1695
msgid ""
"See the :ref:`bulk_inserts` section for details on speeding up bulk "
"insert operations."
msgstr ""

#: ../../peewee/quickstart.rst:4
msgid "Quickstart"
msgstr "クイックスタート"

#: ../../peewee/quickstart.rst:6
msgid ""
"This document presents a brief, high-level overview of Peewee's primary "
"features. This guide will cover:"
msgstr "このドキュメントでは、Peeweeの主な機能のハイレベルな概要を簡単に説明します。"

#: ../../peewee/quickstart.rst:8
msgid ":ref:`model-definition`"
msgstr ""

#: ../../peewee/quickstart.rst:9
msgid ":ref:`storing-data`"
msgstr ""

#: ../../peewee/quickstart.rst:10
msgid ":ref:`retrieving-data`"
msgstr ""

#: ../../peewee/quickstart.rst:13
msgid ""
"If you'd like something a bit more meaty, there is a thorough tutorial on"
" :ref:`creating a \"twitter\"-style web app <example-app>` using peewee "
"and the Flask framework."
msgstr ""
"何かもう少し欲しい方は、peeweeとFlaskフレームワークを使った :ref:`creating a \"twitter\"-style "
"web app <example-app>` というチュートリアルがあります。"

#: ../../peewee/quickstart.rst:17
msgid ""
"I **strongly** recommend opening an interactive shell session and running"
" the code. That way you can get a feel for typing in queries."
msgstr ""

#: ../../peewee/quickstart.rst:22
msgid "Model Definition"
msgstr "モデル定義"

#: ../../peewee/quickstart.rst:24
msgid "Model classes, fields and model instances all map to database concepts:"
msgstr ""

#: ../../peewee/quickstart.rst:34
msgid ""
"When starting a project with peewee, it's typically best to begin with "
"your data model, by defining one or more :py:class:`Model` classes:"
msgstr ""

#: ../../peewee/quickstart.rst:51
msgid ""
"Note that we named our model ``Person`` instead of ``People``. This is a "
"convention you should follow -- even though the table will contain "
"multiple people, we always name the class using the singular form."
msgstr ""

#: ../../peewee/quickstart.rst:53
msgid ""
"There are lots of :ref:`field types <fields>` suitable for storing "
"various types of data. Peewee handles converting between *pythonic* "
"values those used by the database, so you can use Python types in your "
"code without having to worry."
msgstr ""

#: ../../peewee/quickstart.rst:55
msgid ""
"Things get interesting when we set up relationships between models using "
"`foreign keys (wikipedia) <http://en.wikipedia.org/wiki/Foreign_key>`_. "
"This is easy to do with peewee:"
msgstr ""

#: ../../peewee/quickstart.rst:67
msgid ""
"Now that we have our models, let's connect to the database. Although it's"
" not necessary to open the connection explicitly, it is good practice "
"since it will reveal any errors with your database connection "
"immediately, as opposed to some arbitrary time later when the first query"
" is executed. It is also good to close the connection when you are done "
"-- for instance, a web app might open a connection when it receives a "
"request, and close the connection when it sends the response."
msgstr ""

#: ../../peewee/quickstart.rst:73
msgid ""
"We'll begin by creating the tables in the database that will store our "
"data. This will create the tables with the appropriate columns, indexes, "
"sequences, and foreign key constraints:"
msgstr ""

#: ../../peewee/quickstart.rst:84
msgid ""
"Let's begin by populating the database with some people. We will use the "
":py:meth:`~Model.save` and :py:meth:`~Model.create` methods to add and "
"update people's records."
msgstr ""

#: ../../peewee/quickstart.rst:93
msgid ""
"When you call :py:meth:`~Model.save`, the number of rows modified is "
"returned."
msgstr ""

#: ../../peewee/quickstart.rst:95
msgid ""
"You can also add a person by calling the :py:meth:`~Model.create` method,"
" which returns a model instance:"
msgstr ""

#: ../../peewee/quickstart.rst:102
msgid ""
"To update a row, modify the model instance and call "
":py:meth:`~Model.save` to persist the changes. Here we will change "
"Grandma's name and then save the changes in the database:"
msgstr ""

#: ../../peewee/quickstart.rst:110
msgid ""
"Now we have stored 3 people in the database. Let's give them some pets. "
"Grandma doesn't like animals in the house, so she won't have any, but "
"Herb is an animal lover:"
msgstr ""

#: ../../peewee/quickstart.rst:119
msgid ""
"After a long full life, Mittens sickens and dies. We need to remove him "
"from the database:"
msgstr ""

#: ../../peewee/quickstart.rst:126
msgid ""
"The return value of :py:meth:`~Model.delete_instance` is the number of "
"rows removed from the database."
msgstr ""

#: ../../peewee/quickstart.rst:128
msgid ""
"Uncle Bob decides that too many animals have been dying at Herb's house, "
"so he adopts Fido:"
msgstr ""

#: ../../peewee/quickstart.rst:139
msgid "Retrieving Data"
msgstr "データの取得"

#: ../../peewee/quickstart.rst:141
msgid ""
"The real strength of our database is in how it allows us to retrieve data"
" through *queries*. Relational databases are excellent for making ad-hoc "
"queries."
msgstr ""

#: ../../peewee/quickstart.rst:144
msgid "Getting single records"
msgstr ""

#: ../../peewee/quickstart.rst:146
msgid ""
"Let's retrieve Grandma's record from the database. To get a single record"
" from the database, use :py:meth:`SelectQuery.get`:"
msgstr ""

#: ../../peewee/quickstart.rst:152
msgid "We can also use the equivalent shorthand :py:meth:`Model.get`:"
msgstr ""

#: ../../peewee/quickstart.rst:159
msgid "Lists of records"
msgstr ""

#: ../../peewee/quickstart.rst:161
msgid "Let's list all the people in the database:"
msgstr ""

#: ../../peewee/quickstart.rst:172
msgid "Let's list all the cats and their owner's name:"
msgstr ""

#: ../../peewee/quickstart.rst:183
msgid ""
"There is a big problem with the previous query: because we are accessing "
"``pet.owner.name`` and we did not select this value in our original "
"query, peewee will have to perform an additional query to retrieve the "
"pet's owner. This behavior is referred to as :ref:`N+1 <nplusone>` and it"
" should generally be avoided."
msgstr ""

#: ../../peewee/quickstart.rst:185
msgid ""
"We can avoid the extra queries by selecting both *Pet* and *Person*, and "
"adding a *join*."
msgstr ""

#: ../../peewee/quickstart.rst:199
msgid "Let's get all the pets owned by Bob:"
msgstr ""

#: ../../peewee/quickstart.rst:209
msgid ""
"We can do another cool thing here to get bob's pets. Since we already "
"have an object to represent Bob, we can do this instead:"
msgstr ""

#: ../../peewee/quickstart.rst:216
msgid ""
"Let's make sure these are sorted alphabetically by adding an "
":py:meth:`~SelectQuery.order_by` clause:"
msgstr ""

#: ../../peewee/quickstart.rst:226
msgid "Let's list all the people now, youngest to oldest:"
msgstr ""

#: ../../peewee/quickstart.rst:237
msgid "Now let's list all the people *and* some info about their pets:"
msgstr ""

#: ../../peewee/quickstart.rst:253
msgid ""
"Once again we've run into a classic example of :ref:`N+1 <nplusone>` "
"query behavior. We can avoid this by performing a *JOIN* and aggregating "
"the records:"
msgstr ""

#: ../../peewee/quickstart.rst:275
msgid ""
"Even though we created the subquery separately, **only one** query is "
"actually executed."
msgstr ""

#: ../../peewee/quickstart.rst:277
msgid ""
"Finally, let's do a complicated one. Let's get all the people whose "
"birthday was either:"
msgstr ""

#: ../../peewee/quickstart.rst:280
msgid "before 1940 (grandma)"
msgstr ""

#: ../../peewee/quickstart.rst:281
msgid "after 1959 (bob)"
msgstr ""

#: ../../peewee/quickstart.rst:297
msgid "Now let's do the opposite. People whose birthday is between 1940 and 1960:"
msgstr ""

#: ../../peewee/quickstart.rst:310
msgid ""
"One last query. This will use a SQL function to find all people whose "
"names start with either an upper or lower-case *G*:"
msgstr ""

#: ../../peewee/quickstart.rst:320
msgid "We're done with our database, let's close the connection:"
msgstr ""

#: ../../peewee/quickstart.rst:326
msgid "This is just the basics! You can make your queries as complex as you like."
msgstr ""

#: ../../peewee/quickstart.rst:328
msgid "All the other SQL clauses are available as well, such as:"
msgstr ""

#: ../../peewee/quickstart.rst:330
msgid ":py:meth:`~SelectQuery.group_by`"
msgstr ""

#: ../../peewee/quickstart.rst:331
msgid ":py:meth:`~SelectQuery.having`"
msgstr ""

#: ../../peewee/quickstart.rst:332
msgid ":py:meth:`~SelectQuery.limit` and :py:meth:`~SelectQuery.offset`"
msgstr ""

#: ../../peewee/quickstart.rst:334
msgid "Check the documentation on :ref:`querying` for more info."
msgstr ""

#: ../../peewee/quickstart.rst:337
msgid "Working with existing databases"
msgstr "既存データベースの操作"

#: ../../peewee/quickstart.rst:339
msgid ""
"If you already have a database, you can autogenerate peewee models using "
":ref:`pwiz`. For instance, if I have a postgresql database named "
"*charles_blog*, I might run:"
msgstr ""

#: ../../peewee/quickstart.rst:346
msgid "What next?"
msgstr "次は何？"

#: ../../peewee/quickstart.rst:348
msgid ""
"That's it for the quickstart. If you want to look at a full web-app, "
"check out the :ref:`example-app`."
msgstr ""

#: ../../peewee/transactions.rst:6
msgid ""
"Peewee provides several interfaces for working with transactions. The "
"most general is the :py:meth:`Database.atomic` method, which also "
"supports nested transactions. :py:meth:`~Database.atomic` blocks will be "
"run in a transaction or savepoint, depending on the level of nesting."
msgstr ""

#: ../../peewee/transactions.rst:8
msgid ""
"If an exception occurs in a wrapped block, the current "
"transaction/savepoint will be rolled back. Otherwise the statements will "
"be committed at the end of the wrapped block."
msgstr ""

#: ../../peewee/transactions.rst:11
msgid ""
"While inside a block wrapped by the :py:meth:`~Database.atomic` context "
"manager, you can explicitly rollback or commit at any point by calling "
":py:meth:`Transaction.rollback` or :py:meth:`Transaction.commit`. When "
"you do this inside a wrapped block of code, a new transaction will be "
"started automatically."
msgstr ""

#: ../../peewee/transactions.rst:17
msgid "Consider this code:"
msgstr ""

#: ../../peewee/transactions.rst:31
msgid ""
"If the ``ErrorSavingData`` exception gets raised, we call rollback, but "
"because we are not using the ``~Database.atomic`` context manager, **no "
"new transaction is begun**. The call to ``commit()`` will fail because no"
" transaction is active!"
msgstr ""

#: ../../peewee/transactions.rst:36
msgid "On the other hand, consider this:"
msgstr ""

#: ../../peewee/transactions.rst:56
msgid ""
":py:meth:`~Database.atomic` can be used as either a **context manager** "
"or a **decorator**."
msgstr ""

#: ../../peewee/transactions.rst:59
msgid "Context manager"
msgstr "コンテキストマネージャー"

#: ../../peewee/transactions.rst:61
msgid "Using ``atomic`` as context manager:"
msgstr ""

#: ../../peewee/transactions.rst:84
msgid ""
"You can use the ``atomic`` method to perform *get or create* operations "
"as well:"
msgstr ""

#: ../../peewee/transactions.rst:96
msgid "Decorator"
msgstr "デコレータ"

#: ../../peewee/transactions.rst:98
msgid "Using ``atomic`` as a decorator:"
msgstr ""

#: ../../peewee/transactions.rst:111
msgid "Nesting Transactions"
msgstr "トランザクションのネスト"

#: ../../peewee/transactions.rst:113
msgid ""
":py:meth:`~Database.atomic` provides transparent nesting of transactions."
" When using :py:meth:`~Database.atomic`, the outer-most call will be "
"wrapped in a transaction, and any nested calls will use savepoints."
msgstr ""

#: ../../peewee/transactions.rst:123
msgid ""
"Peewee supports nested transactions through the use of savepoints (for "
"more information, see :py:meth:`~Database.savepoint`)."
msgstr ""

#: ../../peewee/transactions.rst:126
msgid "Explicit transaction"
msgstr "明示的なトランザクション"

#: ../../peewee/transactions.rst:128
msgid ""
"If you wish to explicitly run code in a transaction, you can use "
":py:meth:`~Database.transaction`. Like :py:meth:`~Database.atomic`, "
":py:meth:`~Database.transaction` can be used as a context manager or as a"
" decorator."
msgstr ""

#: ../../peewee/transactions.rst:130
msgid ""
"If an exception occurs in a wrapped block, the transaction will be rolled"
" back. Otherwise the statements will be committed at the end of the "
"wrapped block."
msgstr ""

#: ../../peewee/transactions.rst:140
msgid ""
"Transactions can be explicitly committed or rolled-back within the "
"wrapped block. When this happens, a new transaction will be started."
msgstr ""

#: ../../peewee/transactions.rst:162
msgid ""
"If you attempt to nest transactions with peewee using the "
":py:meth:`~Database.transaction` context manager, only the outer-most "
"transaction will be used. However if an exception occurs in a nested "
"block, this can lead to unpredictable behavior, so it is strongly "
"recommended that you use :py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/transactions.rst:165
msgid "Explicit Savepoints"
msgstr ""

#: ../../peewee/transactions.rst:167
msgid ""
"Just as you can explicitly create transactions, you can also explicitly "
"create savepoints using the :py:meth:`~Database.savepoint` method. "
"Savepoints must occur within a transaction, but can be nested arbitrarily"
" deep."
msgstr ""

#: ../../peewee/transactions.rst:179
msgid ""
"If you manually commit or roll back a savepoint, a new savepoint **will "
"not** automatically be created. This differs from the behavior of "
":py:class:`transaction`, which will automatically open a new transaction "
"after manual commit/rollback."
msgstr ""

#: ../../peewee/transactions.rst:182
msgid "Autocommit Mode"
msgstr "自動コミットモード"

#: ../../peewee/transactions.rst:184
msgid ""
"By default, databases are initialized with ``autocommit=True``, you can "
"turn this on and off at runtime if you like. If you choose to disable "
"autocommit, then you must explicitly call :py:meth:`Database.begin` to "
"begin a transaction, and commit or roll back."
msgstr ""

#: ../../peewee/transactions.rst:186
msgid ""
"The behavior below is roughly the same as the context manager and "
"decorator:"
msgstr ""

#: ../../peewee/transactions.rst:206
msgid ""
"If you would like to manually control *every* transaction, simply turn "
"autocommit off when instantiating your database:"
msgstr ""

#~ msgid "Field name to value for attempting to create a new instance."
#~ msgstr ""

#~ msgid ""
#~ "This function attempts to create a "
#~ "model instance based on the provided "
#~ "kwargs. If an ``IntegrityError`` occurs "
#~ "indicating the violation of a "
#~ "constraint, then Peewee will return the"
#~ " model matching the filters."
#~ msgstr ""

#~ msgid ""
#~ "Peewee will not attempt to match "
#~ "*all* the kwargs when an "
#~ "``IntegrityError`` occurs. Rather, only "
#~ "primary key fields or fields that "
#~ "have a unique constraint will be "
#~ "used to retrieve the matching instance."
#~ msgstr ""

#~ msgid ""
#~ "Use care when calling ``create_or_get`` "
#~ "with ``autocommit=False``, as the "
#~ "``create_or_get()`` method will call "
#~ ":py:meth:`Database.atomic` to create either a"
#~ " transaction or savepoint."
#~ msgstr ""

#~ msgid ""
#~ "The parent class from which all "
#~ "other query classes are drived. While"
#~ " you will not deal with "
#~ ":py:class:`Query` directly in your code, "
#~ "it implements some methods that are "
#~ "common across all query types."
#~ msgstr ""

#~ msgid ""
#~ "allows the type of ``JOIN`` used "
#~ "to be specified explicitly, one of "
#~ "``JOIN.INNER``, ``JOIN.LEFT_OUTER``, ``JOIN.FULL``"
#~ msgstr ""

#~ msgid ""
#~ "A :py:class:`Node` instance used to join"
#~ " the two queries, for example "
#~ "``SQL('UNION')``."
#~ msgstr ""

#~ msgid ""
#~ "Initiate a new transaction.  By default"
#~ " **not** implemented as this is not"
#~ " part of the DB-API 2.0, but"
#~ " provided for API compatibility."
#~ msgstr ""

#~ msgid ""
#~ "When a new user wants to join "
#~ "the site we need to make sure "
#~ "the username is available, and if "
#~ "so, create a new *User* record. "
#~ "Looking at the *join()* view, we "
#~ "can that our application attempts to "
#~ "create the User using :py:meth:`Model.create`."
#~ " We defined the *User.username* field "
#~ "with a unique constraint, so if "
#~ "the username is taken the database "
#~ "will raise an ``IntegrityError``."
#~ msgstr ""

#~ msgid ""
#~ "``default = None`` -- any value to"
#~ " use as a default for uninitialized"
#~ " models"
#~ msgstr ""

#~ msgid ""
#~ "When using the ``default`` parameter, "
#~ "the values are set by Peewee "
#~ "rather than being a part of the"
#~ " actual table and column definition."
#~ msgstr ""

#~ msgid ""
#~ "Peewee comes with numerous extrension "
#~ "modules which are collected under the"
#~ " ``playhouse`` namespace. Despite the silly"
#~ " name, there are some very useful "
#~ "extensions, particularly those that expose "
#~ "vendor-specific database features like "
#~ "the :ref:`sqlite_ext` and :ref:`postgres_ext` "
#~ "extensions."
#~ msgstr ""

#~ msgid ""
#~ "A list of 2-tuples containing ``PRAGMA``"
#~ " settings to configure on a per-"
#~ "connection basis."
#~ msgstr ""

#~ msgid ""
#~ "With the ``granular_transaction`` helper, you"
#~ " can specify the isolation level for"
#~ " an individual transaction.  The valid "
#~ "options are:"
#~ msgstr ""

#~ msgid ""
#~ "Create a model for your heirarchical "
#~ "data. The only requirement here is "
#~ "that the model have an integer "
#~ "primary key and a self-referential "
#~ "foreign key. Any additional fields are"
#~ " fine."
#~ msgstr ""

#~ msgid ""
#~ "Functions just like the "
#~ ":py:meth:`Database.transaction` context manager, but"
#~ " accepts an additional parameter specifying"
#~ " the type of lock to use."
#~ msgstr ""

#~ msgid "type of lock to use when opening a new transaction"
#~ msgstr ""

#~ msgid ""
#~ "``AESEncryptedField`` encrypts its contents "
#~ "before storing them in the database."
#~ msgstr ""

#~ msgid "Encryption key."
#~ msgstr ""

#~ msgid ""
#~ "This field requires `pycrypto "
#~ "<https://www.dlitz.net/software/pycrypto/>`_, which can"
#~ " be installed by running ``pip "
#~ "install pycrypto``."
#~ msgstr ""

#~ msgid "a ``list`` of :py:class:`Model` classes to use with the ``db``"
#~ msgstr ""

#~ msgid "Database wrapper"
#~ msgstr ""

#~ msgid ""
#~ "The :py:class:`FlaskDB` class provides a "
#~ "convenient way to configure a peewee "
#~ ":py:class:`Database` instance using Flask app"
#~ " configuration. The :py:class:`FlaskDB` wrapper"
#~ " will also automatically set up "
#~ "request setup and teardown handlers to"
#~ " ensure your connections are managed "
#~ "correctly."
#~ msgstr ""

#~ msgid ""
#~ "The underlying peewee database can be"
#~ " accessed using the ``FlaskDB.database`` "
#~ "attribute."
#~ msgstr ""

#~ msgid ""
#~ "If you prefer, you can also pass"
#~ " the database value directly into the"
#~ " ``FlaskDB`` object:"
#~ msgstr ""

#~ msgid ""
#~ "While the above examples show using "
#~ "a database URL, for more advanced "
#~ "usages you can specify a dictionary "
#~ "of configuration options or simply pass"
#~ " in a peewee :py:class:`Database` instance:"
#~ msgstr ""

#~ msgid "Peewee has two methods for performing \"get/create\" type operations:"
#~ msgstr ""

#~ msgid ""
#~ ":py:meth:`Model.create_or_get`, which will attempt"
#~ " to create a new row. If an "
#~ "``IntegrityError`` occurs indicating the "
#~ "violation of a constraint, then Peewee"
#~ " will attempt to get the object "
#~ "instead."
#~ msgstr ""

#~ msgid ""
#~ "Let's say we wish to implement "
#~ "registering a new user account using "
#~ "the :ref:`example User model <blog-"
#~ "models>`. The *User* model has a "
#~ "*unique* constraint on the username "
#~ "field, so we will rely on the "
#~ "database's integrity guarantees to ensure "
#~ "we don't end up with duplicate "
#~ "usernames:"
#~ msgstr ""

#~ msgid ""
#~ "Rather than writing all this code, "
#~ "you can instead call either "
#~ ":py:meth:`~Model.create_or_get`:"
#~ msgstr ""

#~ msgid ""
#~ "The above example first attempts at "
#~ "creation, then falls back to retrieval,"
#~ " relying on the database to enforce"
#~ " a unique constraint."
#~ msgstr ""

#~ msgid ""
#~ "If you prefer to attempt to "
#~ "retrieve the record first, you can "
#~ "use :py:meth:`~Model.get_or_create`. This method "
#~ "is implemented along the same lines "
#~ "as the Django function of the same"
#~ " name. You can use the Django-"
#~ "style keyword argument filters to "
#~ "specify your ``WHERE`` conditions. The "
#~ "function returns a 2-tuple containing "
#~ "the instance and a boolean value "
#~ "indicating if the object was created."
#~ msgstr ""

#~ msgid ""
#~ "For more details check out the "
#~ "documentation for :py:meth:`Model.create_or_get` and"
#~ " :py:meth:`Model.get_or_create`."
#~ msgstr ""

#~ msgid ""
#~ "By default peewee will use an "
#~ "*INNER* join, but you can use "
#~ "*LEFT OUTER* or *FULL* joins as "
#~ "well:"
#~ msgstr ""

#~ msgid ""
#~ "When starting to a project with "
#~ "peewee, it's typically best to begin "
#~ "with your data model, by defining "
#~ "one or more :py:class:`Model` classes:"
#~ msgstr ""

