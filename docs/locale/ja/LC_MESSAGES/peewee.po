# SOME DESCRIPTIVE TITLE.
# Copyright (C) charles leifer
# This file is distributed under the same license as the peewee package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: peewee 2.8.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-11-30 22:55+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.4\n"

#: ../../peewee/api.rst:4
msgid "API Reference"
msgstr "APIリファレンス"

#: ../../peewee/api.rst:9 ../../peewee/example.rst:35
msgid "Models"
msgstr "モデル"

#: ../../peewee/api.rst:13
msgid ""
"Models provide a 1-to-1 mapping to database tables. Subclasses of "
"``Model`` declare any number of :py:class:`Field` instances as class "
"attributes. These fields correspond to columns on the table."
msgstr "モデルはデータベーステーブルに1対1のマッピングを提供します。"
"``Model`` のサブクラスは、任意の数の :py:class:`Field` インスタンスをクラス属性として宣言します。"
"これらのフィールドは、テーブルカラムに対応しています。"

#: ../../peewee/api.rst:17
msgid ""
"Table-level operations, such as :py:meth:`~Model.select`, "
":py:meth:`~Model.update`, :py:meth:`~Model.insert`, and "
":py:meth:`~Model.delete`, are implemented as classmethods. Row-level "
"operations such as :py:meth:`~Model.save` and "
":py:meth:`~Model.delete_instance` are implemented as instancemethods."
msgstr ":py:meth:`~Model.select`、:py:meth:`~Model.update`、:py:meth:`~Model.insert`、:py:meth:`~Model.delete` などのテーブルレベルの操作はクラスメソッドとして実装されています。"
":py:meth:`~Model.save` や :py:meth:`~Model.delete_instance` などの行レベルの操作は、インスタンスメソッドとして実装されています。"

#: ../../peewee/api.rst:22
msgid ""
"Initialize the model, assigning the given key/values to the appropriate "
"fields."
msgstr "モデルを初期化し、与えられたキー/バリューを適切なフィールドに割り当てます。"

#: ../../peewee/api.rst:25 ../../peewee/api.rst:324 ../../peewee/api.rst:343
#: ../../peewee/api.rst:362 ../../peewee/api.rst:1539 ../../peewee/api.rst:1665
#: ../../peewee/api.rst:1690 ../../peewee/api.rst:1755
#: ../../peewee/api.rst:2398 ../../peewee/api.rst:2763
#: ../../peewee/api.rst:2890 ../../peewee/playhouse.rst:534
#: ../../peewee/playhouse.rst:559 ../../peewee/playhouse.rst:1154
#: ../../peewee/playhouse.rst:1865 ../../peewee/playhouse.rst:1952
#: ../../peewee/playhouse.rst:2349 ../../peewee/playhouse.rst:2605
#: ../../peewee/playhouse.rst:2695 ../../peewee/playhouse.rst:2807
#: ../../peewee/playhouse.rst:2843 ../../peewee/playhouse.rst:2866
#: ../../peewee/playhouse.rst:2990 ../../peewee/playhouse.rst:3010
#: ../../peewee/playhouse.rst:3027 ../../peewee/playhouse.rst:3102
#: ../../peewee/playhouse.rst:4014 ../../peewee/playhouse.rst:4255
#: ../../peewee/playhouse.rst:4279 ../../peewee/querying.rst:739
msgid "Example:"
msgstr "例:"

#: ../../peewee/api.rst:38
msgid ""
"A list of model classes, field instances, functions or expressions. If no"
" argument is provided, all columns for the given model will be selected."
msgstr "モデルクラス、フィールドインスタンス、関数、または式のリスト。"
"引数が指定されていない場合は、指定されたモデルのすべての列が選択されます。"

#: ../../peewee/api.rst:41
msgid "a :py:class:`SelectQuery` for the given :py:class:`Model`."
msgstr "指定された :py:class:`Model` の :py:class*`SelectQuery` 。"

#: ../../peewee/api.rst:43
msgid "Examples of selecting all columns (default):"
msgstr "すべてのカラムを選択する例（デフォルト）:"

#: ../../peewee/api.rst:49
msgid ""
"Example of selecting all columns on *Tweet* and the parent model, *User*."
" When the ``user`` foreign key is accessed on a *Tweet* instance no "
"additional query will be needed (see :ref:`N+1 <nplusone>` for more "
"details):"
msgstr "*Tweet* のすべてのカラムと親モデル *User* を選択する例"

#: ../../peewee/api.rst:63
msgid "mapping of field-name to expression"
msgstr "フィールド名から式へのマッピング"

#: ../../peewee/api.rst:64
msgid "an :py:class:`UpdateQuery` for the given :py:class:`Model`"
msgstr "指定された :py:class:`Model` の :py:class:`UpdateQuery`"

#: ../../peewee/api.rst:66
msgid "Example showing users being marked inactive if their registration expired:"
msgstr "ユーザーの登録が失効した場合に非アクティブとマークされていることを示す例:"

#: ../../peewee/api.rst:74
msgid "Example showing an atomic update:"
msgstr "アトミック更新を示す例:"

#: ../../peewee/api.rst:81
msgid ""
"When an update query is executed, the number of rows modified will be "
"returned."
msgstr "更新クエリが実行されると、変更された行の数が返されます。"

#: ../../peewee/api.rst:85
msgid ""
"Insert a new row into the database. If any fields on the model have "
"default values, these values will be used if the fields are not "
"explicitly set in the ``insert`` dictionary."
msgstr "新しい行をデータベースに挿入します。"
"モデルのいずれかのフィールドにデフォルト値がある場合、"
"フィールドが ``insert`` ディクショナリに明示的に設定されていなければデフォルト値が使用されます。"

#: ../../peewee/api.rst:89
msgid "mapping of field or field-name to expression."
msgstr "フィールドまたはフィールド名から式へのマッピング。"

#: ../../peewee/api.rst:90 ../../peewee/api.rst:139 ../../peewee/api.rst:184
msgid "an :py:class:`InsertQuery` for the given :py:class:`Model`."
msgstr "指定された :py:class:`Model`の :py:class:`InsertQuery`"

#: ../../peewee/api.rst:92
msgid "Example showing creation of a new user:"
msgstr "新しいユーザーの作成を示す例："

#: ../../peewee/api.rst:99
msgid "You can also use :py:class:`Field` objects as the keys:"
msgstr ":py:class:`Field` オブジェクトをキーとして使用することもできます:"

#: ../../peewee/api.rst:105
msgid ""
"If you have a model with a default value on one of the fields, and that "
"field is not specified in the ``insert`` parameter, the default will be "
"used:"
msgstr "いずれかのフィールドにデフォルト値を持つモデルがあり、"
"そのフィールドが ``insert`` パラメーターで指定されていない場合は、デフォルトが使用されます:"

#: ../../peewee/api.rst:118
msgid ""
"When an insert query is executed on a table with an auto-incrementing "
"primary key, the primary key of the new row will be returned."
msgstr "オートインクリメントの主キーを持つテーブルで挿入クエリを実行すると、新しい行の主キーが返されます。"

#: ../../peewee/api.rst:122
msgid ""
"Insert multiple rows at once. The ``rows`` parameter must be an iterable "
"that yields dictionaries. As with :py:meth:`~Model.insert`, fields that "
"are not specified in the dictionary will use their default value, if one "
"exists."
msgstr "一度に複数の行を挿入します。"
"``rows`` パラメーターは、辞書でなければなりません。"
":py:meth:`Model.insert` の場合と同様に、ディクショナリに指定されていないフィールドは、"
"デフォルト値（存在する場合）を使用します。"

#: ../../peewee/api.rst:128
msgid ""
"Due to the nature of bulk inserts, each row must contain the same fields."
" The following will not work:"
msgstr "一括挿入の性質上、各行には同じフィールドが含まれている必要があります。"
"以下は動作しません:"

#: ../../peewee/api.rst:138
msgid "An iterable containing dictionaries of field-name-to-value."
msgstr "フィールド名と値がセットのディクショナリを含むリスト。"

#: ../../peewee/api.rst:141
msgid "Example of inserting multiple Users:"
msgstr "複数のユーザーを挿入する例:"

#: ../../peewee/api.rst:151
msgid ""
"Because the ``rows`` parameter can be an arbitrary iterable, you can also"
" use a generator:"
msgstr "``rows`` パラメータは任意の反復可能なものにすることができるため、ジェネレータを使用することもできます:"

#: ../../peewee/api.rst:162
msgid ""
"If you are using SQLite, your SQLite library must be version 3.7.11 or "
"newer to take advantage of bulk inserts."
msgstr "SQLiteを使用している場合、一括挿入を利用するには、SQLiteライブラリのバージョンが3.7.11以降である必要があります。"

#: ../../peewee/api.rst:166
msgid ""
"SQLite has a default limit of 999 bound variables per statement. This "
"limit can be modified at compile-time or at run-time, **but** if "
"modifying at run-time, you can only specify a *lower* value than the "
"default limit."
msgstr "SQLiteには、ステートメントごとに999のバウンド変数のデフォルト制限があります。"
"この制限はコンパイル時または実行時に変更できますが、"
"実行時に変更する場合はデフォルトの制限よりも小さい値しか指定できません。"

#: ../../peewee/api.rst:171
msgid "For more information, check out the following SQLite documents:"
msgstr ""

#: ../../peewee/api.rst:173
msgid ""
"`Max variable number limit "
"<https://www.sqlite.org/limits.html#max_variable_number>`_"
msgstr ""

#: ../../peewee/api.rst:174
msgid "`Changing run-time limits <https://www.sqlite.org/c3ref/limit.html>`_"
msgstr ""

#: ../../peewee/api.rst:175
msgid "`SQLite compile-time flags <https://www.sqlite.org/compile.html>`_"
msgstr ""

#: ../../peewee/api.rst:179
msgid ""
"Insert rows into the table using a query as the data source. This API "
"should be used for *INSERT INTO...SELECT FROM* queries."
msgstr ""

#: ../../peewee/api.rst:182
msgid "The field objects to map the selected data into."
msgstr ""

#: ../../peewee/api.rst:183
msgid "The source of the new rows."
msgstr ""

#: ../../peewee/api.rst:186
msgid "Example of inserting data across tables for denormalization purposes:"
msgstr ""

#: ../../peewee/api.rst:200 ../../peewee/api.rst:1747
msgid "a :py:class:`DeleteQuery` for the given :py:class:`Model`."
msgstr ""

#: ../../peewee/api.rst:202
msgid "Example showing the deletion of all inactive users:"
msgstr ""

#: ../../peewee/api.rst:210
msgid ""
"This method performs a delete on the *entire table*. To delete a single "
"instance, see :py:meth:`Model.delete_instance`."
msgstr ""

#: ../../peewee/api.rst:215
msgid "a string SQL expression"
msgstr ""

#: ../../peewee/api.rst:216
msgid "any number of parameters to interpolate"
msgstr ""

#: ../../peewee/api.rst:217
msgid "a :py:class:`RawQuery` for the given ``Model``"
msgstr ""

#: ../../peewee/api.rst:219
msgid "Example selecting rows from the User table:"
msgstr ""

#: ../../peewee/api.rst:228
msgid ""
"Generally the use of ``raw`` is reserved for those cases where you can "
"significantly optimize a select query. It is useful for select queries "
"since it will return instances of the model."
msgstr ""

#: ../../peewee/api.rst:234
msgid "key/value pairs of model attributes"
msgstr ""

#: ../../peewee/api.rst:237
msgid ""
"Example showing the creation of a user (a row will be added to the "
"database):"
msgstr ""

#: ../../peewee/api.rst:245
msgid "The create() method is a shorthand for instantiate-then-save."
msgstr ""

#: ../../peewee/api.rst:249
msgid "a list of query expressions, e.g. ``User.username == 'foo'``"
msgstr ""

#: ../../peewee/api.rst:250 ../../peewee/api.rst:1344
msgid ":py:class:`Model` instance or raises ``DoesNotExist`` exception"
msgstr ""

#: ../../peewee/api.rst:252
msgid ""
"Get a single row from the database that matches the given query. Raises a"
" ``<model-class>.DoesNotExist`` if no rows are returned:"
msgstr ""

#: ../../peewee/api.rst:259
msgid ""
"This method is also exposed via the :py:class:`SelectQuery`, though it "
"takes no parameters:"
msgstr ""

#: ../../peewee/api.rst:274
msgid ""
"The :py:meth:`~Model.get` method is shorthand for selecting with a limit "
"of 1. It has the added behavior of raising an exception when no matching "
"row is found. If more than one row is found, the first row returned by "
"the database cursor will be used."
msgstr ""

#: ../../peewee/api.rst:281
msgid "A dictionary of values to set on newly-created model instances."
msgstr ""

#: ../../peewee/api.rst:282
msgid ""
"Django-style filters specifying which model to get, and what values to "
"apply to new instances."
msgstr ""

#: ../../peewee/api.rst:283 ../../peewee/api.rst:316
msgid ""
"A 2-tuple containing the model instance and a boolean indicating whether "
"the instance was created."
msgstr ""

#: ../../peewee/api.rst:285
msgid ""
"This function attempts to retrieve a model instance based on the provided"
" filters. If no matching model can be found, a new model is created using"
" the parameters specified by the filters and any values in the "
"``defaults`` dictionary."
msgstr ""

#: ../../peewee/api.rst:287
msgid ""
"Use care when calling ``get_or_create`` with ``autocommit=False``, as the"
" ``get_or_create()`` method will call :py:meth:`Database.atomic` to "
"create either a transaction or savepoint."
msgstr ""

#: ../../peewee/api.rst:289
msgid "Example **without** ``get_or_create``:"
msgstr ""

#: ../../peewee/api.rst:304
msgid "Equivalent code using ``get_or_create``:"
msgstr ""

#: ../../peewee/api.rst:315
msgid "Field name to value for attempting to create a new instance."
msgstr ""

#: ../../peewee/api.rst:318
msgid ""
"This function attempts to create a model instance based on the provided "
"kwargs. If an ``IntegrityError`` occurs indicating the violation of a "
"constraint, then Peewee will return the model matching the filters."
msgstr ""

#: ../../peewee/api.rst:320
msgid ""
"Peewee will not attempt to match *all* the kwargs when an "
"``IntegrityError`` occurs. Rather, only primary key fields or fields that"
" have a unique constraint will be used to retrieve the matching instance."
msgstr ""

#: ../../peewee/api.rst:322
msgid ""
"Use care when calling ``create_or_get`` with ``autocommit=False``, as the"
" ``create_or_get()`` method will call :py:meth:`Database.atomic` to "
"create either a transaction or savepoint."
msgstr ""

#: ../../peewee/api.rst:339
msgid ":py:class:`ModelAlias` instance"
msgstr ""

#: ../../peewee/api.rst:341
msgid "The :py:meth:`alias` method is used to create self-joins."
msgstr ""

#: ../../peewee/api.rst:353
msgid ""
"When using a :py:class:`ModelAlias` in a join, you must explicitly "
"specify the join condition."
msgstr ""

#: ../../peewee/api.rst:357
msgid ""
"If set to ``True``, the method will check for the existence of the table "
"before attempting to create."
msgstr ""

#: ../../peewee/api.rst:360
msgid ""
"Create the table for the given model, along with any constraints and "
"indexes."
msgstr ""

#: ../../peewee/api.rst:371
msgid ""
"If set to ``True``, the query will check for the existence of the table "
"before attempting to remove."
msgstr ""

#: ../../peewee/api.rst:373
msgid "Drop table with ``CASCADE`` option."
msgstr ""

#: ../../peewee/api.rst:375
msgid "Drop the table for the given model."
msgstr ""

#: ../../peewee/api.rst:383
msgid "A list of queries required to create the table and indexes."
msgstr ""

#: ../../peewee/api.rst:387
msgid "Whether to force execution of an insert"
msgstr ""

#: ../../peewee/api.rst:388
msgid ""
"A list of fields to persist -- when supplied, only the given fields will "
"be persisted."
msgstr ""

#: ../../peewee/api.rst:391
msgid ""
"Save the given instance, creating or updating depending on whether it has"
" a primary key.  If ``force_insert=True`` an *INSERT* will be issued "
"regardless of whether or not the primary key exists."
msgstr ""

#: ../../peewee/api.rst:395
msgid "Example showing saving a model instance:"
msgstr ""

#: ../../peewee/api.rst:405
msgid ""
"Delete this instance and anything that depends on it, optionally updating"
" those that have nullable dependencies"
msgstr ""

#: ../../peewee/api.rst:407
msgid ""
"If doing a recursive delete, delete all dependent objects regardless of "
"whether it could be updated to NULL"
msgstr ""

#: ../../peewee/api.rst:410
msgid ""
"Delete the given instance.  Any foreign keys set to cascade on delete "
"will be deleted automatically.  For more programmatic control, you can "
"call with recursive=True, which will delete any non-nullable related "
"models (those that *are* nullable will be set to NULL).  If you wish to "
"delete all dependencies regardless of whether they are nullable, set "
"``delete_nullable=True``."
msgstr ""

#: ../../peewee/api.rst:417
msgid "example:"
msgstr ""

#: ../../peewee/api.rst:425
msgid "Search models related via a nullable foreign key"
msgstr ""

#: ../../peewee/api.rst:428
msgid ""
"Generate a list of queries of dependent models.  Yields a 2-tuple "
"containing the query and corresponding foreign key field.  Useful for "
"searching dependencies of a model, i.e. things that would be orphaned in "
"the event of a delete."
msgstr ""

#: ../../peewee/api.rst:434
msgid "Return a list of fields that were manually set."
msgstr ""

#: ../../peewee/api.rst:439
msgid ""
"If you just want to persist modified fields, you can call "
"``model.save(only=model.dirty_fields)``."
msgstr ""

#: ../../peewee/api.rst:442
msgid ""
"If you **always** want to only save a model's dirty fields, you can use "
"the Meta option ``only_save_dirty = True``. Then, any time you call "
":py:meth:`Model.save()`, by default only the dirty fields will be saved, "
"e.g."
msgstr ""

#: ../../peewee/api.rst:459
msgid "Return whether any fields were manually set."
msgstr ""

#: ../../peewee/api.rst:465
msgid ""
"This method provides a hook for performing model initialization *after* "
"the row data has been populated."
msgstr ""

#: ../../peewee/api.rst:472 ../../peewee/models.rst:76
#: ../../peewee/playhouse.rst:2410
msgid "Fields"
msgstr "フィールド"

#: ../../peewee/api.rst:476
msgid "The base class from which all other field types extend."
msgstr ""

#: ../../peewee/api.rst:478
msgid "whether this column can accept ``None`` or ``NULL`` values"
msgstr ""

#: ../../peewee/api.rst:479
msgid "whether to create an index for this column when creating the table"
msgstr ""

#: ../../peewee/api.rst:480
msgid "whether to create a unique index for this column when creating the table"
msgstr ""

#: ../../peewee/api.rst:481
msgid "specify a \"verbose name\" for this field, useful for metadata purposes"
msgstr ""

#: ../../peewee/api.rst:482
msgid "specify some instruction text for the usage/meaning of this field"
msgstr ""

#: ../../peewee/api.rst:483
msgid ""
"column name to use for underlying storage, useful for compatibility with "
"legacy databases"
msgstr ""

#: ../../peewee/api.rst:484
msgid "a value to use as an uninitialized default"
msgstr ""

#: ../../peewee/api.rst:485
msgid "an iterable of 2-tuples mapping ``value`` to ``display``"
msgstr ""

#: ../../peewee/api.rst:486
msgid "whether to use this as the primary key for the table"
msgstr ""

#: ../../peewee/api.rst:487
msgid "name of sequence (if backend supports it)"
msgstr ""

#: ../../peewee/api.rst:488
msgid "a list of constraints, e.g. ``[Check('price > 0')]``."
msgstr ""

#: ../../peewee/api.rst:489
msgid "name of schema (if backend supports it)"
msgstr ""

#: ../../peewee/api.rst:490
msgid ""
"named attributes containing values that may pertain to specific field "
"subclasses, such as \"max_length\" or \"decimal_places\""
msgstr ""

#: ../../peewee/api.rst:494
msgid ""
"Attribute used to map this field to a column type, e.g. \"string\" or "
"\"datetime\""
msgstr ""

#: ../../peewee/api.rst:498
msgid "Boolean flag indicating if the field is attached to a model class."
msgstr ""

#: ../../peewee/api.rst:502
msgid "The model the field belongs to. *Only applies to bound fields.*"
msgstr ""

#: ../../peewee/api.rst:506
msgid "The name of the field. *Only applies to bound fields.*"
msgstr ""

#: ../../peewee/api.rst:510
msgid "python data type to prep for storage in the database"
msgstr ""

#: ../../peewee/api.rst:515
msgid "data coming from the backend storage"
msgstr ""

#: ../../peewee/api.rst:520
msgid ""
"This method is a shorthand that is used, by default, by both ``db_value``"
" and ``python_value``.  You can usually get away with just implementing "
"this."
msgstr ""

#: ../../peewee/api.rst:523
msgid "arbitrary data from app or backend"
msgstr ""

#: ../../peewee/api.rst:528
msgid "Stores: integers"
msgstr ""

#: ../../peewee/api.rst:534
msgid "Stores: big integers"
msgstr ""

#: ../../peewee/api.rst:540
msgid "Stores: auto-incrementing integer fields suitable for use as primary key."
msgstr ""

#: ../../peewee/api.rst:546
msgid "Stores: floating-point numbers"
msgstr ""

#: ../../peewee/api.rst:552
msgid "Stores: double-precision floating-point numbers"
msgstr ""

#: ../../peewee/api.rst:558
msgid "Stores: decimal numbers, using python standard library ``Decimal`` objects"
msgstr ""

#: ../../peewee/api.rst:560 ../../peewee/api.rst:575
msgid "Additional attributes and values:"
msgstr ""

#: ../../peewee/api.rst:563
msgid "``max_digits``"
msgstr ""

#: ../../peewee/api.rst:563
msgid "``10``"
msgstr ""

#: ../../peewee/api.rst:564
msgid "``decimal_places``"
msgstr ""

#: ../../peewee/api.rst:564
msgid "``5``"
msgstr ""

#: ../../peewee/api.rst:565
msgid "``auto_round``"
msgstr ""

#: ../../peewee/api.rst:565
msgid "``False``"
msgstr ""

#: ../../peewee/api.rst:566
msgid "``rounding``"
msgstr ""

#: ../../peewee/api.rst:566
msgid "``decimal.DefaultContext.rounding``"
msgstr ""

#: ../../peewee/api.rst:573
msgid "Stores: small strings (0-255 bytes)"
msgstr ""

#: ../../peewee/api.rst:578 ../../peewee/models.rst:172
#: ../../peewee/models.rst:174
msgid "``max_length``"
msgstr ""

#: ../../peewee/api.rst:578
msgid "``255``"
msgstr ""

#: ../../peewee/api.rst:585
msgid "Stores: arbitrarily large strings"
msgstr ""

#: ../../peewee/api.rst:591
msgid "Stores: python ``datetime.datetime`` instances"
msgstr ""

#: ../../peewee/api.rst:593
msgid ""
"Accepts a special parameter ``formats``, which contains a list of formats"
" the datetime can be encoded with.  The default behavior is:"
msgstr ""

#: ../../peewee/api.rst:603 ../../peewee/api.rst:650 ../../peewee/api.rst:687
msgid "If the incoming value does not match a format, it will be returned as-is"
msgstr ""

#: ../../peewee/api.rst:609
msgid ""
"An expression suitable for extracting the year, for example to retrieve "
"all blog posts from 2013:"
msgstr ""

#: ../../peewee/api.rst:618
msgid "An expression suitable for extracting the month from a stored date."
msgstr ""

#: ../../peewee/api.rst:622
msgid "An expression suitable for extracting the day from a stored date."
msgstr ""

#: ../../peewee/api.rst:626
msgid "An expression suitable for extracting the hour from a stored time."
msgstr ""

#: ../../peewee/api.rst:630
msgid "An expression suitable for extracting the minute from a stored time."
msgstr ""

#: ../../peewee/api.rst:634
msgid "An expression suitable for extracting the second from a stored time."
msgstr ""

#: ../../peewee/api.rst:638
msgid "Stores: python ``datetime.date`` instances"
msgstr ""

#: ../../peewee/api.rst:640
msgid ""
"Accepts a special parameter ``formats``, which contains a list of formats"
" the date can be encoded with.  The default behavior is:"
msgstr ""

#: ../../peewee/api.rst:656
msgid ""
"An expression suitable for extracting the year, for example to retrieve "
"all people born in 1980:"
msgstr ""

#: ../../peewee/api.rst:665
msgid "Same as :py:attr:`~DateField.year`, except extract month."
msgstr ""

#: ../../peewee/api.rst:669
msgid "Same as :py:attr:`~DateField.year`, except extract day."
msgstr ""

#: ../../peewee/api.rst:673
msgid "Stores: python ``datetime.time`` instances"
msgstr ""

#: ../../peewee/api.rst:675
msgid ""
"Accepts a special parameter ``formats``, which contains a list of formats"
" the time can be encoded with.  The default behavior is:"
msgstr ""

#: ../../peewee/api.rst:693
msgid ""
"Extract the hour from a time, for example to retreive all events "
"occurring in the evening:"
msgstr ""

#: ../../peewee/api.rst:702
msgid "Same as :py:attr:`~TimeField.hour`, except extract minute."
msgstr ""

#: ../../peewee/api.rst:706
msgid "Same as :py:attr:`~TimeField.hour`, except extract second.."
msgstr ""

#: ../../peewee/api.rst:710
msgid "Stores: ``True`` / ``False``"
msgstr ""

#: ../../peewee/api.rst:716
msgid "Store arbitrary binary data."
msgstr ""

#: ../../peewee/api.rst:720
msgid "Store ``UUID`` values."
msgstr ""

#: ../../peewee/api.rst:722
msgid "Currently this field is only supported by :py:class:`PostgresqlDatabase`."
msgstr ""

#: ../../peewee/api.rst:726
msgid ""
"Intended to be used only with SQLite. Since data-types are not enforced, "
"you can declare fields without *any* data-type. It is also common for "
"SQLite virtual tables to use meta-columns or untyped columns, so for "
"those cases as well you may wish to use an untyped field."
msgstr ""

#: ../../peewee/api.rst:728
msgid ""
"Accepts a special ``coerce`` parameter, a function that takes a value "
"coming from the database and converts it into the appropriate Python "
"type."
msgstr ""

#: ../../peewee/api.rst:730
msgid "Currently this field is only supported by :py:class:`SqliteDatabase`."
msgstr ""

#: ../../peewee/api.rst:734
msgid "Stores: relationship to another model"
msgstr ""

#: ../../peewee/api.rst:736
msgid ""
"related :py:class:`Model` class or the string 'self' if declaring a self-"
"referential foreign key"
msgstr ""

#: ../../peewee/api.rst:737
msgid "attribute to expose on related model"
msgstr ""

#: ../../peewee/api.rst:738
msgid "on delete behavior, e.g. ``on_delete='CASCADE'``."
msgstr ""

#: ../../peewee/api.rst:739
msgid "on update behavior."
msgstr ""

#: ../../peewee/api.rst:740
msgid ""
"the field (or field name) on ``rel_model`` the foreign key references. "
"Defaults to the primary key field for ``rel_model``."
msgstr ""

#: ../../peewee/api.rst:763
msgid ""
"Foreign keys do not have a particular ``db_field`` as they will take "
"their field type depending on the type of primary key on the model they "
"are related to."
msgstr ""

#: ../../peewee/api.rst:767
msgid ""
"If you manually specify a ``to_field``, that field must be either a "
"primary key or have a unique constraint."
msgstr ""

#: ../../peewee/api.rst:772
msgid ""
"Specify a composite primary key for a model.  Unlike the other fields, a "
"composite key is defined in the model's ``Meta`` class after the fields "
"have been defined.  It takes as parameters the string names of the fields"
" to use as the primary key:"
msgstr ""

#: ../../peewee/api.rst:790
msgid "Query Types"
msgstr "クエリの種類"

#: ../../peewee/api.rst:794
msgid ""
"The parent class from which all other query classes are drived. While you"
" will not deal with :py:class:`Query` directly in your code, it "
"implements some methods that are common across all query types."
msgstr ""

#: ../../peewee/api.rst:800 ../../peewee/api.rst:1006
msgid "a list of one or more expressions"
msgstr ""

#: ../../peewee/api.rst:801 ../../peewee/api.rst:838
msgid "a :py:class:`Query` instance"
msgstr ""

#: ../../peewee/api.rst:803
msgid "Example selection users where the username is equal to 'somebody':"
msgstr ""

#: ../../peewee/api.rst:809
msgid ""
"Example selecting tweets made by users who are either editors or "
"administrators:"
msgstr ""

#: ../../peewee/api.rst:817
msgid "Example of deleting tweets by users who are no longer active:"
msgstr ""

#: ../../peewee/api.rst:827
msgid ""
":py:meth:`~SelectQuery.where` calls are chainable.  Multiple calls will "
"be \"AND\"-ed together."
msgstr ""

#: ../../peewee/api.rst:832
msgid ""
"the model to join on.  there must be a :py:class:`ForeignKeyField` "
"between the current ``query context`` and the model passed in."
msgstr ""

#: ../../peewee/api.rst:834
msgid ""
"allows the type of ``JOIN`` used to be specified explicitly, one of "
"``JOIN.INNER``, ``JOIN.LEFT_OUTER``, ``JOIN.FULL``"
msgstr ""

#: ../../peewee/api.rst:836
msgid ""
"if multiple foreign keys exist between two models, this parameter is the "
"ForeignKeyField to join on."
msgstr ""

#: ../../peewee/api.rst:840
msgid ""
"Generate a ``JOIN`` clause from the current ``query context`` to the "
"``model`` passed in, and establishes ``model`` as the new ``query "
"context``."
msgstr ""

#: ../../peewee/api.rst:843
msgid ""
"Example selecting tweets and joining on user in order to restrict to only"
" those tweets made by \"admin\" users:"
msgstr ""

#: ../../peewee/api.rst:850
msgid ""
"Example selecting users and joining on a particular foreign key field. "
"See the :py:ref:`example app <example-app>` for a real-life usage:"
msgstr ""

#: ../../peewee/api.rst:859
msgid "model to switch the ``query context`` to."
msgstr ""

#: ../../peewee/api.rst:862
msgid ""
"Switches the ``query context`` to the given model.  Raises an exception "
"if the model has not been selected or joined on previously.  Useful for "
"performing multiple joins from a single table."
msgstr ""

#: ../../peewee/api.rst:866
msgid "The following example selects from blog and joins on both entry and user:"
msgstr ""

#: ../../peewee/api.rst:874
msgid "A string to alias the result of this query"
msgstr ""

#: ../../peewee/api.rst:877
msgid "Assign an alias to given query, which can be used as part of a subquery."
msgstr ""

#: ../../peewee/api.rst:887
msgid "Execute the given query"
msgstr ""

#: ../../peewee/api.rst:893
msgid "return the row as a tuple or a single value"
msgstr ""

#: ../../peewee/api.rst:894
msgid ""
"attempt to coerce the selected value to the appropriate data-type based "
"on it's associated Field type (assuming one exists)."
msgstr ""

#: ../../peewee/api.rst:899
msgid ""
"Provide a way to retrieve single values from select queries, for instance"
" when performing an aggregation."
msgstr ""

#: ../../peewee/api.rst:907
msgid ""
"This example illustrates the use of the `convert` argument. When using a "
"SQLite database, datetimes are stored as strings. To select the max "
"datetime, and have it *returned* as a datetime, we will specify "
"``convert=True``."
msgstr ""

#: ../../peewee/api.rst:923
msgid ""
"By far the most complex of the query classes available in peewee. It "
"supports all clauses commonly associated with select queries."
msgstr ""

#: ../../peewee/api.rst:926
msgid "Methods on the select query can be chained together."
msgstr ""

#: ../../peewee/api.rst:928
msgid ""
"``SelectQuery`` implements an :py:meth:`~SelectQuery.__iter__` method, "
"allowing it to be iterated to return model instances."
msgstr ""

#: ../../peewee/api.rst:931
msgid "a :py:class:`Model` class to perform query on"
msgstr ""

#: ../../peewee/api.rst:932
msgid "a list of models, fields, functions or expressions"
msgstr ""

#: ../../peewee/api.rst:934
msgid ""
"If no selection is provided, it will default to all the fields of the "
"given model."
msgstr ""

#: ../../peewee/api.rst:937
msgid ""
"Example selecting some user instances from the database.  Only the ``id``"
" and ``username`` columns are selected.  When iterated, will return "
"instances of the ``User`` model:"
msgstr ""

#: ../../peewee/api.rst:947
msgid ""
"Example selecting users and additionally the number of tweets made by the"
" user. The ``User`` instances returned will have an additional attribute,"
" 'count', that corresponds to the number of tweets made:"
msgstr ""

#: ../../peewee/api.rst:960
msgid ""
"a list of expressions, which can be model classes or fields. if left "
"blank, will default to all the fields of the given model."
msgstr ""

#: ../../peewee/api.rst:962 ../../peewee/api.rst:979 ../../peewee/api.rst:989
#: ../../peewee/api.rst:1007 ../../peewee/api.rst:1027
#: ../../peewee/api.rst:1110 ../../peewee/api.rst:1123
#: ../../peewee/api.rst:1137 ../../peewee/api.rst:1145
#: ../../peewee/api.rst:1178 ../../peewee/api.rst:1186
#: ../../peewee/api.rst:1194 ../../peewee/api.rst:1265
msgid ":py:class:`SelectQuery`"
msgstr ""

#: ../../peewee/api.rst:965
msgid ""
"Usually the selection will be specified when the instance is created. "
"This method simply exists for the case when you want to modify the SELECT"
" clause independent of instantiating a query."
msgstr ""

#: ../../peewee/api.rst:976
msgid ""
"one or more expressions, for example :py:class:`Model` or "
":py:class:`SelectQuery` instance(s). if left blank, will default to the "
"table of the given model."
msgstr ""

#: ../../peewee/api.rst:988
msgid ""
"a list of expressions, which can be model classes or individual field "
"instances"
msgstr ""

#: ../../peewee/api.rst:991
msgid ""
"Group by one or more columns.  If a model class is provided, all the "
"fields on that model class will be used."
msgstr ""

#: ../../peewee/api.rst:994
msgid ""
"Example selecting users, joining on tweets, and grouping by the user so a"
" count of tweets can be calculated for each user:"
msgstr ""

#: ../../peewee/api.rst:1009
msgid ""
"Here is the above example selecting users and tweet counts, but "
"restricting the results to those users who have created 100 or more "
"tweets:"
msgstr ""

#: ../../peewee/api.rst:1022
msgid ""
"a list of fields, calls to ``field.[asc|desc]()`` or one or more "
"expressions. If called without any arguments, any pre-existing ``ORDER "
"BY`` clause will be removed."
msgstr ""

#: ../../peewee/api.rst:1025
msgid ""
"When called with ``extend=True``, Peewee will append any to the pre-"
"existing ``ORDER BY`` rather than overwriting it."
msgstr ""

#: ../../peewee/api.rst:1029
msgid "Example of ordering users by username:"
msgstr ""

#: ../../peewee/api.rst:1035
msgid ""
"Example of selecting tweets and ordering them first by user, then newest "
"first:"
msgstr ""

#: ../../peewee/api.rst:1047
msgid ""
"You can also use ``+`` and ``-`` prefixes to indicate ascending or "
"descending order if you prefer:"
msgstr ""

#: ../../peewee/api.rst:1058
msgid ""
"A more complex example ordering users by the number of tweets made "
"(greatest to least), then ordered by username in the event of a tie:"
msgstr ""

#: ../../peewee/api.rst:1070
msgid "Example of removing a pre-existing ``ORDER BY`` clause:"
msgstr ""

#: ../../peewee/api.rst:1083
msgid "One or more :py:class:`Window` instances."
msgstr ""

#: ../../peewee/api.rst:1085
msgid "Add one or more window definitions to this query."
msgstr ""

#: ../../peewee/api.rst:1100
msgid "limit results to ``num`` rows"
msgstr ""

#: ../../peewee/api.rst:1104
msgid "offset results by ``num`` rows"
msgstr ""

#: ../../peewee/api.rst:1108
msgid "a 1-based page number to use for paginating results"
msgstr ""

#: ../../peewee/api.rst:1109
msgid "number of results to return per-page"
msgstr ""

#: ../../peewee/api.rst:1112
msgid "Shorthand for applying a ``LIMIT`` and ``OFFSET`` to the query."
msgstr ""

#: ../../peewee/api.rst:1114
msgid "Page indices are **1-based**, so page 1 is the first page."
msgstr ""

#: ../../peewee/api.rst:1122
msgid "See notes."
msgstr ""

#: ../../peewee/api.rst:1125
msgid ""
"Indicates that this query should only return distinct rows. Results in a "
"``SELECT DISTINCT`` query."
msgstr ""

#: ../../peewee/api.rst:1129
msgid ""
"The value for ``is_distinct`` should either be a boolean, in which case "
"the query will (or won't) be `DISTINCT`."
msgstr ""

#: ../../peewee/api.rst:1132
msgid ""
"You can specify a list of one or more expressions to generate a "
"``DISTINCT ON`` query, e.g. ``.distinct([Model.col1, Model.col2])``."
msgstr ""

#: ../../peewee/api.rst:1139
msgid ""
"Indicate that this query should lock rows for update.  If ``nowait`` is "
"``True`` then the database will raise an ``OperationalError`` if it "
"cannot obtain the lock."
msgstr ""

#: ../../peewee/api.rst:1147
msgid ""
"Flag this query indicating it should only attempt to reconstruct a single"
" model instance for every row returned by the cursor.  If multiple tables"
" were queried, the columns returned are patched directly onto the single "
"model instance."
msgstr ""

#: ../../peewee/api.rst:1151
msgid ""
"Generally this method is useful for speeding up the time needed to "
"construct model instances given a database cursor."
msgstr ""

#: ../../peewee/api.rst:1156
msgid ""
"this can provide a significant speed improvement when doing simple "
"iteration over a large result set."
msgstr ""

#: ../../peewee/api.rst:1161
msgid "``iterable``"
msgstr ""

#: ../../peewee/api.rst:1163
msgid ""
"By default peewee will cache rows returned by the cursor.  This is to "
"prevent things like multiple iterations, slicing and indexing from "
"triggering extra queries.  When you are iterating over a large number of "
"rows, however, this cache can take up a lot of memory. Using "
"``iterator()`` will save memory by not storing all the returned model "
"instances."
msgstr ""

#: ../../peewee/api.rst:1180 ../../peewee/api.rst:1816
msgid ""
"Flag this query indicating it should simply return raw tuples from the "
"cursor. This method is useful when you either do not want or do not need "
"full model instances."
msgstr ""

#: ../../peewee/api.rst:1188
msgid ""
"Flag this query indicating it should simply return dictionaries from the "
"cursor. This method is useful when you either do not want or do not need "
"full model instances."
msgstr ""

#: ../../peewee/api.rst:1196
msgid "This method provides one way to avoid the **N+1** query problem."
msgstr ""

#: ../../peewee/api.rst:1198
msgid ""
"Consider a webpage where you wish to display a list of users and all of "
"their associated tweets. You could approach this problem by listing the "
"users, then for each user executing a separate query to retrieve their "
"tweets. This is the **N+1** behavior, because the number of queries "
"varies depending on the number of users. Conventional wisdom is that it "
"is preferable to execute fewer queries. Peewee provides several ways to "
"avoid this problem."
msgstr ""

#: ../../peewee/api.rst:1205
msgid ""
"You can use the :py:func:`prefetch` helper, which uses ``IN`` clauses to "
"retrieve the tweets for the listed users."
msgstr ""

#: ../../peewee/api.rst:1208
msgid ""
"Another method is to select both the user and the tweet data in a single "
"query, then de-dupe the users, aggregating the tweets in the process."
msgstr ""

#: ../../peewee/api.rst:1211
msgid "The raw column data might appear like this:"
msgstr ""

#: ../../peewee/api.rst:1223
msgid ""
"We can infer from the ``JOIN`` clause that the user data will be "
"duplicated, and therefore by de-duping the users, we can collect their "
"tweets in one go and iterate over the users and tweets transparently."
msgstr ""

#: ../../peewee/api.rst:1250
msgid ""
"Be sure that you specify an ``ORDER BY`` clause that ensures duplicated "
"data will appear in consecutive rows."
msgstr ""

#: ../../peewee/api.rst:1254
msgid ""
"You can specify arbitrarily complex joins, though for more complex "
"queries it may be more efficient to use :py:func:`prefetch`. In short, "
"try both and see what works best for your data-set."
msgstr ""

#: ../../peewee/api.rst:1258
msgid ""
"For more information, see the :ref:`nplusone` document and the :ref"
":`aggregate-rows` sub-section."
msgstr ""

#: ../../peewee/api.rst:1262
msgid ""
"related :py:class:`Model` on which to perform aggregation, must be linked"
" by :py:class:`ForeignKeyField`."
msgstr ""

#: ../../peewee/api.rst:1264
msgid "the type of aggregation to use, e.g. ``fn.Count(Tweet.id).alias('count')``"
msgstr ""

#: ../../peewee/api.rst:1267
msgid ""
"Annotate a query with an aggregation performed on a related model, for "
"example, \"get a list of users with the number of tweets for each\":"
msgstr ""

#: ../../peewee/api.rst:1274
msgid ""
"If ``aggregation`` is None, it will default to "
"``fn.Count(related_model.id).alias('count')`` but can be anything:"
msgstr ""

#: ../../peewee/api.rst:1283
msgid ""
"If the ``ForeignKeyField`` is ``nullable``, then a ``LEFT OUTER`` join "
"may need to be used::"
msgstr ""

#: ../../peewee/api.rst:1294
msgid ""
"a function specifying what aggregation to perform, for example "
"``fn.Max(Tweet.created_date)``."
msgstr ""

#: ../../peewee/api.rst:1297
msgid ""
"Method to look at an aggregate of rows using a given function and return "
"a scalar value, such as the count of all rows or the average value of a "
"particular column."
msgstr ""

#: ../../peewee/api.rst:1303 ../../peewee/api.rst:1320
msgid "Remove any limit or offset clauses from the query before counting."
msgstr ""

#: ../../peewee/api.rst:1307
msgid ""
"If the query has a GROUP BY, DISTINCT, LIMIT, or OFFSET clause, then the "
":py:meth:`~SelectQuery.wrapped_count` method will be used instead."
msgstr ""

#: ../../peewee/api.rst:1323
msgid ""
"Wrap the count query in a subquery.  Additional overhead but will give "
"correct counts when performing ``DISTINCT`` queries or those with ``GROUP"
" BY`` clauses."
msgstr ""

#: ../../peewee/api.rst:1328
msgid ""
":py:meth:`~SelectQuery.count` will automatically default to "
":py:meth:`~SelectQuery.wrapped_count` in the event the query is distinct "
"or has a grouping."
msgstr ""

#: ../../peewee/api.rst:1333
msgid ""
"boolean whether the current query will return any rows.  uses an "
"optimized lookup, so use this rather than :py:meth:`~SelectQuery.get`."
msgstr ""

#: ../../peewee/api.rst:1346
msgid ""
"Get a single row from the database that matches the given query.  Raises "
"a ``<model-class>.DoesNotExist`` if no rows are returned:"
msgstr ""

#: ../../peewee/api.rst:1357
msgid ""
"This method is also exposed via the :py:class:`Model` api, in which case "
"it accepts arguments that are translated to the where clause:"
msgstr ""

#: ../../peewee/api.rst:1360
msgid "user = User.get(User.active == True, User.username == username)"
msgstr ""

#: ../../peewee/api.rst:1364
msgid ""
"Return the first *n* query results after applying a limit of ``n`` "
"records."
msgstr ""

#: ../../peewee/api.rst:1366 ../../peewee/api.rst:1382
msgid ":py:class:`Model` instance, list or ``None`` if no results"
msgstr ""

#: ../../peewee/api.rst:1368
msgid ""
"Fetch the first *n* rows from a query. Behind-the-scenes, a ``LIMIT n`` "
"is applied. The results of the query are then cached on the query result "
"wrapper so subsequent calls to :py:meth:`~SelectQuery.first` will not "
"cause multiple queries."
msgstr ""

#: ../../peewee/api.rst:1373
msgid ""
"If only one row is requested (default behavior), then the return-type "
"will be either a model instance or ``None``."
msgstr ""

#: ../../peewee/api.rst:1376
msgid ""
"If multiple rows are requested, the return type will either be a list of "
"one to n model instances, or ``None`` if no results are found."
msgstr ""

#: ../../peewee/api.rst:1381
msgid "Return the first *n* query results."
msgstr ""

#: ../../peewee/api.rst:1384
msgid ""
"Fetch the first *n* rows from a query. No ``LIMIT`` is applied to the "
"query, so the :py:meth:`~SelectQuery.peek` has slightly different "
"semantics from :py:meth:`~SelectQuery.first`, which ensures no more than "
"*n* rows are requested. The ``peek`` method, on the other hand, retains "
"the ability to fetch the entire result set withouth issuing additional "
"queries."
msgstr ""

#: ../../peewee/api.rst:1393
msgid ":py:class:`QueryResultWrapper`"
msgstr ""

#: ../../peewee/api.rst:1395
msgid ""
"Executes the query and returns a :py:class:`QueryResultWrapper` for "
"iterating over the result set.  The results are managed internally by the"
" query and whenever a clause is added that would possibly alter the "
"result set, the query is marked for re-execution."
msgstr ""

#: ../../peewee/api.rst:1402
msgid "Executes the query and returns populated model instances:"
msgstr ""

#: ../../peewee/api.rst:1411
msgid ""
"Return the number of items in the result set of this query. If all you "
"need is the count of items and do not intend to do anything with the "
"results, call :py:meth:`~SelectQuery.count`."
msgstr ""

#: ../../peewee/api.rst:1414
msgid ""
"The ``SELECT`` query will be executed and the result set will be loaded. "
"If you want to obtain the number of results without also loading the "
"query, use :py:meth:`~SelectQuery.count`."
msgstr ""

#: ../../peewee/api.rst:1420
msgid "Either an index or a ``slice`` object."
msgstr ""

#: ../../peewee/api.rst:1422
msgid ""
"Return the model instance(s) at the requested indices. To get the first "
"model, for instance:"
msgstr ""

#: ../../peewee/api.rst:1433 ../../peewee/api.rst:1451
#: ../../peewee/api.rst:1467 ../../peewee/api.rst:1483
msgid "Either a :py:class:`SelectQuery` or a :py:class:`CompoundSelect`"
msgstr ""

#: ../../peewee/api.rst:1434 ../../peewee/api.rst:1452
#: ../../peewee/api.rst:1468 ../../peewee/api.rst:1484
msgid ":py:class:`CompoundSelect`"
msgstr ""

#: ../../peewee/api.rst:1436
msgid ""
"Create a ``UNION`` query with the right-hand object. The result will "
"contain all values from both the left and right queries."
msgstr ""

#: ../../peewee/api.rst:1447
msgid ""
"SQLite does not allow ``ORDER BY`` or ``LIMIT`` clauses on the components"
" of a compound query, however SQLite does allow these clauses on the "
"final, compound result. This applies to ``UNION (ALL)``, ``INTERSECT``, "
"and ``EXCEPT``."
msgstr ""

#: ../../peewee/api.rst:1454
msgid ""
"Create an ``INTERSECT`` query. The result will contain values that are in"
" both the left and right queries."
msgstr ""

#: ../../peewee/api.rst:1470
msgid ""
"Create an ``EXCEPT`` query. The result will contain values that are in "
"the left-hand query but not in the right-hand query."
msgstr ""

#: ../../peewee/api.rst:1486
msgid ""
"Create an symmetric difference query. The result will contain values that"
" are in either the left-hand query or the right-hand query, but not both."
msgstr ""

#: ../../peewee/api.rst:1502
msgid ":py:class:`Model` class on which to perform update"
msgstr ""

#: ../../peewee/api.rst:1503
msgid "mapping of field/value pairs containing columns and values to update"
msgstr ""

#: ../../peewee/api.rst:1505
msgid "Example in which users are marked inactive if their registration expired:"
msgstr ""

#: ../../peewee/api.rst:1512
msgid "Example of an atomic update:"
msgstr ""

#: ../../peewee/api.rst:1524 ../../peewee/api.rst:1636
#: ../../peewee/api.rst:1740 ../../peewee/api.rst:1832
msgid "Performs the query"
msgstr ""

#: ../../peewee/api.rst:1528 ../../peewee/api.rst:1679
#: ../../peewee/api.rst:1744
msgid ""
"A list of model classes, field instances, functions or expressions. If no"
" argument is provided, all columns for the given model will be selected. "
"To clear any existing values, pass in ``None``."
msgstr ""

#: ../../peewee/api.rst:1531
msgid "a :py:class:`UpdateQuery` for the given :py:class:`Model`."
msgstr ""

#: ../../peewee/api.rst:1533
msgid ""
"Add a ``RETURNING`` clause to the query, which will cause the ``UPDATE`` "
"to compute return values based on each row that was actually updated."
msgstr ""

#: ../../peewee/api.rst:1535
msgid ""
"When the query is executed, rather than returning the number of rows "
"updated, an iterator will be returned that yields the updated objects."
msgstr ""

#: ../../peewee/api.rst:1537 ../../peewee/api.rst:1688
#: ../../peewee/api.rst:1753
msgid "Currently only :py:class:`PostgresqlDatabase` supports this feature."
msgstr ""

#: ../../peewee/api.rst:1554 ../../peewee/api.rst:1704
#: ../../peewee/api.rst:1770
msgid ""
"For more information, check out :ref:`the RETURNING clause docs "
"<returning-clause>`."
msgstr ""

#: ../../peewee/api.rst:1558 ../../peewee/api.rst:1566
msgid ":py:class:`UpdateQuery`"
msgstr ""

#: ../../peewee/api.rst:1560 ../../peewee/api.rst:1568
msgid ""
"This method should only be used in conjunction with a call to "
":py:meth:`~UpdateQuery.returning`."
msgstr ""

#: ../../peewee/api.rst:1562
msgid ""
"When the updated results are returned, they will be returned as row "
"tuples."
msgstr ""

#: ../../peewee/api.rst:1570
msgid ""
"When the updated results are returned, they will be returned as "
"dictionaries mapping column to value."
msgstr ""

#: ../../peewee/api.rst:1574
msgid ""
"Add a SQL ``ON CONFLICT`` clause with the specified action to the given "
"``UPDATE`` query. `Valid actions "
"<https://www.sqlite.org/lang_conflict.html>`_ are:"
msgstr ""

#: ../../peewee/api.rst:1576 ../../peewee/api.rst:1648
msgid "ROLLBACK"
msgstr ""

#: ../../peewee/api.rst:1577 ../../peewee/api.rst:1649
msgid "ABORT"
msgstr ""

#: ../../peewee/api.rst:1578 ../../peewee/api.rst:1650
msgid "FAIL"
msgstr ""

#: ../../peewee/api.rst:1579 ../../peewee/api.rst:1651
msgid "IGNORE"
msgstr ""

#: ../../peewee/api.rst:1580 ../../peewee/api.rst:1652
msgid "REPLACE"
msgstr ""

#: ../../peewee/api.rst:1582
msgid "Specifying ``None`` for the action will execute a normal ``UPDATE`` query."
msgstr ""

#: ../../peewee/api.rst:1584 ../../peewee/api.rst:1656
msgid "This feature is only available on SQLite databases."
msgstr ""

#: ../../peewee/api.rst:1589
msgid "Creates an ``InsertQuery`` instance for the given model."
msgstr ""

#: ../../peewee/api.rst:1591
msgid "A mapping of either field or field-name to value."
msgstr ""

#: ../../peewee/api.rst:1592
msgid ""
"An iterable of dictionaries containing a mapping of field or field-name "
"to value."
msgstr ""

#: ../../peewee/api.rst:1594
msgid ""
"A list of field objects to insert data into (only used in combination "
"with the ``query`` parameter)."
msgstr ""

#: ../../peewee/api.rst:1595
msgid "A :py:class:`SelectQuery` to use as the source of data."
msgstr ""

#: ../../peewee/api.rst:1596
msgid ""
"Check that every column referenced in the insert query has a "
"corresponding field on the model. If validation is enabled and then "
"fails, a ``KeyError`` is raised."
msgstr ""

#: ../../peewee/api.rst:1598
msgid "Basic example:"
msgstr ""

#: ../../peewee/api.rst:1607
msgid "Example inserting multiple rows:"
msgstr ""

#: ../../peewee/api.rst:1618
msgid "Example inserting using a query as the data source:"
msgstr ""

#: ../../peewee/api.rst:1640
msgid ""
"Perform an *INSERT OR REPLACE* query with SQLite. MySQL databases will "
"issue a *REPLACE* query. Currently this feature is not supported for "
"Postgres databases, but the 9.5 syntax will be added soon."
msgstr ""

#: ../../peewee/api.rst:1642
msgid "This feature is only available on SQLite and MySQL databases."
msgstr ""

#: ../../peewee/api.rst:1646
msgid ""
"Add a SQL ``ON CONFLICT`` clause with the specified action to the given "
"``INSERT`` query. Specifying ``REPLACE`` is equivalent to using the "
":py:meth:`~InsertQuery.upsert` method. `Valid actions "
"<https://www.sqlite.org/lang_conflict.html>`_ are:"
msgstr ""

#: ../../peewee/api.rst:1654
msgid "Specifying ``None`` for the action will execute a normal ``INSERT`` query."
msgstr ""

#: ../../peewee/api.rst:1660
msgid ""
"By default, when doing bulk INSERTs, peewee will not return the list of "
"generated primary keys. However, if the database supports returning "
"primary keys via ``INSERT ... RETURNING``, this method instructs peewee "
"to return the generated list of IDs."
msgstr ""

#: ../../peewee/api.rst:1663
msgid ""
"Currently only PostgreSQL supports this behavior. While other databases "
"support bulk inserts, they will simply return ``True`` instead."
msgstr ""

#: ../../peewee/api.rst:1682
msgid "a :py:class:`InsertQuery` for the given :py:class:`Model`."
msgstr ""

#: ../../peewee/api.rst:1684
msgid ""
"Add a ``RETURNING`` clause to the query, which will cause the ``INSERT`` "
"to compute return values based on each row that was inserted."
msgstr ""

#: ../../peewee/api.rst:1686
msgid ""
"When the query is executed, rather than returning the primary key of the "
"new row(s), an iterator will be returned that yields the inserted "
"objects."
msgstr ""

#: ../../peewee/api.rst:1708 ../../peewee/api.rst:1716
msgid ":py:class:`InsertQuery`"
msgstr ""

#: ../../peewee/api.rst:1710 ../../peewee/api.rst:1718
msgid ""
"This method should only be used in conjunction with a call to "
":py:meth:`~InsertQuery.returning`."
msgstr ""

#: ../../peewee/api.rst:1712
msgid ""
"When the inserted results are returned, they will be returned as row "
"tuples."
msgstr ""

#: ../../peewee/api.rst:1720
msgid ""
"When the inserted results are returned, they will be returned as "
"dictionaries mapping column to value."
msgstr ""

#: ../../peewee/api.rst:1724
msgid "Creates a *DELETE* query for the given model."
msgstr ""

#: ../../peewee/api.rst:1727
msgid ""
"DeleteQuery will *not* traverse foreign keys or ensure that constraints "
"are obeyed, so use it with care."
msgstr ""

#: ../../peewee/api.rst:1730
msgid "Example deleting users whose account is inactive:"
msgstr ""

#: ../../peewee/api.rst:1749
msgid ""
"Add a ``RETURNING`` clause to the query, which will cause the ``DELETE`` "
"to compute return values based on each row that was removed from the "
"database."
msgstr ""

#: ../../peewee/api.rst:1751
msgid ""
"When the query is executed, rather than returning the number of rows "
"deleted, an iterator will be returned that yields the deleted objects."
msgstr ""

#: ../../peewee/api.rst:1774 ../../peewee/api.rst:1782
#: ../../peewee/querying.rst:234
msgid ":py:class:`DeleteQuery`"
msgstr ""

#: ../../peewee/api.rst:1776 ../../peewee/api.rst:1784
msgid ""
"This method should only be used in conjunction with a call to "
":py:meth:`~DeleteQuery.returning`."
msgstr ""

#: ../../peewee/api.rst:1778
msgid ""
"When the deleted results are returned, they will be returned as row "
"tuples."
msgstr ""

#: ../../peewee/api.rst:1786
msgid ""
"When the deleted results are returned, they will be returned as "
"dictionaries mapping column to value."
msgstr ""

#: ../../peewee/api.rst:1791
msgid ""
"Allows execution of an arbitrary query and returns instances of the model"
" via a :py:class:`QueryResultsWrapper`."
msgstr ""

#: ../../peewee/api.rst:1795
msgid ""
"Generally you will only need this for executing highly optimized SELECT "
"queries."
msgstr ""

#: ../../peewee/api.rst:1799
#, python-format
msgid ""
"If you are executing a parameterized query, you must use the correct "
"interpolation string for your database.  SQLite uses ``'?'`` and most "
"others use ``'%s'``."
msgstr ""

#: ../../peewee/api.rst:1803
msgid "Example selecting users with a given username:"
msgstr ""

#: ../../peewee/api.rst:1814 ../../peewee/api.rst:1822
msgid ":py:class:`RawQuery`"
msgstr ""

#: ../../peewee/api.rst:1824
msgid ""
"Flag this query indicating it should simply return raw dicts from the "
"cursor. This method is useful when you either do not want or do not need "
"full model instances."
msgstr ""

#: ../../peewee/api.rst:1830
msgid ""
"a :py:class:`QueryResultWrapper` for iterating over the result set.  The "
"results are instances of the given model."
msgstr ""

#: ../../peewee/api.rst:1837
msgid "Compound select query."
msgstr ""

#: ../../peewee/api.rst:1839
msgid ""
"The type of model to return, by default the model class of the ``lhs`` "
"query."
msgstr ""

#: ../../peewee/api.rst:1841
msgid ""
"Left-hand query, either a :py:class:`SelectQuery` or a "
":py:class:`CompoundQuery`."
msgstr ""

#: ../../peewee/api.rst:1842
msgid ""
"A :py:class:`Node` instance used to join the two queries, for example "
"``SQL('UNION')``."
msgstr ""

#: ../../peewee/api.rst:1843
msgid ""
"Right query, either a :py:class:`SelectQuery` or a "
":py:class:`CompoundQuery`."
msgstr ""

#: ../../peewee/api.rst:1848
msgid ":py:class:`SelectQuery` instance"
msgstr ""

#: ../../peewee/api.rst:1849
msgid ""
"one or more :py:class:`SelectQuery` instances to prefetch for ``sq``. You"
" can also pass models, but they will be converted into SelectQueries. If "
"you wish to specify a particular model to join against, you can pass a "
"2-tuple of ``(query_or_model, join_model)``."
msgstr ""

#: ../../peewee/api.rst:1853
msgid ":py:class:`SelectQuery` with related instances pre-populated"
msgstr ""

#: ../../peewee/api.rst:1855
msgid ""
"Pre-fetch the appropriate instances from the subqueries and apply them to"
" their corresponding parent row in the outer query. This function will "
"eagerly load the related instances specified in the subqueries. This is a"
" technique used to save doing O(n) queries for n rows, and rather is O(k)"
" queries for *k* subqueries."
msgstr ""

#: ../../peewee/api.rst:1861
msgid ""
"For example, consider you have a list of users and want to display all "
"their tweets:"
msgstr ""

#: ../../peewee/api.rst:1879
msgid ""
"You can prefetch an arbitrary number of items.  For instance, suppose we "
"have a photo site, User -> Photo -> (Comments, Tags).  That is, users can"
" post photos, and these photos can have tags and comments on them.  If we"
" wanted to fetch a list of users, all their photos, and all the comments "
"and tags on the photos:"
msgstr ""

#: ../../peewee/api.rst:1905
msgid "Subqueries must be related by foreign key and can be arbitrarily deep"
msgstr ""

#: ../../peewee/api.rst:1907
msgid ""
"For more information, see the :ref:`nplusone` document and the "
":ref:`prefetch` sub-section."
msgstr ""

#: ../../peewee/api.rst:1910
msgid ""
":py:func:`prefetch` can use up lots of RAM when the result set is large, "
"and will not warn you if you are doing something dangerous, so it is up "
"to you to know when to use it.  Additionally, because of the semantics of"
" subquerying, there may be some cases when prefetch does not act as you "
"expect (for instance, when applying a ``LIMIT`` to subqueries, but there "
"may be others) -- please report anything you think is a bug to `github "
"<https://github.com/coleifer/peewee/issues>`_."
msgstr ""

#: ../../peewee/api.rst:1919
msgid "Database and its subclasses"
msgstr "データベースとそのサブクエリ"

#: ../../peewee/api.rst:1923 ../../peewee/api.rst:2050
msgid "the name of the database (or filename if using sqlite)"
msgstr ""

#: ../../peewee/api.rst:1924
msgid "whether to store connections in a threadlocal"
msgstr ""

#: ../../peewee/api.rst:1925
msgid ""
"automatically commit every query executed by calling "
":py:meth:`~Database.execute`"
msgstr ""

#: ../../peewee/api.rst:1926
msgid ""
"a mapping of :py:attr:`~Field.db_field` to database column type, e.g. "
"'string' => 'varchar'"
msgstr ""

#: ../../peewee/api.rst:1927
msgid "a mapping of operations understood by the querycompiler to expressions"
msgstr ""

#: ../../peewee/api.rst:1928
msgid "automatically rollback when an exception occurs while executing a query."
msgstr ""

#: ../../peewee/api.rst:1929
msgid "use the Cython speedups module to improve performance of some queries."
msgstr ""

#: ../../peewee/api.rst:1930 ../../peewee/api.rst:2051
msgid "any arbitrary parameters to pass to the database driver when connecting"
msgstr ""

#: ../../peewee/api.rst:1932
msgid ""
"The ``connect_kwargs`` dictionary is used for vendor-specific parameters "
"that will be passed back directly to your database driver, allowing you "
"to specify the ``user``, ``host`` and ``password``, for instance. For "
"more information and examples, see the :ref:`vendor-specific parameters "
"document <vendor-specific-parameters>`."
msgstr ""

#: ../../peewee/api.rst:1935
msgid ""
"If your database name is not known when the class is declared, you can "
"pass ``None`` in as the database name which will mark the database as "
"\"deferred\" and any attempt to connect while in this state will raise an"
" exception.  To initialize your database, call the "
":py:meth:`Database.init` method with the database name."
msgstr ""

#: ../../peewee/api.rst:1941
msgid ""
"For an in-depth discussion of run-time database configuration, see the "
":ref:`deferring_initialization` section."
msgstr ""

#: ../../peewee/api.rst:1943
msgid ""
"A high-level API for working with the supported database engines. The "
"database class:"
msgstr ""

#: ../../peewee/api.rst:1945
msgid "Manages the underlying database connection."
msgstr ""

#: ../../peewee/api.rst:1946
msgid "Executes queries."
msgstr ""

#: ../../peewee/api.rst:1947
msgid "Manage transactions and savepoints."
msgstr ""

#: ../../peewee/api.rst:1948
msgid "Create and drop tables and indexes."
msgstr ""

#: ../../peewee/api.rst:1949
msgid "Introspect the database."
msgstr ""

#: ../../peewee/api.rst:1953
msgid ""
"Whether to issue a commit after executing a select query.  With some "
"engines can prevent implicit transactions from piling up."
msgstr ""

#: ../../peewee/api.rst:1958
msgid "A class suitable for compiling queries"
msgstr ""

#: ../../peewee/api.rst:1962
msgid "Supported compound query operations."
msgstr ""

#: ../../peewee/api.rst:1966
msgid ""
"Whether ``UNION`` (or other compound ``SELECT`` queries) allow "
"parentheses around the queries."
msgstr ""

#: ../../peewee/api.rst:1970
msgid "Whether the database supports ``DISTINCT ON`` statements."
msgstr ""

#: ../../peewee/api.rst:1974
msgid "Whether the database supports cascading drop table queries."
msgstr ""

#: ../../peewee/api.rst:1978
msgid ""
"A mapping of field types to database column types, e.g. ``{'primary_key':"
" 'SERIAL'}``"
msgstr ""

#: ../../peewee/api.rst:1982
msgid "Whether the given backend enforces foreign key constraints."
msgstr ""

#: ../../peewee/api.rst:1986 ../../peewee/api.rst:1990
msgid "Whether the given backend supports selecting rows for update"
msgstr ""

#: ../../peewee/api.rst:1994
msgid ""
"Whether the database supports multiple ``VALUES`` clauses for ``INSERT`` "
"queries."
msgstr ""

#: ../../peewee/api.rst:1998
msgid ""
"Whether the database supports returning the primary key for newly "
"inserted rows."
msgstr ""

#: ../../peewee/api.rst:2002
msgid "The string used by the driver to interpolate query parameters"
msgstr ""

#: ../../peewee/api.rst:2006
msgid ""
"A mapping of operation codes to string operations, e.g. ``{OP.LIKE: 'LIKE"
" BINARY'}``"
msgstr ""

#: ../../peewee/api.rst:2010
msgid "The string used by the driver to quote names"
msgstr ""

#: ../../peewee/api.rst:2014
msgid ""
"Table names that are reserved by the backend -- if encountered in the "
"application a warning will be issued."
msgstr ""

#: ../../peewee/api.rst:2019
msgid ""
"Whether the database supports ``RETURNING`` clauses for ``UPDATE``, "
"``INSERT`` and ``DELETE`` queries."
msgstr ""

#: ../../peewee/api.rst:2021
msgid "Currently only :py:class:`PostgresqlDatabase` supports this."
msgstr ""

#: ../../peewee/api.rst:2023
msgid "See the following for more information:"
msgstr ""

#: ../../peewee/api.rst:2025 ../../peewee/querying.rst:859
msgid ":py:meth:`UpdateQuery.returning`"
msgstr ""

#: ../../peewee/api.rst:2026 ../../peewee/querying.rst:860
msgid ":py:meth:`InsertQuery.returning`"
msgstr ""

#: ../../peewee/api.rst:2027 ../../peewee/querying.rst:861
msgid ":py:meth:`DeleteQuery.returning`"
msgstr ""

#: ../../peewee/api.rst:2031
msgid "Whether the given backend supports savepoints."
msgstr ""

#: ../../peewee/api.rst:2035
msgid "Whether the given backend supports sequences"
msgstr ""

#: ../../peewee/api.rst:2039
msgid ""
"Whether the given backend supports deleting rows using a subquery that "
"selects from the same table"
msgstr ""

#: ../../peewee/api.rst:2044
msgid "Whether the given backend supports window functions."
msgstr ""

#: ../../peewee/api.rst:2048
msgid ""
"This method is used to initialize a deferred database. For details on "
"configuring your database at run-time, see the "
":ref:`deferring_initialization` section."
msgstr ""

#: ../../peewee/api.rst:2055
msgid "Establishes a connection to the database"
msgstr ""

#: ../../peewee/api.rst:2058
msgid ""
"By default, connections will be stored on a threadlocal, ensuring "
"connections are not shared across threads. To disable this behavior, "
"initialize the database with ``threadlocals=False``."
msgstr ""

#: ../../peewee/api.rst:2062
msgid "Closes the connection to the database (if one is open)"
msgstr ""

#: ../../peewee/api.rst:2065
msgid ""
"If you initialized with ``threadlocals=True``, only a connection local to"
" the calling thread will be closed."
msgstr ""

#: ../../peewee/api.rst:2070
msgid ""
"Perform additional intialization on a newly-opened connection. For "
"example, if you are using SQLite you may want to enable foreign key "
"constraint enforcement (off by default)."
msgstr ""

#: ../../peewee/api.rst:2072
msgid "Here is how you might use this hook to load a SQLite extension:"
msgstr ""

#: ../../peewee/api.rst:2090
msgid "the database cursor used to perform the insert query"
msgstr ""

#: ../../peewee/api.rst:2091
msgid "the model class that was just created"
msgstr ""

#: ../../peewee/api.rst:2100
msgid ""
"an instance of :py:class:`QueryCompiler` using the field and op overrides"
" specified."
msgstr ""

#: ../../peewee/api.rst:2105
msgid "a :py:class:`Node` instance or subclass (e.g. a :py:class:`SelectQuery`)."
msgstr ""

#: ../../peewee/api.rst:2107
msgid ""
"The clause will be compiled into SQL then sent to the "
":py:meth:`~Database.execute_sql` method."
msgstr ""

#: ../../peewee/api.rst:2111
msgid "a string sql query"
msgstr ""

#: ../../peewee/api.rst:2112
msgid "a list or tuple of parameters to interpolate"
msgstr ""

#: ../../peewee/api.rst:2115
msgid ""
"You can configure whether queries will automatically commit by using the "
":py:meth:`~Database.set_autocommit` and "
":py:meth:`Database.get_autocommit` methods."
msgstr ""

#: ../../peewee/api.rst:2121
msgid ""
"Initiate a new transaction.  By default **not** implemented as this is "
"not part of the DB-API 2.0, but provided for API compatibility."
msgstr ""

#: ../../peewee/api.rst:2126
msgid ""
"Call ``commit()`` on the active connection, committing the current "
"transaction."
msgstr ""

#: ../../peewee/api.rst:2130
msgid ""
"Call ``rollback()`` on the active connection, rolling back the current "
"transaction."
msgstr ""

#: ../../peewee/api.rst:2134
msgid "a boolean value indicating whether to turn on/off autocommit."
msgstr ""

#: ../../peewee/api.rst:2146
msgid ""
"a list of :py:class:`IndexMetadata` instances, representing the indexes "
"for the given table."
msgstr ""

#: ../../peewee/api.rst:2150
msgid ""
"a list of :py:class:`ColumnMetadata` instances, representing the columns "
"for the given table."
msgstr ""

#: ../../peewee/api.rst:2158
msgid ""
"a list of :py:class:`ForeignKeyMetadata` instances, representing the "
"foreign keys for the given table."
msgstr ""

#: ../../peewee/api.rst:2166 ../../peewee/playhouse.rst:2418
msgid ":py:class:`Model` class."
msgstr ""

#: ../../peewee/api.rst:2167
msgid "If `True`, the table will not be created if it already exists."
msgstr ""

#: ../../peewee/api.rst:2170
msgid ""
"Unlike :py:meth:`Model.create_table`, this method does not create indexes"
" or constraints. This method will only create the table itself. If you "
"wish to create the table along with any indexes and constraints, use "
"either :py:meth:`Model.create_table` or "
":py:meth:`Database.create_tables`."
msgstr ""

#: ../../peewee/api.rst:2174
msgid ":py:class:`Model` table on which to create index"
msgstr ""

#: ../../peewee/api.rst:2175
msgid "field(s) to create index on (either field instances or field names)"
msgstr ""

#: ../../peewee/api.rst:2176
msgid "whether the index should enforce uniqueness"
msgstr ""

#: ../../peewee/api.rst:2180
msgid ":py:class:`Model` table on which to create foreign key constraint"
msgstr ""

#: ../../peewee/api.rst:2181
msgid ":py:class:`Field` object"
msgstr ""

#: ../../peewee/api.rst:2182
msgid "Name to give foreign key constraint."
msgstr ""

#: ../../peewee/api.rst:2184
msgid ""
"Manually create a foreign key constraint using an ``ALTER TABLE`` query. "
"This is primarily used when creating a circular foreign key dependency, "
"for example:"
msgstr ""

#: ../../peewee/api.rst:2214
msgid "name of sequence to create"
msgstr ""

#: ../../peewee/api.rst:2216 ../../peewee/api.rst:2228
msgid "only works with database engines that support sequences"
msgstr ""

#: ../../peewee/api.rst:2220
msgid ":py:class:`Model` table to drop"
msgstr ""

#: ../../peewee/api.rst:2221
msgid "if ``True``, query will add a ``IF EXISTS`` clause"
msgstr ""

#: ../../peewee/api.rst:2222 ../../peewee/api.rst:2247
msgid "drop table with ``CASCADE`` option."
msgstr ""

#: ../../peewee/api.rst:2226
msgid "name of sequence to drop"
msgstr ""

#: ../../peewee/api.rst:2232 ../../peewee/api.rst:2245
msgid "A list of models."
msgstr ""

#: ../../peewee/api.rst:2233
msgid "Check first whether the table exists before attempting to create it."
msgstr ""

#: ../../peewee/api.rst:2235
msgid ""
"This method should be used for creating tables as it will resolve the "
"model dependency graph and ensure the tables are created in the correct "
"order. This method will also create any indexes and constraints defined "
"on the models."
msgstr ""

#: ../../peewee/api.rst:2237 ../../peewee/api.rst:2251
#: ../../peewee/database.rst:873 ../../peewee/playhouse.rst:1553
#: ../../peewee/playhouse.rst:3206 ../../peewee/playhouse.rst:3570
#: ../../peewee/playhouse.rst:3671 ../../peewee/playhouse.rst:3724
msgid "Usage:"
msgstr ""

#: ../../peewee/api.rst:2246
msgid "Check the table exists before attempting to drop it."
msgstr ""

#: ../../peewee/api.rst:2249
msgid ""
"This method should be used for dropping tables, as it will resolve the "
"model dependency graph and ensure the tables are dropped in the correct "
"order."
msgstr ""

#: ../../peewee/api.rst:2259
msgid ""
"Execute statements in either a transaction or a savepoint. The outer-most"
" call to *atomic* will use a transaction, and any subsequent nested calls"
" will use savepoints."
msgstr ""

#: ../../peewee/api.rst:2262
msgid "``atomic`` can be used as either a context manager or a decorator."
msgstr ""

#: ../../peewee/api.rst:2265
msgid ""
"For most use-cases, it makes the most sense to always use "
":py:meth:`~Database.atomic` when you wish to execute queries in a "
"transaction. The benefit of using ``atomic`` is that you do not need to "
"manually keep track of the transaction stack depth, as this will be "
"managed for you."
msgstr ""

#: ../../peewee/api.rst:2267 ../../peewee/api.rst:2300
#: ../../peewee/api.rst:2341
msgid "Context manager example code:"
msgstr ""

#: ../../peewee/api.rst:2281 ../../peewee/api.rst:2317
msgid "Decorator example code:"
msgstr ""

#: ../../peewee/api.rst:2292
msgid ""
"Execute statements in a transaction using either a context manager or "
"decorator. If an error is raised inside the wrapped block, the "
"transaction will be rolled back, otherwise statements are committed when "
"exiting. Transactions can also be explicitly rolled back or committed "
"within the transaction block by calling :py:meth:`~transaction.rollback` "
"or :py:meth:`~transaction.commit`. If you manually commit or roll back, a"
" new transaction will be started automatically."
msgstr ""

#: ../../peewee/api.rst:2296
msgid ""
"Nested blocks can be wrapped with ``transaction`` - the database will "
"keep a stack and only commit when it reaches the end of the outermost "
"function / block."
msgstr ""

#: ../../peewee/api.rst:2329
msgid ""
"Use :py:meth:`~Database.atomic` or :py:meth:`~Database.transaction` "
"instead."
msgstr ""

#: ../../peewee/api.rst:2333
msgid ""
"Execute statements in a savepoint using either a context manager or "
"decorator.  If an error is raised inside the wrapped block, the savepoint"
" will be rolled back, otherwise statements are committed when exiting. "
"Like :py:meth:`~Database.transaction`, a savepoint can also be explicitly"
" rolled-back or committed by calling :py:meth:`~savepoint.rollback` or "
":py:meth:`~savepoint.commit`. If you manually commit or roll back, a new "
"savepoint **will not** be created."
msgstr ""

#: ../../peewee/api.rst:2337
msgid "Savepoints can be thought of as nested transactions."
msgstr ""

#: ../../peewee/api.rst:2339
msgid "An optional string identifier for the savepoint."
msgstr ""

#: ../../peewee/api.rst:2359
msgid ""
"Create an :py:class:`ExecutionContext` context manager or decorator. "
"Blocks wrapped with an *ExecutionContext* will run using their own "
"connection. By default, the wrapped block will also run in a transaction,"
" although this can be disabled specifyin ``with_transaction=False``."
msgstr ""

#: ../../peewee/api.rst:2361
msgid ""
"For more explanation of :py:class:`ExecutionContext`, see the "
":ref:`advanced_connection_management` section."
msgstr ""

#: ../../peewee/api.rst:2363
msgid "ExecutionContext is very new and has not been tested extensively."
msgstr ""

#: ../../peewee/api.rst:2367
msgid ""
"Register a mapping of field overrides for the database class.  Used to "
"register custom fields or override the defaults."
msgstr ""

#: ../../peewee/api.rst:2370 ../../peewee/api.rst:2378
msgid "A mapping of :py:attr:`~Field.db_field` to column type"
msgstr ""

#: ../../peewee/api.rst:2374
msgid ""
"Register a mapping of operations understood by the QueryCompiler to their"
" SQL equivalent, e.g. ``{OP.EQ: '='}``.  Used to extend the types of "
"field comparisons."
msgstr ""

#: ../../peewee/api.rst:2382
msgid ""
"Return an expression suitable for extracting a date part from a date "
"field.  For instance, extract the year from a :py:class:`DateTimeField`."
msgstr ""

#: ../../peewee/api.rst:2385
msgid ""
"The date part attribute to retrieve.  Valid options are: \"year\", "
"\"month\", \"day\", \"hour\", \"minute\" and \"second\"."
msgstr ""

#: ../../peewee/api.rst:2387 ../../peewee/api.rst:2395
msgid "field instance storing a datetime, date or time."
msgstr ""

#: ../../peewee/api.rst:2392
msgid ""
"Return an expression suitable for truncating a date / datetime to the "
"given resolution. This can be used, for example, to group a collection of"
" timestamps by day."
msgstr ""

#: ../../peewee/api.rst:2394
msgid ""
"The date part to truncate to. Valid options are: \"year\", \"month\", "
"\"day\", \"hour\", \"minute\" and \"second\"."
msgstr ""

#: ../../peewee/api.rst:2409
msgid ""
":py:class:`Database` subclass that works with the ``sqlite3`` driver (or "
"``pysqlite2``). In addition to the default database parameters, "
":py:class:`SqliteDatabase` also accepts a *journal_mode* parameter which "
"will configure the journaling mode."
msgstr ""

#: ../../peewee/api.rst:2411
msgid ""
"If you have both ``sqlite3`` and ``pysqlite2`` installed on your system, "
"peewee will use whichever points at a newer version of SQLite."
msgstr ""

#: ../../peewee/api.rst:2413
msgid ""
"SQLite is unique among the databases supported by Peewee in that it "
"allows a high degree of customization by the host application. This means"
" you can do things like write custom functions or aggregates *in Python* "
"and then call them from your SQL queries. This feature, and many more, "
"are available through the :py:class:`SqliteExtDatabase`, part of "
"``playhouse.sqlite_ext``. I *strongly* recommend you use "
":py:class:`SqliteExtDatabase` as it exposes many of the features that "
"make SQLite so powerful."
msgstr ""

#: ../../peewee/api.rst:2415
msgid "Custom parameters:"
msgstr ""

#: ../../peewee/api.rst:2417
msgid "Journaling mode."
msgstr ""

#: ../../peewee/api.rst:2418
msgid ""
"List of 2-tuples containing ``PRAGMA`` statements to run against new "
"connections."
msgstr ""

#: ../../peewee/api.rst:2420 ../../peewee/database.rst:182
msgid ""
"SQLite allows run-time configuration of a number of parameters through "
"``PRAGMA`` statements (`documentation "
"<https://www.sqlite.org/pragma.html>`_). These statements are typically "
"run against a new database connection. To run one or more ``PRAGMA`` "
"statements against new connections, you can specify them as a list of "
"2-tuples containing the pragma name and value:"
msgstr ""

#: ../../peewee/api.rst:2435
msgid ""
":py:class:`Database` subclass that works with either \"MySQLdb\" or "
"\"pymysql\"."
msgstr ""

#: ../../peewee/api.rst:2447
msgid ":py:class:`Database` subclass that works with the \"psycopg2\" driver"
msgstr ""

#: ../../peewee/api.rst:2469
msgid ""
"Control whether the ``UNICODE`` and ``UNICODEARRAY`` psycopg2 extensions "
"are loaded automatically."
msgstr ""

#: ../../peewee/api.rst:2472
msgid "Transaction, Savepoint and ExecutionContext"
msgstr "トランザクション、セーブポイントおよびExecutionContext"

#: ../../peewee/api.rst:2474
msgid ""
"The easiest way to create transactions and savepoints is to use "
":py:meth:`Database.atomic`. The :py:meth:`~Database.atomic` method will "
"create a transaction or savepoint depending on the level of nesting."
msgstr ""

#: ../../peewee/api.rst:2486
msgid ""
"Context manager that encapsulates a database transaction. Statements "
"executed within the wrapped block will be committed at the end of the "
"block unless an exception occurs, in which case any changes will be "
"rolled back."
msgstr ""

#: ../../peewee/api.rst:2488
msgid ""
"Transactions should not be nested as this could lead to unpredictable "
"behavior in the event of an exception in a nested block. If you wish to "
"use nested transactions, use the :py:meth:`~Database.atomic` method, "
"which will create a transaction at the outer-most layer and use "
"savepoints for nested blocks."
msgstr ""

#: ../../peewee/api.rst:2490
msgid ""
"In practice you should not create :py:class:`transaction` objects "
"directly, but rather use the :py:meth:`Database.transaction` method."
msgstr ""

#: ../../peewee/api.rst:2494
msgid "Manually commit any pending changes and begin a new transaction."
msgstr ""

#: ../../peewee/api.rst:2498
msgid "Manually roll-back any pending changes and begin a new transaction."
msgstr ""

#: ../../peewee/api.rst:2502
msgid ""
"Context manager that encapsulates a savepoint (nested transaction). "
"Statements executed within the wrapped block will be committed at the end"
" of the block unless an exception occurs, in which case any changes will "
"be rolled back."
msgstr ""

#: ../../peewee/api.rst:2504
msgid ""
"Savepoints must be created within a transaction. It is recommended that "
"you use :py:meth:`~Database.atomic` instead of manually managing the "
"transaction+savepoint stack."
msgstr ""

#: ../../peewee/api.rst:2506
msgid ""
"In practice you should not create :py:class:`savepoint` objects directly,"
" but rather use the :py:meth:`Database.savepoint` method."
msgstr ""

#: ../../peewee/api.rst:2510
msgid ""
"Manually commit any pending changes. If the savepoint is manually "
"committed and additional changes are made, they will be executed in the "
"context of the outer block."
msgstr ""

#: ../../peewee/api.rst:2514
msgid ""
"Manually roll-back any pending changes. If the savepoint is manually "
"rolled-back and additional changes are made, they will be executed in the"
" context of the outer block."
msgstr ""

#: ../../peewee/api.rst:2518
msgid ""
"ExecutionContext provides a way to explicitly run statements in a "
"dedicated connection. Typically a single database connection is "
"maintained per-thread, but in some situations you may wish to explicitly "
"force a new, separate connection. To accomplish this, you can create an "
":py:class:`ExecutionContext`. Statements executed in the wrapped block "
"will be run in a transaction by default, though you can disable this by "
"specifying ``with_transaction=False``."
msgstr ""

#: ../../peewee/api.rst:2520
msgid ""
"Rather than instantiating ``ExecutionContext`` directly, use "
":py:meth:`Database.execution_context`."
msgstr ""

#: ../../peewee/api.rst:2522 ../../peewee/database.rst:209
#: ../../peewee/database.rst:313 ../../peewee/playhouse.rst:787
#: ../../peewee/playhouse.rst:2531 ../../peewee/playhouse.rst:2555
#: ../../peewee/playhouse.rst:2575
msgid "Example code:"
msgstr ""

#: ../../peewee/api.rst:2545
msgid ""
"For the duration of the wrapped block, all queries against the given "
"``models`` will use the specified ``database``. Optionally these queries "
"can be run outside a transaction by specifying "
"``with_transaction=False``."
msgstr ""

#: ../../peewee/api.rst:2547
msgid ""
"``Using`` provides, in short, a way to run queries on a list of models "
"using a manually specified database."
msgstr ""

#: ../../peewee/api.rst:2549 ../../peewee/playhouse.rst:3581
#: ../../peewee/playhouse.rst:3668
msgid "a :py:class:`Database` instance."
msgstr ""

#: ../../peewee/api.rst:2550
msgid "a list of :py:class:`Model` classes to use with the given database."
msgstr ""

#: ../../peewee/api.rst:2551
msgid "Whether the wrapped block should be run in a transaction."
msgstr ""

#: ../../peewee/api.rst:2554
msgid "Metadata Types"
msgstr "メタデータの種類"

#: ../../peewee/api.rst:2560
msgid "The name of the index."
msgstr ""

#: ../../peewee/api.rst:2564
msgid "The SQL query used to generate the index."
msgstr ""

#: ../../peewee/api.rst:2568
msgid "A list of columns that are covered by the index."
msgstr ""

#: ../../peewee/api.rst:2572
msgid "A boolean value indicating whether the index has a unique constraint."
msgstr ""

#: ../../peewee/api.rst:2576
msgid "The name of the table containing this index."
msgstr ""

#: ../../peewee/api.rst:2582
msgid "The name of the column."
msgstr ""

#: ../../peewee/api.rst:2586
msgid "The data type of the column"
msgstr ""

#: ../../peewee/api.rst:2590
msgid "A boolean value indicating whether ``NULL`` is permitted in this column."
msgstr ""

#: ../../peewee/api.rst:2594
msgid "A boolean value indicating whether this column is a primary key."
msgstr ""

#: ../../peewee/api.rst:2598
msgid "The name of the table containing this column."
msgstr ""

#: ../../peewee/api.rst:2604
msgid "The column containing the foreign key (the \"source\")."
msgstr ""

#: ../../peewee/api.rst:2608
msgid "The table referenced by the foreign key."
msgstr ""

#: ../../peewee/api.rst:2612
msgid "The column referenced by the foreign key (on ``dest_table``)."
msgstr ""

#: ../../peewee/api.rst:2616
msgid "The name of the table containing this foreign key."
msgstr ""

#: ../../peewee/api.rst:2619
msgid "Misc"
msgstr "その他"

#: ../../peewee/api.rst:2623
msgid ""
"A helper class that will convert arbitrary function calls to SQL function"
" calls."
msgstr ""

#: ../../peewee/api.rst:2625
msgid ""
"To express functions in peewee, use the :py:class:`fn` object.  The way "
"it works is anything to the right of the \"dot\" operator will be treated"
" as a function.  You can pass that function arbitrary parameters which "
"can be other valid expressions."
msgstr ""

#: ../../peewee/api.rst:2629
msgid "For example:"
msgstr ""

#: ../../peewee/api.rst:2632
msgid "Peewee expression"
msgstr ""

#: ../../peewee/api.rst:2632
msgid "Equivalent SQL"
msgstr ""

#: ../../peewee/api.rst:2634
msgid "``fn.Count(Tweet.id).alias('count')``"
msgstr ""

#: ../../peewee/api.rst:2634
msgid "``Count(t1.\"id\") AS count``"
msgstr ""

#: ../../peewee/api.rst:2635
msgid "``fn.Lower(fn.Substr(User.username, 1, 1))``"
msgstr ""

#: ../../peewee/api.rst:2635
msgid "``Lower(Substr(t1.\"username\", 1, 1))``"
msgstr ""

#: ../../peewee/api.rst:2636
msgid "``fn.Rand().alias('random')``"
msgstr ""

#: ../../peewee/api.rst:2636
msgid "``Rand() AS random``"
msgstr ""

#: ../../peewee/api.rst:2637
msgid "``fn.Stddev(Employee.salary).alias('sdv')``"
msgstr ""

#: ../../peewee/api.rst:2637
msgid "``Stddev(t1.\"salary\") AS sdv``"
msgstr ""

#: ../../peewee/api.rst:2642
msgid "Basic support for SQL window functions."
msgstr ""

#: ../../peewee/api.rst:2644 ../../peewee/api.rst:2714
msgid "List of :py:class:`Node` instances to partition by."
msgstr ""

#: ../../peewee/api.rst:2645 ../../peewee/api.rst:2715
msgid "List of :py:class:`Node` instances to use for ordering."
msgstr ""

#: ../../peewee/api.rst:2646
msgid "A :py:class:`Window` instance to use for this aggregate."
msgstr ""

#: ../../peewee/api.rst:2648 ../../peewee/api.rst:2717
#: ../../peewee/models.rst:516 ../../peewee/playhouse.rst:2900
#: ../../peewee/playhouse.rst:3128 ../../peewee/playhouse.rst:3173
#: ../../peewee/playhouse.rst:3702
msgid "Examples:"
msgstr ""

#: ../../peewee/api.rst:2692
msgid ""
"Add fragments of SQL to a peewee query.  For example you might want to "
"reference an aliased name."
msgstr ""

#: ../../peewee/api.rst:2695
msgid "Arbitrary SQL string."
msgstr ""

#: ../../peewee/api.rst:2696
msgid "Arbitrary query parameters."
msgstr ""

#: ../../peewee/api.rst:2712
msgid "Create a ``WINDOW`` definition."
msgstr ""

#: ../../peewee/api.rst:2734
msgid ""
"Used to reference a not-yet-created model class. Stands in as a "
"placeholder for the related model of a foreign key. Useful for circular "
"references."
msgstr ""

#: ../../peewee/api.rst:2755
msgid "Replace the placeholder with the correct model class."
msgstr ""

#: ../../peewee/api.rst:2759
msgid ""
"Proxy class useful for situations when you wish to defer the "
"initialization of an object.  For instance, you want to define your "
"models but you do not know what database engine you will be using until "
"runtime."
msgstr ""

#: ../../peewee/api.rst:2789
msgid "The object to proxy to."
msgstr ""

#: ../../peewee/api.rst:2791
msgid ""
"Once initialized, the attributes and methods on ``obj`` can be accessed "
"directly via the :py:class:`Proxy` instance."
msgstr ""

#: ../../peewee/api.rst:2796
msgid ""
"The :py:class:`Node` class is the parent class for all composable parts "
"of a query, and forms the basis of peewee's expression API. The following"
" classes extend :py:class:`Node`:"
msgstr ""

#: ../../peewee/api.rst:2798
msgid ""
":py:class:`SelectQuery`, :py:class:`UpdateQuery`, "
":py:class:`InsertQuery`, :py:class:`DeleteQuery`, and "
":py:class:`RawQuery`."
msgstr ""

#: ../../peewee/api.rst:2799
msgid ":py:class:`Field`"
msgstr ""

#: ../../peewee/api.rst:2800
msgid ":py:class:`Func` (and :py:func:`fn`)"
msgstr ""

#: ../../peewee/api.rst:2801
msgid ":py:class:`SQL`"
msgstr ""

#: ../../peewee/api.rst:2802
msgid ":py:class:`Expression`"
msgstr ""

#: ../../peewee/api.rst:2803
msgid ":py:class:`Param`"
msgstr ""

#: ../../peewee/api.rst:2804
msgid ":py:class:`Window`"
msgstr ""

#: ../../peewee/api.rst:2805
msgid ":py:class:`Clause`"
msgstr ""

#: ../../peewee/api.rst:2806
msgid ":py:class:`Entity`"
msgstr ""

#: ../../peewee/api.rst:2807
msgid ":py:class:`Check`"
msgstr ""

#: ../../peewee/api.rst:2809
msgid "Overridden operators:"
msgstr ""

#: ../../peewee/api.rst:2811
msgid ""
"Bitwise and- and or- (``&`` and ``|``): combine multiple nodes using the "
"given conjunction."
msgstr ""

#: ../../peewee/api.rst:2812
msgid ""
"``+``, ``-``, ``*``, ``/`` and ``^`` (add, subtract, multiply, divide and"
" exclusive-or)."
msgstr ""

#: ../../peewee/api.rst:2813
msgid ""
"``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``: create a binary expression "
"using the given comparator."
msgstr ""

#: ../../peewee/api.rst:2814
msgid "``<<``: create an *IN* expression."
msgstr ""

#: ../../peewee/api.rst:2815
msgid "``>>``: create an *IS* expression."
msgstr ""

#: ../../peewee/api.rst:2816
msgid "``%`` and ``**``: *LIKE* and *ILIKE*."
msgstr ""

#: ../../peewee/api.rst:2820
msgid "Create a binary expression using case-insensitive string search."
msgstr ""

#: ../../peewee/api.rst:2824
msgid "Create a binary expression using case-insensitive prefix search."
msgstr ""

#: ../../peewee/api.rst:2828
msgid "Create a binary expression using case-insensitive suffix search."
msgstr ""

#: ../../peewee/api.rst:2832
msgid "Create an expression that will match values between ``low`` and ``high``."
msgstr ""

#: ../../peewee/api.rst:2836
msgid "Match based on regular expression."
msgstr ""

#: ../../peewee/api.rst:2840
msgid "Concatenate the current node with the provided ``rhs``."
msgstr ""

#: ../../peewee/api.rst:2844
msgid "Create an expression testing whether the ``Node`` is (or is not) ``NULL``."
msgstr ""

#: ../../peewee/api.rst:2854
msgid ""
"To simplify things, peewee will generate the correct SQL for equality and"
" inequality. The :py:meth:`~Node.is_null` method is provided simply for "
"readability."
msgstr ""

#: ../../peewee/api.rst:2865
msgid "Negate the node. This translates roughly into *NOT (<node>)*."
msgstr ""

#: ../../peewee/api.rst:2869
msgid "Apply an alias to the given node. This translates into *<node> AS <name>*."
msgstr ""

#: ../../peewee/api.rst:2873
msgid ""
"Apply ascending ordering to the given node. This translates into *<node> "
"ASC*."
msgstr ""

#: ../../peewee/api.rst:2877
msgid ""
"Apply descending ordering to the given node. This translates into *<node>"
" DESC*."
msgstr ""

#: ../../peewee/api.rst:2881
msgid ""
"Bind the results of an expression to a specific model type. Useful when "
"adding expressions to a select, where the result of the expression should"
" be placed on a particular joined instance."
msgstr ""

#: ../../peewee/api.rst:2885
msgid ""
"Decorator for adding the decorated function as a new method on "
":py:class:`Node` and its subclasses. Useful for adding implementation-"
"specific features to all node types."
msgstr ""

#: ../../peewee/api.rst:2887
msgid ""
"Method name. If not provided the name of the wrapped function will be "
"used."
msgstr ""

#: ../../peewee/api.rst:2888
msgid ""
"Whether this method should return a clone. This is generally true when "
"the method mutates the internal state of the node."
msgstr ""

#: ../../peewee/api.rst:2910
msgid ""
"To remove an extended method, simply call ``delattr`` on the class the "
"method was originally added to."
msgstr ""

#: ../../peewee/contributing.rst:4
msgid "Contributing"
msgstr "貢献する"

#: ../../peewee/contributing.rst:6
msgid ""
"In order to continually improve, Peewee needs the help of developers like"
" you. Whether it's contributing patches, submitting bug reports, or just "
"asking and answering questions, you are helping to make Peewee a better "
"library."
msgstr ""

#: ../../peewee/contributing.rst:8
msgid "In this document I'll describe some of the ways you can help."
msgstr ""

#: ../../peewee/contributing.rst:11
msgid "Patches"
msgstr "パッチ"

#: ../../peewee/contributing.rst:13
msgid ""
"Do you have an idea for a new feature, or is there a clunky API you'd "
"like to improve? Before coding it up and submitting a pull-request, `open"
" a new issue <https://github.com/coleifer/peewee/issues/new>`_ on GitHub "
"describing your proposed changes. This doesn't have to be anything "
"formal, just a description of what you'd like to do and why."
msgstr ""

#: ../../peewee/contributing.rst:15
msgid ""
"When you're ready, you can submit a pull-request with your changes. "
"Successful patches will have the following:"
msgstr ""

#: ../../peewee/contributing.rst:17
msgid "Unit tests."
msgstr ""

#: ../../peewee/contributing.rst:18
msgid "Documentation, both prose form and general :ref:`API documentation <api>`."
msgstr ""

#: ../../peewee/contributing.rst:19
msgid "Code that conforms stylistically with the rest of the Peewee codebase."
msgstr ""

#: ../../peewee/contributing.rst:22
msgid "Bugs"
msgstr "バグ"

#: ../../peewee/contributing.rst:24
msgid ""
"If you've found a bug, please check to see if it has `already been "
"reported <https://github.com/coleifer/peewee/issues/>`_, and if not "
"`create an issue on GitHub "
"<https://github.com/coleifer/peewee/issues/new>`_. The more information "
"you include, the more quickly the bug will get fixed, so please try to "
"include the following:"
msgstr ""

#: ../../peewee/contributing.rst:26
msgid ""
"Traceback and the error message (please `format your code "
"<https://help.github.com/articles/markdown-basics/>`_!)"
msgstr ""

#: ../../peewee/contributing.rst:27
msgid "Relevant portions of your code or code to reproduce the error"
msgstr ""

#: ../../peewee/contributing.rst:28
msgid ""
"Peewee version: ``python -c \"from peewee import __version__; "
"print(__version__)\"``"
msgstr ""

#: ../../peewee/contributing.rst:29
msgid "Which database you're using"
msgstr ""

#: ../../peewee/contributing.rst:31
msgid ""
"If you have found a bug in the code and submit a failing test-case, then "
"hats-off to you, you are a hero!"
msgstr ""

#: ../../peewee/contributing.rst:34
msgid "Questions"
msgstr "質問"

#: ../../peewee/contributing.rst:36
msgid ""
"If you have questions about how to do something with peewee, then I "
"recommend either:"
msgstr ""

#: ../../peewee/contributing.rst:38
msgid ""
"Ask on StackOverflow. I check SO just about every day for new peewee "
"questions and try to answer them. This has the benefit also of preserving"
" the question and answer for other people to find."
msgstr ""

#: ../../peewee/contributing.rst:39
msgid ""
"Ask in IRC, ``#peewee`` on freenode. I always answer questions, but it "
"may take a bit to get to them."
msgstr ""

#: ../../peewee/contributing.rst:40
msgid "Ask on the mailing list, https://groups.google.com/group/peewee-orm"
msgstr ""

#: ../../peewee/database.rst:4
msgid "Managing your Database"
msgstr "データベースの管理"

#: ../../peewee/database.rst:6
msgid ""
"This document describes how to perform typical database-related tasks "
"with peewee. Throughout this document we will use the following example "
"models:"
msgstr ""

#: ../../peewee/database.rst:22
msgid "Creating a database connection and tables"
msgstr "データベース接続とテーブルの作成"

#: ../../peewee/database.rst:24
msgid ""
"While it is not necessary to explicitly connect to the database before "
"using it, **managing connections explicitly is a good practice**. This "
"way if the connection fails, the exception can be caught during the "
"*connect* step, rather than some arbitrary time later when a query is "
"executed. Furthermore, if you're using a :ref:`connection pool <pool>`, "
"it is actually necessary to call :py:meth:`~Database.connect` and "
":py:meth:`~Database.close` to ensure connections are recycled correctly."
msgstr ""

#: ../../peewee/database.rst:26
msgid ""
"For web-apps you will typically open a connection when a request is "
"started and close it when the response is delivered:"
msgstr ""

#: ../../peewee/database.rst:38
msgid ""
"For examples of configuring connection hooks for several popular web "
"frameworks, see the :ref:`adding_request_hooks` section."
msgstr ""

#: ../../peewee/database.rst:40
msgid ""
"For advanced connection management techniques, see the :ref:`advanced "
"connection management <advanced_connection_management>` section."
msgstr ""

#: ../../peewee/database.rst:42
msgid ""
"To use this database with your models, set the ``database`` attribute on "
"an inner :ref:`Meta <model-options>` class:"
msgstr ""

#: ../../peewee/database.rst:52
msgid ""
"**Best practice:** define a base model class that points at the database "
"object you wish to use, and then all your models will extend it:"
msgstr ""

#: ../../peewee/database.rst:71
msgid ""
"Remember to specify a database on your model classes, otherwise peewee "
"will fall back to a default sqlite database named \"peewee.db\"."
msgstr ""

#: ../../peewee/database.rst:77
msgid "Vendor-specific Parameters"
msgstr ""

#: ../../peewee/database.rst:79
msgid ""
"Some database drivers accept special parameters when being initialized. "
"Rather than try to accommodate all these parameters, Peewee will pass "
"back unrecognized parameters directly to the database driver."
msgstr ""

#: ../../peewee/database.rst:81
msgid ""
"For instance, with Postgresql it is common to need to specify the "
"``host``, ``user`` and ``password`` when creating your connection. These "
"are not standard Peewee :py:class:`Database` parameters, so they will be "
"passed directly back to ``psycopg2`` when creating connections:"
msgstr ""

#: ../../peewee/database.rst:92
msgid ""
"As another example, the ``pymysql`` driver accepts a ``charset`` "
"parameter which is not a standard Peewee :py:class:`Database` parameter. "
"To set this value, simply pass in ``charset`` alongside your other "
"values:"
msgstr ""

#: ../../peewee/database.rst:98
msgid "Consult your database driver's documentation for the available parameters:"
msgstr ""

#: ../../peewee/database.rst:100
msgid ""
"Postgres: `psycopg2 "
"<http://initd.org/psycopg/docs/module.html#psycopg2.connect>`_"
msgstr ""

#: ../../peewee/database.rst:101
msgid ""
"MySQL: `MySQLdb <http://mysql-python.sourceforge.net/MySQLdb.html#some-"
"mysql-examples>`_"
msgstr ""

#: ../../peewee/database.rst:102
msgid ""
"MySQL: `pymysql "
"<https://github.com/PyMySQL/PyMySQL/blob/f08f01fe8a59e8acfb5f5add4a8fe874bec2a196/pymysql/connections.py#L494-L513>`_"
msgstr ""

#: ../../peewee/database.rst:103
msgid ""
"SQLite: `sqlite3 "
"<https://docs.python.org/2/library/sqlite3.html#sqlite3.connect>`_"
msgstr ""

#: ../../peewee/database.rst:108
msgid "Using Postgresql"
msgstr "Postgresqlの使用"

#: ../../peewee/database.rst:110
msgid ""
"To connect to a Postgresql database, we will use "
":py:class:`PostgresqlDatabase`. The first parameter is always the name of"
" the database, and after that you can specify arbitrary `psycopg2 "
"parameters "
"<http://initd.org/psycopg/docs/module.html#psycopg2.connect>`_."
msgstr ""

#: ../../peewee/database.rst:124
msgid ""
"The :ref:`playhouse` contains a :ref:`Postgresql extension module "
"<postgres_ext>` which provides many postgres-specific features such as:"
msgstr ""

#: ../../peewee/database.rst:126
msgid ":ref:`Arrays <pgarrays>`"
msgstr ""

#: ../../peewee/database.rst:127
msgid ":ref:`HStore <hstore>`"
msgstr ""

#: ../../peewee/database.rst:128
msgid ":ref:`JSON <pgjson>`"
msgstr ""

#: ../../peewee/database.rst:129
msgid ":ref:`Server-side cursors <server_side_cursors>`"
msgstr ""

#: ../../peewee/database.rst:130 ../../peewee/database.rst:165
msgid "And more!"
msgstr ""

#: ../../peewee/database.rst:132
msgid ""
"If you would like to use these awesome features, use the "
":py:class:`PostgresqlExtDatabase` from the ``playhouse.postgres_ext`` "
"module:"
msgstr ""

#: ../../peewee/database.rst:143
msgid "Using SQLite"
msgstr "SQLiteの使用"

#: ../../peewee/database.rst:145
msgid ""
"To connect to a SQLite database, we will use :py:class:`SqliteDatabase`. "
"The first parameter is the filename containing the database, or the "
"string *:memory:* to create an in-memory database. After the database "
"filename, you can specify arbitrary `sqlite3 parameters "
"<https://docs.python.org/2/library/sqlite3.html#sqlite3.connect>`_."
msgstr ""

#: ../../peewee/database.rst:160
msgid ""
"The :ref:`playhouse` contains a :ref:`SQLite extension module "
"<sqlite_ext>` which provides many SQLite-specific features such as:"
msgstr ""

#: ../../peewee/database.rst:162
msgid ""
":ref:`Full-text search <sqlite_fts>` with :ref:`BM25 ranking "
"<sqlite_bm25>`."
msgstr ""

#: ../../peewee/database.rst:163
msgid "Support for custom functions, aggregates and collations"
msgstr ""

#: ../../peewee/database.rst:164
msgid "Advanced transaction support"
msgstr ""

#: ../../peewee/database.rst:167
msgid ""
"If you would like to use these awesome features, use the "
":py:class:`SqliteExtDatabase` from the ``playhouse.sqlite_ext`` module:"
msgstr ""

#: ../../peewee/database.rst:178
msgid "PRAGMA statements"
msgstr ""

#: ../../peewee/database.rst:193
msgid "SQLite and Autocommit"
msgstr ""

#: ../../peewee/database.rst:197
msgid ""
"In version 2.4.5, the default isolation level for SQLite databases is "
"``None``, which equates to *autocommit*. The reason for this change has "
"to do with some idiosyncracies of ``pysqlite`` (or the standard library "
"``sqlite3``)."
msgstr ""

#: ../../peewee/database.rst:199
msgid ""
"If you are using your database in autocommit mode (the default) then you "
"should not need to make any changes to your code."
msgstr ""

#: ../../peewee/database.rst:201
msgid ""
"If you are using ``autocommit=False``, you will need to explicitly call "
":py:meth:`~Database.begin` before executing queries."
msgstr ""

#: ../../peewee/database.rst:204
msgid ""
"This does not apply to code executed within "
":py:meth:`~Database.transaction` or :py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/database.rst:207
msgid ""
"If you are using peewee with autocommit disabled, you must explicitly "
"call :py:meth:`~Database.begin`, otherwise statements **will** be "
"executed in autocommit mode."
msgstr ""

#: ../../peewee/database.rst:231
msgid "APSW, an Advanced SQLite Driver"
msgstr ""

#: ../../peewee/database.rst:233
msgid ""
"Peewee also comes with an alternate SQLite database that uses "
":ref:`apsw`, an advanced Python SQLite driver. More information on APSW "
"can be obtained on the `APSW project website "
"<https://code.google.com/p/apsw/>`_. APSW provides special features like:"
msgstr ""

#: ../../peewee/database.rst:235
msgid "Virtual tables, virtual file-systems, Blob I/O, backups and file control."
msgstr ""

#: ../../peewee/database.rst:236 ../../peewee/playhouse.rst:968
msgid "Connections can be shared across threads without any additional locking."
msgstr ""

#: ../../peewee/database.rst:237 ../../peewee/playhouse.rst:969
msgid "Transactions are managed explicitly by your code."
msgstr ""

#: ../../peewee/database.rst:238
msgid "Unicode is handled *correctly*."
msgstr ""

#: ../../peewee/database.rst:239
msgid "APSW is faster that the standard library sqlite3 module."
msgstr ""

#: ../../peewee/database.rst:240
msgid "Exposes pretty much the entire SQLite C API to your Python app."
msgstr ""

#: ../../peewee/database.rst:242
msgid ""
"If you would like to use APSW, use the :py:class:`APSWDatabase` from the "
"`apsw_ext` module:"
msgstr ""

#: ../../peewee/database.rst:253
msgid "Using BerkeleyDB"
msgstr "BerkeleyBDの使用"

#: ../../peewee/database.rst:255
msgid ""
"The :ref:`playhouse <playhouse>` contains a special extension module for "
"using a :ref:`BerkeleyDB database <berkeleydb>`. BerkeleyDB can be "
"compiled with a SQLite-compatible API, then the python SQLite driver can "
"be compiled to use the Berkeley version of SQLite."
msgstr ""

#: ../../peewee/database.rst:257
msgid ""
"You can find up-to-date `step by step instructions "
"<http://charlesleifer.com/blog/building-the-python-sqlite-driver-for-use-"
"with-berkeleydb/>`_ on my blog for compling the BerkeleyDB + SQLite "
"library, then building a statically-linked `pysqlite "
"<https://github.com/ghaering/pysqlite>`_ that uses the custom sqlite "
"library."
msgstr ""

#: ../../peewee/database.rst:259
msgid ""
"To connect to a BerkeleyDB database, we will use "
":py:class:`BerkeleyDatabase`. Like :py:class:`SqliteDatabase`, the first "
"parameter is the filename containing the database or the string "
"*:memory:* to create an in-memory database."
msgstr ""

#: ../../peewee/database.rst:279
msgid "Using MySQL"
msgstr "MySQLの使用"

#: ../../peewee/database.rst:281
msgid ""
"To connect to a MySQL database, we will use :py:class:`MySQLDatabase`. "
"After the database name, you can specify arbitrary connection parameters "
"that will be passed back to the driver (either MySQLdb or pymysql)."
msgstr ""

#: ../../peewee/database.rst:297
msgid "Error 2006: MySQL server has gone away"
msgstr ""

#: ../../peewee/database.rst:299
msgid ""
"This particular error can occur when MySQL kills an idle database "
"connection. This typically happens with web apps that do not explicitly "
"manage database connections. What happens is your application starts, a "
"connection is opened to handle the first query that executes, and, since "
"that connection is never closed, it remains open, waiting for more "
"queries."
msgstr ""

#: ../../peewee/database.rst:301
msgid ""
"To fix this, make sure you are explicitly connecting to the database when"
" you need to execute queries, and close your connection when you are "
"done. In a web-application, this typically means you will open a "
"connection when a request comes in, and close the connection when you "
"return a response."
msgstr ""

#: ../../peewee/database.rst:303
msgid "See the :ref:`adding_request_hooks` for more information."
msgstr ""

#: ../../peewee/database.rst:305
msgid ""
"If you would like to automatically reconnect and retry queries that fail "
"due to an ``OperationalError``, peewee provides a :py:class:`Database` "
"mixin :py:class:`RetryOperationalError` that will handle reconnecting and"
" retrying the query automatically. For more information see :ref"
":`automatic-reconnect`."
msgstr ""

#: ../../peewee/database.rst:309
msgid "Connecting using a Database URL"
msgstr "データベースのURLを使用した接続"

#: ../../peewee/database.rst:311
msgid ""
"The playhouse module :ref:`db_url` provides a helper :py:func:`connect` "
"function that accepts a database URL and returns a :py:class:`Database` "
"instance."
msgstr ""

#: ../../peewee/database.rst:330
msgid "Example database URLs:"
msgstr ""

#: ../../peewee/database.rst:332 ../../peewee/playhouse.rst:3704
msgid ""
"*sqlite:///my_database.db* will create a :py:class:`SqliteDatabase` "
"instance for the file ``my_database.db`` in the current directory."
msgstr ""

#: ../../peewee/database.rst:333 ../../peewee/playhouse.rst:3705
msgid ""
"*sqlite:///:memory:* will create an in-memory :py:class:`SqliteDatabase` "
"instance."
msgstr ""

#: ../../peewee/database.rst:334 ../../peewee/playhouse.rst:3706
msgid ""
"*postgresql://postgres:my_password@localhost:5432/my_database* will "
"create a :py:class:`PostgresqlDatabase` instance. A username and password"
" are provided, as well as the host and port to connect to."
msgstr ""

#: ../../peewee/database.rst:335 ../../peewee/playhouse.rst:3707
msgid ""
"*mysql://user:passwd@ip:port/my_db* will create a "
":py:class:`MySQLDatabase` instance for the local MySQL database *my_db*."
msgstr ""

#: ../../peewee/database.rst:336
msgid ":ref:`More examples in the db_url documentation <db_url>`."
msgstr ""

#: ../../peewee/database.rst:339
msgid "Multi-threaded applications"
msgstr "マルチスレッドアプリケーション"

#: ../../peewee/database.rst:341
msgid ""
"peewee stores the connection state in a thread local, so each thread gets"
" its own separate connection. If you prefer to manage the connections "
"yourself, you can disable this behavior by initializing your database "
"with ``threadlocals=False``."
msgstr ""

#: ../../peewee/database.rst:346
msgid "Run-time database configuration"
msgstr "実行時のデータベース設定"

#: ../../peewee/database.rst:348
msgid ""
"Sometimes the database connection settings are not known until run-time, "
"when these values may be loaded from a configuration file or the "
"environment. In these cases, you can *defer* the initialization of the "
"database by specifying ``None`` as the database_name."
msgstr ""

#: ../../peewee/database.rst:358
msgid ""
"If you try to connect or issue any queries while your database is "
"uninitialized you will get an exception:"
msgstr ""

#: ../../peewee/database.rst:365
msgid ""
"To initialize your database, call the :py:meth:`~Database.init` method "
"with the database name and any additional keyword arguments:"
msgstr ""

#: ../../peewee/database.rst:372
msgid ""
"For even more control over initializing your database, see the next "
"section, :ref:`dynamic_db`."
msgstr ""

#: ../../peewee/database.rst:377
msgid "Dynamically defining a database"
msgstr "データベースの動的定義"

#: ../../peewee/database.rst:379
msgid ""
"For even more control over how your database is defined/initialized, you "
"can use the :py:class:`Proxy` helper. :py:class:`Proxy` objects act as a "
"placeholder, and then at run-time you can swap it out for a different "
"object. In the example below, we will swap out the database depending on "
"how the app is configured:"
msgstr ""

#: ../../peewee/database.rst:404
msgid ""
"Only use this method if your actual database driver varies at run-time. "
"For instance, if your tests and local dev environment run on SQLite, but "
"your deployed app uses PostgreSQL, you can use the :py:class:`Proxy` to "
"swap out engines at run-time."
msgstr ""

#: ../../peewee/database.rst:406
msgid ""
"However, if it is only connection values that vary at run-time, such as "
"the path to the database file, or the database host, you should instead "
"use :py:meth:`Database.init`. See :ref:`deferring_initialization` for "
"more details."
msgstr ""

#: ../../peewee/database.rst:411
msgid "Connection Pooling"
msgstr "接続のプーリング"

#: ../../peewee/database.rst:413
msgid ""
"Connection pooling is provided by the :ref:`pool module <pool>`, included"
" in the :ref:`playhouse` extensions library. The pool supports:"
msgstr ""

#: ../../peewee/database.rst:415
msgid "Timeout after which connections will be recycled."
msgstr ""

#: ../../peewee/database.rst:416
msgid "Upper bound on the number of open connections."
msgstr ""

#: ../../peewee/database.rst:418
msgid ""
"The connection pool module comes with support for Postgres and MySQL "
"(though adding support for other databases is trivial)."
msgstr ""

#: ../../peewee/database.rst:434
msgid "The following pooled database classes are available:"
msgstr ""

#: ../../peewee/database.rst:436
msgid ":py:class:`PooledPostgresqlDatabase`"
msgstr ""

#: ../../peewee/database.rst:437
msgid ":py:class:`PooledPostgresqlExtDatabase`"
msgstr ""

#: ../../peewee/database.rst:438
msgid ":py:class:`PooledMySQLDatabase`"
msgstr ""

#: ../../peewee/database.rst:439
msgid ":py:class:`PooledSqliteDatabase`"
msgstr ""

#: ../../peewee/database.rst:440
msgid ":py:class:`PooledSqliteExtDatabase`"
msgstr ""

#: ../../peewee/database.rst:442
msgid ""
"For an in-depth discussion of peewee's connection pool, see the "
":ref:`pool` section of the :ref:`playhouse` documentation."
msgstr ""

#: ../../peewee/database.rst:447 ../../peewee/playhouse.rst:3939
msgid "Read Slaves"
msgstr "スレーブを読み込む"

#: ../../peewee/database.rst:449
msgid ""
"Peewee can automatically run *SELECT* queries against one or more read "
"replicas. The :ref:`read_slave module <read_slaves>`, included in the "
":ref:`playhouse` extensions library, contains a :py:class:`Model` "
"subclass which provides this behavior."
msgstr ""

#: ../../peewee/database.rst:451
msgid "Here is how you might use the :py:class:`ReadSlaveModel`:"
msgstr ""

#: ../../peewee/database.rst:471
msgid ""
"Now when you execute writes (or deletes), they will be run on the master,"
" while all read-only queries will be executed against one of the "
"replicas. Queries are dispatched among the read slaves in round-robin "
"fashion."
msgstr ""

#: ../../peewee/database.rst:474
msgid "Schema migrations"
msgstr "スキーママイグレーション"

#: ../../peewee/database.rst:476
msgid ""
"Currently peewee does not have support for *automatic* schema migrations,"
" but you can use the :ref:`migrate` module to create simple migration "
"scripts. The schema migrations module works with SQLite, MySQL and "
"Postgres, and will even allow you to do things like drop or rename "
"columns in SQLite!"
msgstr ""

#: ../../peewee/database.rst:478
msgid "Here is an example of how you might write a migration script:"
msgstr ""

#: ../../peewee/database.rst:497
msgid "Check the :ref:`migrate` documentation for more details."
msgstr ""

#: ../../peewee/database.rst:500
msgid "Generating Models from Existing Databases"
msgstr "既存データベースからモデル生成"

#: ../../peewee/database.rst:502
msgid ""
"If you'd like to generate peewee model definitions for an existing "
"database, you can try out the database introspection tool :ref:`pwiz` "
"that comes with peewee. *pwiz* is capable of introspecting Postgresql, "
"MySQL and SQLite databases."
msgstr ""

#: ../../peewee/database.rst:504
msgid "Introspecting a Postgresql database:"
msgstr ""

#: ../../peewee/database.rst:510
msgid "Introspecting a SQLite database:"
msgstr ""

#: ../../peewee/database.rst:516
msgid "pwiz will generate:"
msgstr ""

#: ../../peewee/database.rst:518
msgid "Database connection object"
msgstr ""

#: ../../peewee/database.rst:519
msgid "A *BaseModel* class to use with the database"
msgstr ""

#: ../../peewee/database.rst:520
msgid "*Model* classes for each table in the database."
msgstr ""

#: ../../peewee/database.rst:522
msgid ""
"The generated code is written to stdout, and can easily be redirected to "
"a file:"
msgstr ""

#: ../../peewee/database.rst:529
msgid ""
"pwiz generally works quite well with even large and complex database "
"schemas, but in some cases it will not be able to introspect a column. "
"You may need to go through the generated code to add indexes, fix "
"unrecognized column types, and resolve any circular references that were "
"found."
msgstr ""

#: ../../peewee/database.rst:537
msgid "Adding Request Hooks"
msgstr "リクエストフックの追加"

#: ../../peewee/database.rst:539
msgid ""
"When building web-applications, it is very important that you manage your"
" database connections correctly. In this section I will describe how to "
"add hooks to your web app to ensure the database connection is handled "
"properly."
msgstr ""

#: ../../peewee/database.rst:541
msgid ""
"These steps will ensure that regardless of whether you're using a simple "
"SQLite database, or a pool of multiple Postgres connections, peewee will "
"handle the connections correctly."
msgstr ""

#: ../../peewee/database.rst:544
msgid "Flask"
msgstr ""

#: ../../peewee/database.rst:546
msgid ""
"Flask and peewee are a great combo and my go-to for projects of any size."
" Flask provides two hooks which we will use to open and close our db "
"connection. We'll open the connection when a request is received, then "
"close it when the response is returned."
msgstr ""

#: ../../peewee/database.rst:570
msgid "Django"
msgstr ""

#: ../../peewee/database.rst:572
msgid ""
"While it's less common to see peewee used with Django, it is actually "
"very easy to use the two. To manage your peewee database connections with"
" Django, the easiest way in my opinion is to add a middleware to your "
"app. The middleware should be the very first in the list of middlewares, "
"to ensure it runs first when a request is handled, and last when the "
"response is returned."
msgstr ""

#: ../../peewee/database.rst:574
msgid ""
"If you have a django project named *my_blog* and your peewee database is "
"defined in the module ``my_blog.db``, you might add the following "
"middleware class:"
msgstr ""

#: ../../peewee/database.rst:591
msgid ""
"To ensure this middleware gets executed, add it to your ``settings`` "
"module:"
msgstr ""

#: ../../peewee/database.rst:612
msgid "Bottle"
msgstr ""

#: ../../peewee/database.rst:614
msgid ""
"I haven't used bottle myself, but looking at the documentation I believe "
"the following code should ensure the database connections are properly "
"managed:"
msgstr ""

#: ../../peewee/database.rst:636
msgid "Web.py"
msgstr ""

#: ../../peewee/database.rst:638
msgid ""
"See `application processors "
"<http://webpy.org/cookbook/application_processors>`_."
msgstr ""

#: ../../peewee/database.rst:655
msgid "Tornado"
msgstr ""

#: ../../peewee/database.rst:657
msgid ""
"It looks like Tornado's ``RequestHandler`` class implements two hooks "
"which can be used to open and close connections when a request is "
"handled."
msgstr ""

#: ../../peewee/database.rst:675
msgid ""
"In your app, instead of extending the default ``RequestHandler``, now you"
" can extend ``PeeweeRequestHandler``."
msgstr ""

#: ../../peewee/database.rst:677
msgid ""
"Note that this does not address how to use peewee asynchronously with "
"Tornado or another event loop."
msgstr ""

#: ../../peewee/database.rst:680
msgid "Wheezy.web"
msgstr ""

#: ../../peewee/database.rst:682
msgid ""
"The connection handling code can be placed in a `middleware "
"<https://pythonhosted.org/wheezy.http/userguide.html#middleware>`_."
msgstr ""

#: ../../peewee/database.rst:700
msgid "Thanks to GitHub user *@tuukkamustonen* for submitting this code."
msgstr ""

#: ../../peewee/database.rst:703
msgid "Falcon"
msgstr ""

#: ../../peewee/database.rst:705
msgid ""
"The connection handling code can be placed in a `middleware component "
"<https://falcon.readthedocs.io/en/stable/api/middleware.html>`_."
msgstr ""

#: ../../peewee/database.rst:728
msgid "Pyramid"
msgstr ""

#: ../../peewee/database.rst:730
msgid ""
"Set up a Request factory that handles database connection lifetime as "
"follows:"
msgstr ""

#: ../../peewee/database.rst:748
msgid ""
"In your application `main()` make sure `MyRequest` is used as "
"`request_factory`:"
msgstr ""

#: ../../peewee/database.rst:757
msgid "Other frameworks"
msgstr ""

#: ../../peewee/database.rst:759
msgid ""
"Don't see your framework here? Please `open a GitHub ticket "
"<https://github.com/coleifer/peewee/issues/new>`_ and I'll see about "
"adding a section, or better yet, submit a documentation pull-request."
msgstr ""

#: ../../peewee/database.rst:762
msgid "Additional connection initialization"
msgstr "追加接続の初期化"

#: ../../peewee/database.rst:764
msgid ""
"Peewee does a few basic things depending on your database to initialize a"
" connection. For SQLite this means registering custom user-defined "
"functions, for Postgresql this means registering unicode support."
msgstr ""

#: ../../peewee/database.rst:766
msgid ""
"You may find it necessary to add additional initialization when a new "
"connection is opened, however. For example you may want to tell SQLite to"
" enforce all foreign key constraints (off by default). To do this, you "
"can subclass the database and override the "
":py:meth:`~Database.initialize_connection` method."
msgstr ""

#: ../../peewee/database.rst:768
msgid ""
"This method contains no implementation on the base database classes, so "
"you do not need to call ``super()`` with it."
msgstr ""

#: ../../peewee/database.rst:770
msgid "Example turning on SQLite foreign keys:"
msgstr ""

#: ../../peewee/database.rst:781
msgid "Advanced Connection Management"
msgstr "高度な接続管理"

#: ../../peewee/database.rst:783
msgid ""
"Managing your database connections is as simple as calling "
":py:meth:`~Database.connect` when you need to open a connection, and "
":py:meth:`~Database.close` when you are finished. In a web-app, you would"
" typically connect when you receive a request, and close the connection "
"when you return a response. Because connection state is stored in a "
"thread-local, you do not need to worry about juggling connection objects "
"-- peewee will handle it for you."
msgstr ""

#: ../../peewee/database.rst:785
msgid ""
"In some situations, however, you may want to manage your connections more"
" explicitly. Since peewee stores the active connection in a threadlocal, "
"this typically would mean that there could only ever be one connection "
"open per thread. For most applications this is desirable, but if you "
"would like to manually manage multiple connections you can create an "
":py:class:`ExecutionContext`."
msgstr ""

#: ../../peewee/database.rst:787
msgid ""
"Execution contexts allow finer-grained control over managing multiple "
"connections to the database. When an execution context is initialized "
"(either as a context manager or as a decorated function), a separate "
"connection will be used for the duration of the wrapped block. You can "
"also choose whether to wrap the block in a transaction."
msgstr ""

#: ../../peewee/database.rst:789
msgid "Execution context examples:"
msgstr ""

#: ../../peewee/database.rst:807
msgid ""
"If you are using the peewee connection pool, then the new connections "
"used by the :py:class:`ExecutionContext` will be pulled from the pool of "
"available connections and recycled appropriately."
msgstr ""

#: ../../peewee/database.rst:810
msgid "Using multiple databases"
msgstr "複数データベースの使用"

#: ../../peewee/database.rst:812
msgid ""
"With peewee you can use as many databases as you want. Each model can "
"define it's database by specifying a :ref:`Meta.database <model-"
"options>`. What if you want to use the same model with multiple "
"databases, though? Depending on your use-case, peewee provides several "
"options."
msgstr ""

#: ../../peewee/database.rst:814
msgid ""
"If you have a Master/Slave setup and want all writes to go to the master,"
" but reads can go to any number of replicated copies, check out the "
":ref:`Read Slave extension <read_slaves>`."
msgstr ""

#: ../../peewee/database.rst:816
msgid ""
"For finer-grained control, check out the :py:class:`Using` context "
"manager / decorator. This allows you to specify the database to use with "
"a given list of models for the duration of the wrapped block."
msgstr ""

#: ../../peewee/database.rst:818
msgid ""
"Here is an example of how you might use the :py:class:`Using` context "
"manager:"
msgstr ""

#: ../../peewee/database.rst:846
msgid ""
"For simple master/slave configurations, check out the :ref:`read_slaves` "
"extension. This extension ensures writes are sent to the master database "
"and reads occur from any of the listed read replicas."
msgstr ""

#: ../../peewee/database.rst:851
msgid "Database Errors"
msgstr "データベースエラー"

#: ../../peewee/database.rst:853
msgid ""
"The Python DB-API 2.0 spec describes `several types of exceptions "
"<https://www.python.org/dev/peps/pep-0249/#exceptions>`_. Because most "
"database drivers have their own implementations of these exceptions, "
"Peewee simplifies things by providing its own wrappers around any "
"implementation-specific exception classes. That way, you don't need to "
"worry about importing any special exception classes, you can just use the"
" ones from peewee:"
msgstr ""

#: ../../peewee/database.rst:855
msgid "``DatabaseError``"
msgstr ""

#: ../../peewee/database.rst:856
msgid "``DataError``"
msgstr ""

#: ../../peewee/database.rst:857
msgid "``IntegrityError``"
msgstr ""

#: ../../peewee/database.rst:858
msgid "``InterfaceError``"
msgstr ""

#: ../../peewee/database.rst:859
msgid "``InternalError``"
msgstr ""

#: ../../peewee/database.rst:860
msgid "``NotSupportedError``"
msgstr ""

#: ../../peewee/database.rst:861
msgid "``OperationalError``"
msgstr ""

#: ../../peewee/database.rst:862
msgid "``ProgrammingError``"
msgstr ""

#: ../../peewee/database.rst:864
msgid "All of these error classes extend ``PeeweeException``."
msgstr ""

#: ../../peewee/database.rst:869
msgid "Automatic Reconnect"
msgstr "自動再接続"

#: ../../peewee/database.rst:871
msgid ""
"Peewee provides very basic support for automatic reconnecting in the "
":ref:`shortcuts` module, through the use of the "
":py:class:`RetryOperationalError` mixin. This mixin will automatically "
"reconnect to the database and retry any queries that fail with an "
"``OperationalError``. The query that failed will be retried only once, "
"and if it fails twice an exception will be raised."
msgstr ""

#: ../../peewee/database.rst:888
msgid "Logging queries"
msgstr "クエリのロギング"

#: ../../peewee/database.rst:890
msgid ""
"All queries are logged to the *peewee* namespace using the standard "
"library ``logging`` module. Queries are logged using the *DEBUG* level.  "
"If you're interested in doing something with the queries, you can simply "
"register a handler."
msgstr ""

#: ../../peewee/database.rst:901
msgid "Generating skeleton code"
msgstr "スケルトンコードの生成"

#: ../../peewee/database.rst:903
msgid ""
"For writing quick scripts, peewee comes with a helper script :ref:`pskel`"
" which generates database connection and model boilerplate code. If you "
"find yourself frequently writing small programs, :ref:`pskel` can really "
"save you time."
msgstr ""

#: ../../peewee/database.rst:905
msgid "To generate a script, you can simply run:"
msgstr ""

#: ../../peewee/database.rst:911
msgid ""
"``pskel`` will generate code to connect to an in-memory SQLite database, "
"as well as blank model definitions for the model names specified on the "
"command line."
msgstr ""

#: ../../peewee/database.rst:913
msgid ""
"Here is a more complete example, which will use the "
":py:class:`PostgresqlExtDatabase` with query logging enabled:"
msgstr ""

#: ../../peewee/database.rst:919
msgid "You can now fill in the model definitions and get to hacking!"
msgstr ""

#: ../../peewee/database.rst:922
msgid "Adding a new Database Driver"
msgstr "新しいデータベースドライバーの追加"

#: ../../peewee/database.rst:924
msgid ""
"Peewee comes with built-in support for Postgres, MySQL and SQLite. These "
"databases are very popular and run the gamut from fast, embeddable "
"databases to heavyweight servers suitable for large-scale deployments.  "
"That being said, there are a ton of cool databases out there and adding "
"support for your database-of-choice should be really easy, provided the "
"driver supports the `DB-API 2.0 spec "
"<http://www.python.org/dev/peps/pep-0249/>`_."
msgstr ""

#: ../../peewee/database.rst:926
msgid ""
"The db-api 2.0 spec should be familiar to you if you've used the standard"
" library sqlite3 driver, psycopg2 or the like. Peewee currently relies on"
" a handful of parts:"
msgstr ""

#: ../../peewee/database.rst:928
msgid "`Connection.commit`"
msgstr ""

#: ../../peewee/database.rst:929
msgid "`Connection.execute`"
msgstr ""

#: ../../peewee/database.rst:930
msgid "`Connection.rollback`"
msgstr ""

#: ../../peewee/database.rst:931
msgid "`Cursor.description`"
msgstr ""

#: ../../peewee/database.rst:932
msgid "`Cursor.fetchone`"
msgstr ""

#: ../../peewee/database.rst:934
msgid ""
"These methods are generally wrapped up in higher-level abstractions and "
"exposed by the :py:class:`Database`, so even if your driver doesn't do "
"these exactly you can still get a lot of mileage out of peewee.  An "
"example is the `apsw sqlite driver <http://code.google.com/p/apsw/>`_ in "
"the \"playhouse\" module."
msgstr ""

#: ../../peewee/database.rst:936
msgid ""
"The first thing is to provide a subclass of :py:class:`Database` that "
"will open a connection."
msgstr ""

#: ../../peewee/database.rst:948
msgid ""
"The :py:class:`Database` provides a higher-level API and is responsible "
"for executing queries, creating tables and indexes, and introspecting the"
" database to get lists of tables. The above implementation is the "
"absolute minimum needed, though some features will not work -- for best "
"results you will want to additionally add a method for extracting a list "
"of tables and indexes for a table from the database.  We'll pretend that "
"``FooDB`` is a lot like MySQL and has special \"SHOW\" statements:"
msgstr ""

#: ../../peewee/database.rst:960
msgid "Other things the database handles that are not covered here include:"
msgstr ""

#: ../../peewee/database.rst:962
msgid ":py:meth:`~Database.last_insert_id` and :py:meth:`~Database.rows_affected`"
msgstr ""

#: ../../peewee/database.rst:963
msgid ":py:attr:`~Database.interpolation` and :py:attr:`~Database.quote_char`"
msgstr ""

#: ../../peewee/database.rst:964
msgid ""
":py:attr:`~Database.op_overrides` for mapping operations such as "
"\"LIKE/ILIKE\" to their database equivalent"
msgstr ""

#: ../../peewee/database.rst:966
msgid ""
"Refer to the :py:class:`Database` API reference or the `source code "
"<https://github.com/coleifer/peewee/blob/master/peewee.py>`_. for "
"details."
msgstr ""

#: ../../peewee/database.rst:968
msgid ""
"If your driver conforms to the DB-API 2.0 spec, there shouldn't be much "
"work needed to get up and running."
msgstr ""

#: ../../peewee/database.rst:970
msgid ""
"Our new database can be used just like any of the other database "
"subclasses:"
msgstr ""

#: ../../peewee/example.rst:4
msgid "Example app"
msgstr "サンプル・アプリケーション"

#: ../../peewee/example.rst:6
msgid ""
"We'll be building a simple *twitter*-like site. The source code for the "
"example can be found in the ``examples/twitter`` directory. You can also "
"`browse the source-code "
"<https://github.com/coleifer/peewee/tree/master/examples/twitter>`_ on "
"github. There is also an example `blog app "
"<https://github.com/coleifer/peewee/tree/master/examples/blog>`_ if "
"that's more to your liking."
msgstr ""

#: ../../peewee/example.rst:8
msgid ""
"The example app uses the `flask <http://flask.pocoo.org/>`_ web framework"
" which is very easy to get started with. If you don't have flask already,"
" you will need to install it to run the example:"
msgstr ""

#: ../../peewee/example.rst:15
msgid "Running the example"
msgstr "サンプルの実行"

#: ../../peewee/example.rst:19
msgid ""
"After ensuring that flask is installed, ``cd`` into the twitter example "
"directory and execute the ``run_example.py`` script:"
msgstr ""

#: ../../peewee/example.rst:25
msgid "The example app will be accessible at http://localhost:5000/"
msgstr ""

#: ../../peewee/example.rst:28
msgid "Diving into the code"
msgstr "コードへの潜入"

#: ../../peewee/example.rst:30
msgid ""
"For simplicity all example code is contained within a single module, "
"``examples/twitter/app.py``. For a guide on structuring larger Flask apps"
" with peewee, check out `Structuring Flask Apps "
"<http://charlesleifer.com/blog/structuring-flask-apps-a-how-to-for-those-"
"coming-from-django/>`_."
msgstr ""

#: ../../peewee/example.rst:37
msgid ""
"In the spirit of the popular web framework Django, peewee uses "
"declarative model definitions. If you're not familiar with Django, the "
"idea is that you declare a model class for each table. The model class "
"then defines one or more field attributes which correspond to the table's"
" columns. For the twitter clone, there are just three models:"
msgstr ""

#: ../../peewee/example.rst:42
msgid "*User*:"
msgstr ""

#: ../../peewee/example.rst:40
msgid ""
"Represents a user account and stores the username and password, an email "
"address for generating avatars using *gravatar*, and a datetime field "
"indicating when that account was created."
msgstr ""

#: ../../peewee/example.rst:46
msgid "*Relationship*:"
msgstr ""

#: ../../peewee/example.rst:45
msgid ""
"This is a utility model that contains two foreign-keys to the *User* "
"model and stores which users follow one another."
msgstr ""

#: ../../peewee/example.rst:50
msgid "*Message*:"
msgstr ""

#: ../../peewee/example.rst:49
msgid ""
"Analagous to a tweet. The Message model stores the text content of the "
"tweet, when it was created, and who posted it (foreign key to User)."
msgstr ""

#: ../../peewee/example.rst:52
msgid "If you like UML, these are the tables and relationships:"
msgstr ""

#: ../../peewee/example.rst:56
msgid ""
"In order to create these models we need to instantiate a "
":py:class:`SqliteDatabase` object. Then we define our model classes, "
"specifying the columns as :py:class:`Field` instances on the class."
msgstr ""

#: ../../peewee/example.rst:107
msgid ""
"Note that we create a *BaseModel* class that simply defines what database"
" we would like to use.  All other models then extend this class and will "
"also use the correct database connection."
msgstr ""

#: ../../peewee/example.rst:112
msgid ""
"Peewee supports many different :ref:`field types <fields>` which map to "
"different column types commonly supported by database engines.  "
"Conversion between python types and those used in the database is handled"
" transparently, allowing you to use the following in your application:"
msgstr ""

#: ../../peewee/example.rst:114
msgid "Strings (unicode or otherwise)"
msgstr ""

#: ../../peewee/example.rst:115
msgid "Integers, floats, and ``Decimal`` numbers."
msgstr ""

#: ../../peewee/example.rst:116
msgid "Boolean values"
msgstr ""

#: ../../peewee/example.rst:117
msgid "Dates, times and datetimes"
msgstr ""

#: ../../peewee/example.rst:118
msgid "``None`` (NULL)"
msgstr ""

#: ../../peewee/example.rst:119
msgid "Binary data"
msgstr ""

#: ../../peewee/example.rst:122
msgid "Creating tables"
msgstr ""

#: ../../peewee/example.rst:124
msgid ""
"In order to start using the models, its necessary to create the tables. "
"This is a one-time operation and can be done quickly using the "
"interactive interpreter. We can create a small helper function to "
"accomplish this:"
msgstr ""

#: ../../peewee/example.rst:132
msgid ""
"Open a python shell in the directory alongside the example app and "
"execute the following:"
msgstr ""

#: ../../peewee/example.rst:141
msgid ""
"If you encounter an *ImportError* it means that either *flask* or "
"*peewee* was not found and may not be installed correctly. Check the "
":ref:`installation` document for instructions on installing peewee."
msgstr ""

#: ../../peewee/example.rst:145
msgid ""
"Every model has a :py:meth:`~Model.create_table` classmethod which runs a"
" SQL *CREATE TABLE* statement in the database. This method will create "
"the table, including all columns, foreign-key constraints, indexes, and "
"sequences. Usually this is something you'll only do once, whenever a new "
"model is added."
msgstr ""

#: ../../peewee/example.rst:147
msgid ""
"Peewee provides a helper method :py:meth:`Database.create_tables` which "
"will resolve inter-model dependencies and call "
":py:meth:`~Model.create_table` on each model."
msgstr ""

#: ../../peewee/example.rst:150
msgid ""
"Adding fields after the table has been created will required you to "
"either drop the table and re-create it or manually add the columns using "
"an *ALTER TABLE* query."
msgstr ""

#: ../../peewee/example.rst:154
msgid ""
"Alternatively, you can use the :ref:`schema migrations <migrate>` "
"extension to alter your database schema using Python."
msgstr ""

#: ../../peewee/example.rst:158
msgid ""
"You can also write ``database.create_tables([User, ...], True)`` and "
"peewee will first check to see if the table exists before creating it."
msgstr ""

#: ../../peewee/example.rst:161
msgid "Establishing a database connection"
msgstr ""

#: ../../peewee/example.rst:163
msgid ""
"You may have noticed in the above model code that there is a class "
"defined on the base model named *Meta* that sets the ``database`` "
"attribute. Peewee allows every model to specify which database it uses. "
"There are many :ref:`Meta options <model-options>` you can specify which "
"control the behavior of your model."
msgstr ""

#: ../../peewee/example.rst:165
msgid "This is a peewee idiom:"
msgstr ""

#: ../../peewee/example.rst:175
msgid ""
"When developing a web application, it's common to open a connection when "
"a request starts, and close it when the response is returned. **You "
"should always manage your connections explicitly**. For instance, if you "
"are using a :ref:`connection pool <pool>`, connections will only be "
"recycled correctly if you call :py:meth:`~Database.connect` and "
":py:meth:`~Database.close`."
msgstr ""

#: ../../peewee/example.rst:177
msgid ""
"We will tell flask that during the request/response cycle we need to "
"create a connection to the database. Flask provides some handy decorators"
" to make this a snap:"
msgstr ""

#: ../../peewee/example.rst:191
msgid ""
"Peewee uses thread local storage to manage connection state, so this "
"pattern can be used with multi-threaded WSGI servers."
msgstr ""

#: ../../peewee/example.rst:195
msgid "Making queries"
msgstr ""

#: ../../peewee/example.rst:197
msgid ""
"In the *User* model there are a few instance methods that encapsulate "
"some user-specific functionality:"
msgstr ""

#: ../../peewee/example.rst:199
msgid "``following()``: who is this user following?"
msgstr ""

#: ../../peewee/example.rst:200
msgid "``followers()``: who is following this user?"
msgstr ""

#: ../../peewee/example.rst:202
msgid ""
"These methods are similar in their implementation but with an important "
"difference in the SQL *JOIN* and *WHERE* clauses:"
msgstr ""

#: ../../peewee/example.rst:220
msgid "Creating new objects"
msgstr ""

#: ../../peewee/example.rst:222
msgid ""
"When a new user wants to join the site we need to make sure the username "
"is available, and if so, create a new *User* record. Looking at the "
"*join()* view, we can that our application attempts to create the User "
"using :py:meth:`Model.create`. We defined the *User.username* field with "
"a unique constraint, so if the username is taken the database will raise "
"an ``IntegrityError``."
msgstr ""

#: ../../peewee/example.rst:244
msgid ""
"We will use a similar approach when a user wishes to follow someone. To "
"indicate a following relationship, we create a row in the *Relationship* "
"table pointing from one user to another. Due to the unique index on "
"``from_user`` and ``to_user``, we will be sure not to end up with "
"duplicate rows:"
msgstr ""

#: ../../peewee/example.rst:258
msgid "Performing subqueries"
msgstr ""

#: ../../peewee/example.rst:260
msgid ""
"If you are logged-in and visit the twitter homepage, you will see tweets "
"from the users that you follow. In order to implement this cleanly, we "
"can use a subquery:"
msgstr ""

#: ../../peewee/example.rst:267
msgid "This code corresponds to the following SQL query:"
msgstr ""

#: ../../peewee/example.rst:282
msgid "Other topics of interest"
msgstr ""

#: ../../peewee/example.rst:284
msgid ""
"There are a couple other neat things going on in the example app that are"
" worth mentioning briefly."
msgstr ""

#: ../../peewee/example.rst:286
msgid ""
"Support for paginating lists of results is implemented in a simple "
"function called ``object_list`` (after it's corollary in Django).  This "
"function is used by all the views that return lists of objects."
msgstr ""

#: ../../peewee/example.rst:300
msgid ""
"Simple authentication system with a ``login_required`` decorator.  The "
"first function simply adds user data into the current session when a user"
" successfully logs in.  The decorator ``login_required`` can be used to "
"wrap view functions, checking for whether the session is authenticated "
"and if not redirecting to the login page."
msgstr ""

#: ../../peewee/example.rst:322
msgid ""
"Return a 404 response instead of throwing exceptions when an object is "
"not found in the database."
msgstr ""

#: ../../peewee/example.rst:334
msgid "More examples"
msgstr "より多くの例"

#: ../../peewee/example.rst:336
msgid ""
"There are more examples included in the peewee `examples directory "
"<https://github.com/coleifer/peewee/blob/master/examples/>`_, including:"
msgstr ""

#: ../../peewee/example.rst:338
msgid ""
"`Example blog app "
"<https://github.com/coleifer/peewee/tree/master/examples/blog>`_ using "
"Flask and peewee. Also see `accompanying blog post "
"<http://charlesleifer.com/blog/how-to-make-a-flask-blog-in-one-hour-or-"
"less/>`_."
msgstr ""

#: ../../peewee/example.rst:339
msgid ""
"`An encrypted command-line diary "
"<https://github.com/coleifer/peewee/blob/master/examples/diary.py>`_. "
"There is a `companion blog post <http://charlesleifer.com/blog/dear-"
"diary-an-encrypted-command-line-diary-with-python/>`_ you might enjoy as "
"well."
msgstr ""

#: ../../peewee/example.rst:340
msgid ""
"`Analytics web-service "
"<https://github.com/coleifer/peewee/tree/master/examples/analytics>`_ "
"(like a lite version of Google Analytics). Also check out the `companion "
"blog post <http://charlesleifer.com/blog/saturday-morning-hacks-building-"
"an-analytics-app-with-flask/>`_."
msgstr ""

#: ../../peewee/example.rst:343
msgid ""
"Like these snippets and interested in more?  Check out `flask-peewee "
"<https://github.com/coleifer/flask-peewee>`_ - a flask plugin that "
"provides a django-like Admin interface, RESTful API, Authentication and "
"more for your peewee models."
msgstr ""

#: ../../peewee/hacks.rst:4
msgid "Hacks"
msgstr ""

#: ../../peewee/hacks.rst:6
msgid ""
"Collected hacks using peewee. Have a cool hack you'd like to share? Open "
"`an issue on GitHub <https://github.com/coleifer/peewee/issues/new>`_ or "
"`contact me <http://charlesleifer.com/contact/>`_."
msgstr ""

#: ../../peewee/hacks.rst:11
msgid "Top object per group"
msgstr ""

#: ../../peewee/hacks.rst:13
msgid ""
"These examples describe several ways to query the single top item per "
"group. For a thorough discuss of various techniques, check out my blog "
"post `Querying the top item by group with Peewee ORM "
"<http://charlesleifer.com/blog/techniques-for-querying-lists-of-objects-"
"and-determining-the-top-related-item/>`_. If you are interested in the "
"more general problem of querying the top *N* items, see the section below"
" :ref:`top_n_per_group`."
msgstr ""

#: ../../peewee/hacks.rst:15
msgid ""
"In these examples we will use the *User* and *Tweet* models to find each "
"user and their most-recent tweet."
msgstr ""

#: ../../peewee/hacks.rst:17
msgid ""
"The most efficient method I found in my testing uses the ``MAX()`` "
"aggregate function."
msgstr ""

#: ../../peewee/hacks.rst:19
msgid ""
"We will perform the aggregation in a non-correlated subquery, so we can "
"be confident this method will be performant. The idea is that we will "
"select the posts, grouped by their author, whose timestamp is equal to "
"the max observed timestamp for that user."
msgstr ""

#: ../../peewee/hacks.rst:46
msgid ""
"SQLite and MySQL are a bit more lax and permit grouping by a subset of "
"the columns that are selected. This means we can do away with the "
"subquery and express it quite concisely:"
msgstr ""

#: ../../peewee/hacks.rst:59
msgid "Top N objects per group"
msgstr ""

#: ../../peewee/hacks.rst:61
msgid ""
"These examples describe several ways to query the top *N* items per group"
" reasonably efficiently. For a thorough discussion of various techniques,"
" check out my blog post `Querying the top N objects per group with Peewee"
" ORM <http://charlesleifer.com/blog/querying-the-top-n-objects-per-group-"
"with-peewee-orm/>`_."
msgstr ""

#: ../../peewee/hacks.rst:63
msgid ""
"In these examples we will use the *User* and *Tweet* models to find each "
"user and their three most-recent tweets."
msgstr ""

#: ../../peewee/hacks.rst:66
msgid "Postgres lateral joins"
msgstr ""

#: ../../peewee/hacks.rst:68
msgid ""
"`Lateral joins <http://blog.heapanalytics.com/postgresqls-powerful-new-"
"join-type-lateral/>`_ are a neat Postgres feature that allow reasonably "
"efficient correlated subqueries. They are often described as SQL ``for "
"each`` loops."
msgstr ""

#: ../../peewee/hacks.rst:70 ../../peewee/hacks.rst:123
msgid "The desired SQL is:"
msgstr ""

#: ../../peewee/hacks.rst:83
msgid ""
"To accomplish this with peewee we'll need to express the lateral join as "
"a :py:class:`Clause`, which gives us greater flexibility than the "
":py:meth:`~Query.join` method."
msgstr ""

#: ../../peewee/hacks.rst:119 ../../peewee/querying.rst:784
msgid "Window functions"
msgstr "ウィンドウ関数"

#: ../../peewee/hacks.rst:121
msgid ""
"`Window functions <http://www.postgresql.org/docs/9.1/static/tutorial-"
"window.html>`_, which are :ref:`supported by peewee <window-functions>`, "
"provide scalable, efficient performance."
msgstr ""

#: ../../peewee/hacks.rst:141
msgid ""
"To accomplish this with peewee, we will wrap the ranked Tweets in an "
"outer query that performs the filtering."
msgstr ""

#: ../../peewee/hacks.rst:168
msgid "Other methods"
msgstr ""

#: ../../peewee/hacks.rst:170
msgid ""
"If you're not using Postgres, then unfortunately you're left with options"
" that exhibit less-than-ideal performance. For a more complete overview "
"of common methods, check out `this blog post "
"<http://charlesleifer.com/blog/querying-the-top-n-objects-per-group-with-"
"peewee-orm/>`_. Below I will summarize the approaches and the "
"corresponding SQL."
msgstr ""

#: ../../peewee/hacks.rst:172
msgid ""
"Using ``COUNT``, we can get all tweets where there exist less than *N* "
"tweets with more recent timestamps:"
msgstr ""

#: ../../peewee/hacks.rst:193
msgid ""
"We can achieve similar results by doing a self-join and performing the "
"filtering in the ``HAVING`` clause:"
msgstr ""

#: ../../peewee/hacks.rst:211
msgid "The last example uses a ``LIMIT`` clause in a correlated subquery."
msgstr ""

#: ../../peewee/hacks.rst:233
msgid "Writing custom functions with SQLite"
msgstr ""

#: ../../peewee/hacks.rst:235
msgid ""
"SQLite is very easy to extend with custom functions written in Python, "
"that are then callable from your SQL statements. By using the "
":py:class:`SqliteExtDatabase` and the :py:meth:`~SqliteExtDatabase.func` "
"decorator, you can very easily define your own functions."
msgstr ""

#: ../../peewee/hacks.rst:237
msgid ""
"Here is an example function that generates a hashed version of a user-"
"supplied password. We can also use this to implement ``login`` "
"functionality for matching a user and password."
msgstr ""

#: ../../peewee/hacks.rst:262
msgid ""
"Here is how you can use the function to add a new user, storing a hashed "
"password:"
msgstr ""

#: ../../peewee/hacks.rst:270
msgid ""
"If we retrieve the user from the database, the password that's stored is "
"hashed and salted:"
msgstr ""

#: ../../peewee/hacks.rst:278
msgid ""
"To implement ``login``-type functionality, you could write something like"
" this:"
msgstr ""

#: ../../peewee/installation.rst:4
msgid "Installing and Testing"
msgstr "インストールとテスト"

#: ../../peewee/installation.rst:6
msgid "Most users will want to simply install the latest version, hosted on PyPI:"
msgstr "ほとんどのユーザーはPyPIでホストされている最新バージョンをインストールするだけです:"

#: ../../peewee/installation.rst:12
msgid "Peewee comes with two C extensions that can optionally be compiled:"
msgstr "Peeweeにはオプションでコンパイルできる2つのCエクステンションが付属しています:"

#: ../../peewee/installation.rst:14
msgid ""
"Speedups, which includes miscellaneous functions re-implemented with "
"Cython. This module will be built automatically if Cython is installed."
msgstr "Cythonで再実装されたその他の関数が含まれているSpeedupsモジュール。"
"Cythonがインストールされている場合、このモジュールは自動的に構築されます。"

#: ../../peewee/installation.rst:15
msgid ""
"Sqlite extensions, which includes Cython implementations of the SQLite "
"date manipulation functions, the REGEXP operator, and full-text search "
"result ranking algorithms. This module should be built using the "
"``build_sqlite_ext`` command."
msgstr ""

#: ../../peewee/installation.rst:18
msgid ""
"If you have Cython installed, then the ``speedups`` module will "
"automatically be built. If you wish to also build the SQLite Cython "
"extension, you must manually run:"
msgstr "Cythonがインストールされている場合は、 ``speedups`` モジュールが自動的に構築されます。"
"SQLite Cythonエクステンションをビルドする場合は、手動で実行する必要があります:"

#: ../../peewee/installation.rst:27
msgid "Installing with git"
msgstr "gitでインストールする"

#: ../../peewee/installation.rst:29
msgid ""
"The project is hosted at https://github.com/coleifer/peewee and can be "
"installed using git:"
msgstr "このプロジェクトは https://github.com/coleifer/peewee にホストされていて、"
"gitを使用してインストールできます:"

#: ../../peewee/installation.rst:38
msgid ""
"If you would like to build the SQLite extension in a git checkout, you "
"can run:"
msgstr "git checkoutでSQLite拡張機能をビルドしたい場合は、以下のように実行できます"

#: ../../peewee/installation.rst:46
msgid ""
"On some systems you may need to use ``sudo python setup.py install`` to "
"install peewee system-wide."
msgstr "いくつかのシステムではシステム全体にpeeweeをインストールするために"
"``sudo python setup.py install`` を使用する必要があります。"

#: ../../peewee/installation.rst:49
msgid "Running tests"
msgstr "テストの実行"

#: ../../peewee/installation.rst:51
msgid "You can test your installation by running the test suite."
msgstr "テストスイートを実行してインストールをテストできます。"

#: ../../peewee/installation.rst:60
msgid ""
"You can test specific features or specific database drivers using the "
"``runtests.py`` script. By default the test suite is run using SQLite and"
" the ``playhouse`` extension tests are not run. To view the available "
"test runner options, use:"
msgstr "``runtests.py`` スクリプトを使用して、"
"特定の機能や特定のデータベースドライバをテストすることができます。"
"デフォルトでは、テストスイートはSQLiteを使用して実行され、``playhouse`` エクステンションのテストは実行されません。"
"使用可能なテストランナーのオプションを表示するには、次のコマンドを使用します:"

#: ../../peewee/models.rst:4
msgid "Models and Fields"
msgstr "モデルとフィールド"

#: ../../peewee/models.rst:6
msgid ""
":py:class:`Model` classes, :py:class:`Field` instances and model "
"instances all map to database concepts:"
msgstr ""

#: ../../peewee/models.rst:9 ../../peewee/quickstart.rst:27
msgid "Thing"
msgstr ""

#: ../../peewee/models.rst:9 ../../peewee/quickstart.rst:27
msgid "Corresponds to..."
msgstr ""

#: ../../peewee/models.rst:11 ../../peewee/quickstart.rst:29
msgid "Model class"
msgstr ""

#: ../../peewee/models.rst:11 ../../peewee/quickstart.rst:29
msgid "Database table"
msgstr ""

#: ../../peewee/models.rst:12 ../../peewee/quickstart.rst:30
msgid "Field instance"
msgstr ""

#: ../../peewee/models.rst:12 ../../peewee/quickstart.rst:30
msgid "Column on a table"
msgstr ""

#: ../../peewee/models.rst:13 ../../peewee/quickstart.rst:31
msgid "Model instance"
msgstr ""

#: ../../peewee/models.rst:13 ../../peewee/quickstart.rst:31
msgid "Row in a database table"
msgstr ""

#: ../../peewee/models.rst:16
msgid ""
"The following code shows the typical way you will define your database "
"connection and model classes."
msgstr ""

#: ../../peewee/models.rst:39
msgid "Create an instance of a :py:class:`Database`."
msgstr ""

#: ../../peewee/models.rst:45
msgid ""
"The ``db`` object will be used to manage the connections to the Sqlite "
"database. In this example we're using :py:class:`SqliteDatabase`, but you"
" could also use one of the other :ref:`database engines <databases>`."
msgstr ""

#: ../../peewee/models.rst:47
msgid "Create a base model class which specifies our database."
msgstr "データベースを指定する基本モデルクラスを作成します。"

#: ../../peewee/models.rst:55
msgid ""
"It is good practice to define a base model class which establishes the "
"database connection. This makes your code DRY as you will not have to "
"specify the database for subsequent models."
msgstr "データベース接続を確立する基本モデルクラスを定義することをお勧めします。"
"これにより、後続のモデルにデータベースを指定する必要がないため、DRYなコードになります。"

#: ../../peewee/models.rst:57
msgid ""
"Model configuration is kept namespaced in a special class called "
"``Meta``. This convention is borrowed from Django. :ref:`Meta <model-"
"options>` configuration is passed on to subclasses, so our project's "
"models will all subclass *BaseModel*. There are :ref:`many different "
"attributes <model-options>` you can configure using *Model.Meta*."
msgstr "モデル設定は、 ``Meta`` と呼ばれる特別なクラスに名前空間が維持されます。"
"この慣例はDjangoから借用しています。"
":ref:`Meta <model-options>` 設定はサブクラスに渡されるので、プロジェクトのモデルはすべて *BaseModel* をサブクラス化します。"
"*Model.Meta* を使用して設定できる :ref:`多くの異なる属性 <model-options>` があります。"


#: ../../peewee/models.rst:59
msgid "Define a model class."
msgstr ""

#: ../../peewee/models.rst:66
msgid ""
"Model definition uses the declarative style seen in other popular ORMs "
"like SQLAlchemy or Django. Note that we are extending the *BaseModel* "
"class so the *User* model will inherit the database connection."
msgstr ""

#: ../../peewee/models.rst:68
msgid ""
"We have explicitly defined a single *username* column with a unique "
"constraint. Because we have not specified a primary key, peewee will "
"automatically add an auto-incrementing integer primary key field named "
"*id*."
msgstr ""

#: ../../peewee/models.rst:71
msgid ""
"If you would like to start using peewee with an existing database, you "
"can use :ref:`pwiz` to automatically generate model definitions."
msgstr ""

#: ../../peewee/models.rst:78
msgid ""
"The :py:class:`Field` class is used to describe the mapping of "
":py:class:`Model` attributes to database columns. Each field type has a "
"corresponding SQL storage class (i.e. varchar, int), and conversion "
"between python data types and underlying storage is handled "
"transparently."
msgstr ""

#: ../../peewee/models.rst:80
msgid ""
"When creating a :py:class:`Model` class, fields are defined as class "
"attributes. This should look familiar to users of the django framework. "
"Here's an example:"
msgstr ""

#: ../../peewee/models.rst:89
msgid ""
"There is one special type of field, :py:class:`ForeignKeyField`, which "
"allows you to represent foreign-key relationships between models in an "
"intuitive way:"
msgstr ""

#: ../../peewee/models.rst:99
msgid "This allows you to write code like the following:"
msgstr ""

#: ../../peewee/models.rst:112
msgid ""
"For full documentation on fields, see the :ref:`Fields API notes <fields-"
"api>`"
msgstr ""

#: ../../peewee/models.rst:117
msgid "Field types table"
msgstr ""

#: ../../peewee/models.rst:120
msgid "Field Type"
msgstr ""

#: ../../peewee/models.rst:120
msgid "Sqlite"
msgstr ""

#: ../../peewee/models.rst:120
msgid "Postgresql"
msgstr ""

#: ../../peewee/models.rst:120
msgid "MySQL"
msgstr ""

#: ../../peewee/models.rst:122
msgid "``CharField``"
msgstr ""

#: ../../peewee/models.rst:122
msgid "varchar"
msgstr ""

#: ../../peewee/models.rst:123
msgid "``FixedCharField``"
msgstr ""

#: ../../peewee/models.rst:123
msgid "char"
msgstr ""

#: ../../peewee/models.rst:124
msgid "``TextField``"
msgstr ""

#: ../../peewee/models.rst:124 ../../peewee/models.rst:138
#: ../../peewee/playhouse.rst:629
msgid "text"
msgstr ""

#: ../../peewee/models.rst:124
msgid "longtext"
msgstr ""

#: ../../peewee/models.rst:125
msgid "``DateTimeField``"
msgstr ""

#: ../../peewee/models.rst:125
msgid "datetime"
msgstr ""

#: ../../peewee/models.rst:125
msgid "timestamp"
msgstr ""

#: ../../peewee/models.rst:126
msgid "``IntegerField``"
msgstr ""

#: ../../peewee/models.rst:126 ../../peewee/models.rst:127
#: ../../peewee/models.rst:130 ../../peewee/models.rst:131
#: ../../peewee/models.rst:133 ../../peewee/models.rst:134
#: ../../peewee/playhouse.rst:625
msgid "integer"
msgstr ""

#: ../../peewee/models.rst:127
msgid "``BooleanField``"
msgstr ""

#: ../../peewee/models.rst:127
msgid "boolean"
msgstr ""

#: ../../peewee/models.rst:127
msgid "bool"
msgstr ""

#: ../../peewee/models.rst:128
msgid "``FloatField``"
msgstr ""

#: ../../peewee/models.rst:128 ../../peewee/models.rst:129
#: ../../peewee/playhouse.rst:626
msgid "real"
msgstr ""

#: ../../peewee/models.rst:129
msgid "``DoubleField``"
msgstr ""

#: ../../peewee/models.rst:129
msgid "double precision"
msgstr ""

#: ../../peewee/models.rst:130
msgid "``BigIntegerField``"
msgstr ""

#: ../../peewee/models.rst:130
msgid "bigint"
msgstr ""

#: ../../peewee/models.rst:131
msgid "``SmallIntegerField``"
msgstr ""

#: ../../peewee/models.rst:131
msgid "smallint"
msgstr ""

#: ../../peewee/models.rst:132
msgid "``DecimalField``"
msgstr ""

#: ../../peewee/models.rst:132
msgid "decimal"
msgstr ""

#: ../../peewee/models.rst:132
msgid "numeric"
msgstr ""

#: ../../peewee/models.rst:133
msgid "``PrimaryKeyField``"
msgstr ""

#: ../../peewee/models.rst:133
msgid "serial"
msgstr ""

#: ../../peewee/models.rst:134
msgid "``ForeignKeyField``"
msgstr ""

#: ../../peewee/models.rst:135
msgid "``DateField``"
msgstr ""

#: ../../peewee/models.rst:135
msgid "date"
msgstr ""

#: ../../peewee/models.rst:136
msgid "``TimeField``"
msgstr ""

#: ../../peewee/models.rst:136
msgid "time"
msgstr ""

#: ../../peewee/models.rst:137
msgid "``BlobField``"
msgstr ""

#: ../../peewee/models.rst:137
msgid "blob"
msgstr ""

#: ../../peewee/models.rst:137
msgid "bytea"
msgstr ""

#: ../../peewee/models.rst:138
msgid "``UUIDField``"
msgstr ""

#: ../../peewee/models.rst:138
msgid "uuid"
msgstr ""

#: ../../peewee/models.rst:138
msgid "varchar(40)"
msgstr ""

#: ../../peewee/models.rst:139
msgid "``BareField``"
msgstr ""

#: ../../peewee/models.rst:139
msgid "untyped"
msgstr ""

#: ../../peewee/models.rst:139
msgid "not supported"
msgstr ""

#: ../../peewee/models.rst:143
msgid ""
"Don't see the field you're looking for in the above table? It's easy to "
"create custom field types and use them with your models."
msgstr ""

#: ../../peewee/models.rst:145
msgid ":ref:`custom-fields`"
msgstr ""

#: ../../peewee/models.rst:146
msgid ":py:class:`Database`, particularly the ``fields`` parameter."
msgstr ""

#: ../../peewee/models.rst:149
msgid "Field initialization arguments"
msgstr ""

#: ../../peewee/models.rst:151
msgid "Parameters accepted by all field types and their default values:"
msgstr ""

#: ../../peewee/models.rst:153
msgid ""
"``null = False`` -- boolean indicating whether null values are allowed to"
" be stored"
msgstr ""

#: ../../peewee/models.rst:154
msgid ""
"``index = False`` -- boolean indicating whether to create an index on "
"this column"
msgstr ""

#: ../../peewee/models.rst:155
msgid ""
"``unique = False`` -- boolean indicating whether to create a unique index"
" on this column. See also :ref:`adding composite indexes "
"<model_indexes>`."
msgstr ""

#: ../../peewee/models.rst:156
msgid ""
"``verbose_name = None`` -- string representing the \"user-friendly\" name"
" of this field"
msgstr ""

#: ../../peewee/models.rst:157
msgid ""
"``help_text = None`` -- string representing any helpful text for this "
"field"
msgstr ""

#: ../../peewee/models.rst:158
msgid ""
"``db_column = None`` -- string representing the underlying column to use "
"if different, useful for legacy databases"
msgstr ""

#: ../../peewee/models.rst:159
msgid ""
"``default = None`` -- any value to use as a default for uninitialized "
"models"
msgstr ""

#: ../../peewee/models.rst:160
msgid ""
"``choices = None`` -- an optional iterable containing 2-tuples of "
"``value``, ``display``"
msgstr ""

#: ../../peewee/models.rst:161
msgid ""
"``primary_key = False`` -- whether this field is the primary key for the "
"table"
msgstr ""

#: ../../peewee/models.rst:162
msgid "``sequence = None`` -- sequence to populate field (if backend supports it)"
msgstr ""

#: ../../peewee/models.rst:163
msgid ""
"``constraints = None`` - a list of one or more constraints, e.g. "
"``[Check('price > 0')]``"
msgstr ""

#: ../../peewee/models.rst:164
msgid ""
"``schema = None`` -- optional name of the schema to use, if your db "
"supports this."
msgstr ""

#: ../../peewee/models.rst:167
msgid "Some fields take special parameters..."
msgstr ""

#: ../../peewee/models.rst:170
msgid "Field type"
msgstr ""

#: ../../peewee/models.rst:170
msgid "Special Parameters"
msgstr ""

#: ../../peewee/models.rst:172
msgid ":py:class:`CharField`"
msgstr ""

#: ../../peewee/models.rst:174
msgid ":py:class:`FixedCharField`"
msgstr ""

#: ../../peewee/models.rst:176
msgid ":py:class:`DateTimeField`"
msgstr ""

#: ../../peewee/models.rst:176 ../../peewee/models.rst:178
#: ../../peewee/models.rst:180
msgid "``formats``"
msgstr ""

#: ../../peewee/models.rst:178
msgid ":py:class:`DateField`"
msgstr ""

#: ../../peewee/models.rst:180
msgid ":py:class:`TimeField`"
msgstr ""

#: ../../peewee/models.rst:182
msgid ":py:class:`DecimalField`"
msgstr ""

#: ../../peewee/models.rst:182
msgid "``max_digits``, ``decimal_places``, ``auto_round``, ``rounding``"
msgstr ""

#: ../../peewee/models.rst:185
msgid ":py:class:`ForeignKeyField`"
msgstr ""

#: ../../peewee/models.rst:185
msgid ""
"``rel_model``, ``related_name``, ``to_field``, ``on_delete``, "
"``on_update``, ``extra``"
msgstr ""

#: ../../peewee/models.rst:188
msgid ":py:class:`BareField`"
msgstr ""

#: ../../peewee/models.rst:188
msgid "``coerce``"
msgstr ""

#: ../../peewee/models.rst:192
msgid ""
"Both ``default`` and ``choices`` could be implemented at the database "
"level as *DEFAULT* and *CHECK CONSTRAINT* respectively, but any "
"application change would require a schema change. Because of this, "
"``default`` is implemented purely in python and ``choices`` are not "
"validated but exist for metadata purposes only."
msgstr ""

#: ../../peewee/models.rst:194
msgid ""
"To add database (server-side) constraints, use the ``constraints`` "
"parameter."
msgstr ""

#: ../../peewee/models.rst:197
msgid "Default field values"
msgstr ""

#: ../../peewee/models.rst:199
msgid ""
"Peewee can provide default values for fields when objects are created. "
"For example to have an ``IntegerField`` default to zero rather than "
"``NULL``, you could declare the field with a default value:"
msgstr ""

#: ../../peewee/models.rst:207
msgid ""
"In some instances it may make sense for the default value to be dynamic. "
"A common scenario is using the current date and time. Peewee allows you "
"to specify a function in these cases, whose return value will be used "
"when the object is created. Note we only provide the function, we do not "
"actually *call* it:"
msgstr ""

#: ../../peewee/models.rst:215
msgid ""
"When using the ``default`` parameter, the values are set by Peewee rather"
" than being a part of the actual table and column definition."
msgstr ""

#: ../../peewee/models.rst:217
msgid ""
"The database can also provide the default value for a field. While peewee"
" does not explicitly provide an API for setting a server-side default "
"value, you can use the ``constraints`` parameter to specify the server "
"default:"
msgstr ""

#: ../../peewee/models.rst:227
msgid "ForeignKeyField"
msgstr ""

#: ../../peewee/models.rst:229
msgid ""
":py:class:`ForeignKeyField` is a special field type that allows one model"
" to reference another. Typically a foreign key will contain the primary "
"key of the model it relates to (but you can specify a particular column "
"by specifying a ``to_field``)."
msgstr ""

#: ../../peewee/models.rst:231
msgid ""
"Foreign keys allow data to be `normalized "
"<http://en.wikipedia.org/wiki/Database_normalization>`_. In our example "
"models, there is a foreign key from ``Tweet`` to ``User``. This means "
"that all the users are stored in their own table, as are the tweets, and "
"the foreign key from tweet to user allows each tweet to *point* to a "
"particular user object."
msgstr ""

#: ../../peewee/models.rst:233
msgid ""
"In peewee, accessing the value of a :py:class:`ForeignKeyField` will "
"return the entire related object, e.g.:"
msgstr ""

#: ../../peewee/models.rst:241
msgid ""
"In the example above the ``User`` data was selected as part of the query."
" For more examples of this technique, see the :ref:`Avoiding N+1 "
"<nplusone>` document."
msgstr ""

#: ../../peewee/models.rst:243
msgid ""
"If we did not select the ``User``, though, then an additional query would"
" be issued to fetch the associated ``User`` data:"
msgstr ""

#: ../../peewee/models.rst:253
msgid ""
"Sometimes you only need the associated primary key value from the foreign"
" key column. In this case, Peewee follows the convention established by "
"Django, of allowing you to access the raw foreign key value by appending "
"``\"_id\"`` to the foreign key field's name:"
msgstr ""

#: ../../peewee/models.rst:263
msgid ""
":py:class:`ForeignKeyField` allows for a backreferencing property to be "
"bound to the target model. Implicitly, this property will be named "
"`classname_set`, where `classname` is the lowercase name of the class, "
"but can be overridden via the parameter ``related_name``:"
msgstr ""

#: ../../peewee/models.rst:282
msgid "DateTimeField, DateField and TimeField"
msgstr ""

#: ../../peewee/models.rst:284
msgid ""
"The three fields devoted to working with dates and times have special "
"properties which allow access to things like the year, month, hour, etc."
msgstr ""

#: ../../peewee/models.rst:287
msgid ":py:class:`DateField` has properties for:"
msgstr ""

#: ../../peewee/models.rst:289
msgid "``year``"
msgstr ""

#: ../../peewee/models.rst:290
msgid "``month``"
msgstr ""

#: ../../peewee/models.rst:291
msgid "``day``"
msgstr ""

#: ../../peewee/models.rst:293
msgid ":py:class:`TimeField` has properties for:"
msgstr ""

#: ../../peewee/models.rst:295
msgid "``hour``"
msgstr ""

#: ../../peewee/models.rst:296
msgid "``minute``"
msgstr ""

#: ../../peewee/models.rst:297
msgid "``second``"
msgstr ""

#: ../../peewee/models.rst:299
msgid ":py:class:`DateTimeField` has all of the above."
msgstr ""

#: ../../peewee/models.rst:301
msgid ""
"These properties can be used just like any other expression. Let's say we"
" have an events calendar and want to highlight all the days in the "
"current month that have an event attached:"
msgstr ""

#: ../../peewee/models.rst:316
msgid ""
"SQLite does not have a native date type, so dates are stored in formatted"
" text columns. To ensure that comparisons work correctly, the dates need "
"to be formatted so they are sorted lexicographically. That is why they "
"are stored, by default, as ``YYYY-MM-DD HH:MM:SS``."
msgstr ""

#: ../../peewee/models.rst:319
msgid "BareField"
msgstr ""

#: ../../peewee/models.rst:321
msgid ""
"The :py:class:`BareField` class is intended to be used only with SQLite. "
"Since SQLite uses dynamic typing and data-types are not enforced, it can "
"be perfectly fine to declare fields without *any* data-type. In those "
"cases you can use :py:class:`BareField`. It is also common for SQLite "
"virtual tables to use meta-columns or untyped columns, so for those cases"
" as well you may wish to use an untyped field."
msgstr ""

#: ../../peewee/models.rst:323
msgid ""
":py:class:`BareField` accepts a special parameter ``coerce``. This "
"parameter is a function that takes a value coming from the database and "
"converts it into the appropriate Python type. For instance, if you have a"
" virtual table with an un-typed column but you know that it will return "
"``int`` objects, you can specify ``coerce=int``."
msgstr ""

#: ../../peewee/models.rst:328
msgid "Creating a custom field"
msgstr ""

#: ../../peewee/models.rst:330
msgid ""
"It isn't too difficult to add support for custom field types in peewee. "
"In this example we will create a UUID field for postgresql (which has a "
"native UUID column type)."
msgstr ""

#: ../../peewee/models.rst:332
msgid ""
"To add a custom field type you need to first identify what type of column"
" the field data will be stored in. If you just want to add python "
"behavior atop, say, a decimal field (for instance to make a currency "
"field) you would just subclass :py:class:`DecimalField`. On the other "
"hand, if the database offers a custom column type you will need to let "
"peewee know. This is controlled by the :py:attr:`Field.db_field` "
"attribute."
msgstr ""

#: ../../peewee/models.rst:334
msgid "Let's start by defining our UUID field:"
msgstr ""

#: ../../peewee/models.rst:341
msgid ""
"We will store the UUIDs in a native UUID column. Since psycopg2 treats "
"the data as a string by default, we will add two methods to the field to "
"handle:"
msgstr ""

#: ../../peewee/models.rst:343
msgid "The data coming out of the database to be used in our application"
msgstr ""

#: ../../peewee/models.rst:344
msgid "The data from our python app going into the database"
msgstr ""

#: ../../peewee/models.rst:359
msgid ""
"Now, we need to let the database know how to map this *uuid* label to an "
"actual *uuid* column type in the database. There are 2 ways of doing "
"this:"
msgstr ""

#: ../../peewee/models.rst:361
msgid "Specify the overrides in the :py:class:`Database` constructor:"
msgstr ""

#: ../../peewee/models.rst:367
msgid "Register them class-wide using :py:meth:`Database.register_fields`:"
msgstr ""

#: ../../peewee/models.rst:374
msgid ""
"That is it! Some fields may support exotic operations, like the "
"postgresql HStore field acts like a key/value store and has custom "
"operators for things like *contains* and *update*. You can specify "
":ref:`custom operations <custom-operators>` as well. For example code, "
"check out the source code for the :py:class:`HStoreField`, in "
"``playhouse.postgres_ext``."
msgstr ""

#: ../../peewee/models.rst:377
msgid "Creating model tables"
msgstr "モデルテーブルの作成"

#: ../../peewee/models.rst:379
msgid ""
"In order to start using our models, its necessary to open a connection to"
" the database and create the tables first. Peewee will run the necessary "
"*CREATE TABLE* queries, additionally creating any constraints and "
"indexes."
msgstr ""

#: ../../peewee/models.rst:390
msgid ""
"Strictly speaking, it is not necessary to call "
":py:meth:`~Database.connect` but it is good practice to be explicit. That"
" way if something goes wrong, the error occurs at the connect step, "
"rather than some arbitrary time later."
msgstr ""

#: ../../peewee/models.rst:393
msgid ""
"Peewee can determine if your tables already exist, and conditionally "
"create them:"
msgstr ""

#: ../../peewee/models.rst:400
msgid ""
"After you have created your tables, if you choose to modify your database"
" schema (by adding, removing or otherwise changing the columns) you will "
"need to either:"
msgstr ""

#: ../../peewee/models.rst:402
msgid "Drop the table and re-create it."
msgstr ""

#: ../../peewee/models.rst:403
msgid ""
"Run one or more *ALTER TABLE* queries. Peewee comes with a schema "
"migration tool which can greatly simplify this. Check the :ref:`schema "
"migrations <migrate>` docs for details."
msgstr ""

#: ../../peewee/models.rst:408
msgid "Model options and table metadata"
msgstr "モデルオプションとテーブルのメタデータ"

#: ../../peewee/models.rst:410
msgid ""
"In order not to pollute the model namespace, model-specific configuration"
" is placed in a special class called *Meta* (a convention borrowed from "
"the django framework):"
msgstr ""

#: ../../peewee/models.rst:424
msgid ""
"This instructs peewee that whenever a query is executed on *Person* to "
"use the contacts database."
msgstr ""

#: ../../peewee/models.rst:427
msgid ""
"Take a look at :ref:`the sample models <blog-models>` - you will notice "
"that we created a ``BaseModel`` that defined the database, and then "
"extended. This is the preferred way to define a database and create "
"models."
msgstr ""

#: ../../peewee/models.rst:429
msgid ""
"Once the class is defined, you should not access ``ModelClass.Meta``, but"
" instead use ``ModelClass._meta``:"
msgstr ""

#: ../../peewee/models.rst:441
msgid ""
"The :py:class:`ModelOptions` class implements several methods which may "
"be of use for retrieving model metadata (such as lists of fields, foreign"
" key relationships, and more)."
msgstr ""

#: ../../peewee/models.rst:454
msgid ""
"There are several options you can specify as ``Meta`` attributes. While "
"most options are inheritable, some are table-specific and will not be "
"inherited by subclasses."
msgstr ""

#: ../../peewee/models.rst:457 ../../peewee/playhouse.rst:3401
#: ../../peewee/playhouse.rst:4107
msgid "Option"
msgstr ""

#: ../../peewee/models.rst:457 ../../peewee/playhouse.rst:3401
#: ../../peewee/querying.rst:872 ../../peewee/querying.rst:890
#: ../../peewee/querying.rst:908
msgid "Meaning"
msgstr ""

#: ../../peewee/models.rst:457
msgid "Inheritable?"
msgstr ""

#: ../../peewee/models.rst:459
msgid "``database``"
msgstr ""

#: ../../peewee/models.rst:459
msgid "database for model"
msgstr ""

#: ../../peewee/models.rst:459 ../../peewee/models.rst:461
#: ../../peewee/models.rst:462 ../../peewee/models.rst:463
#: ../../peewee/models.rst:464 ../../peewee/models.rst:466
#: ../../peewee/models.rst:467 ../../peewee/models.rst:468
#: ../../peewee/models.rst:469
msgid "yes"
msgstr ""

#: ../../peewee/models.rst:460
msgid "``db_table``"
msgstr ""

#: ../../peewee/models.rst:460
msgid "name of the table to store data"
msgstr ""

#: ../../peewee/models.rst:460 ../../peewee/models.rst:465
msgid "no"
msgstr ""

#: ../../peewee/models.rst:461
msgid "``db_table_func``"
msgstr ""

#: ../../peewee/models.rst:461
msgid "function that accepts model and returns a table name"
msgstr ""

#: ../../peewee/models.rst:462
msgid "``indexes``"
msgstr ""

#: ../../peewee/models.rst:462
msgid "a list of fields to index"
msgstr ""

#: ../../peewee/models.rst:463
msgid "``order_by``"
msgstr ""

#: ../../peewee/models.rst:463
msgid "a list of fields to use for default ordering"
msgstr ""

#: ../../peewee/models.rst:464
msgid "``primary_key``"
msgstr ""

#: ../../peewee/models.rst:464
msgid "a :py:class:`CompositeKey` instance"
msgstr ""

#: ../../peewee/models.rst:465
msgid "``table_alias``"
msgstr ""

#: ../../peewee/models.rst:465
msgid "an alias to use for the table in queries"
msgstr ""

#: ../../peewee/models.rst:466
msgid "``schema``"
msgstr ""

#: ../../peewee/models.rst:466
msgid "the database schema for the model"
msgstr ""

#: ../../peewee/models.rst:467
msgid "``constraints``"
msgstr ""

#: ../../peewee/models.rst:467
msgid "a list of table constraints"
msgstr ""

#: ../../peewee/models.rst:468
msgid "``validate_backrefs``"
msgstr ""

#: ../../peewee/models.rst:468
msgid "ensure backrefs do not conflict with other attributes."
msgstr ""

#: ../../peewee/models.rst:469
msgid "``only_save_dirty``"
msgstr ""

#: ../../peewee/models.rst:469
msgid "when calling model.save(), only save dirty fields"
msgstr ""

#: ../../peewee/models.rst:472
msgid "Here is an example showing inheritable versus non-inheritable attributes:"
msgstr ""

#: ../../peewee/models.rst:491
msgid "Meta.order_by"
msgstr ""

#: ../../peewee/models.rst:493
msgid ""
"Specifying a default ordering is, in my opinion, a bad idea. It's better "
"to be explicit in your code when you want to sort your results."
msgstr ""

#: ../../peewee/models.rst:495
msgid ""
"That said, to specify a default ordering, the syntax is similar to that "
"of Django. ``Meta.order_by`` is a tuple of field names, and to indicate "
"descending ordering, the field name is prefixed by a ``'-'``."
msgstr ""

#: ../../peewee/models.rst:510
msgid "Meta.primary_key"
msgstr ""

#: ../../peewee/models.rst:512
msgid ""
"The ``Meta.primary_key`` attribute is used to specify either a "
":py:class:`CompositeKey` or to indicate that the model has *no* primary "
"key. Composite primary keys are discussed in more detail here: :ref"
":`composite-key`."
msgstr ""

#: ../../peewee/models.rst:514
msgid ""
"To indicate that a model should not have a primary key, then set "
"``primary_key = False``."
msgstr ""

#: ../../peewee/models.rst:537
msgid "Indexes and Constraints"
msgstr "インデックスと制約"

#: ../../peewee/models.rst:539
msgid ""
"Peewee can create indexes on single or multiple columns, optionally "
"including a *UNIQUE* constraint. Peewee also supports user-defined "
"constraints on both models and fields."
msgstr ""

#: ../../peewee/models.rst:542
msgid "Single-column indexes and constraints"
msgstr ""

#: ../../peewee/models.rst:544
msgid ""
"Single column indexes are defined using field initialization parameters. "
"The following example adds a unique index on the *username* field, and a "
"normal index on the *email* field:"
msgstr ""

#: ../../peewee/models.rst:552
msgid ""
"To add a user-defined constraint on a column, you can pass it in using "
"the ``constraints`` parameter. You may wish to specify a default value as"
" part of the schema, or add a ``CHECK`` constraint, for example:"
msgstr ""

#: ../../peewee/models.rst:563
msgid "Multi-column indexes"
msgstr ""

#: ../../peewee/models.rst:565
msgid ""
"Multi-column indexes are defined as *Meta* attributes using a nested "
"tuple. Each database index is a 2-tuple, the first part of which is a "
"tuple of the names of the fields, the second part a boolean indicating "
"whether the index should be unique."
msgstr ""

#: ../../peewee/models.rst:585
msgid ""
"Remember to add a **trailing comma** if your tuple of indexes contains "
"only one item:"
msgstr ""

#: ../../peewee/models.rst:595
msgid "Table constraints"
msgstr ""

#: ../../peewee/models.rst:597
msgid ""
"Peewee allows you to add arbitrary constraints to your :py:class:`Model`,"
" that will be part of the table definition when the schema is created."
msgstr ""

#: ../../peewee/models.rst:599
msgid ""
"For instance, suppose you have a *people* table with a composite primary "
"key of two columns, the person's first and last name. You wish to have "
"another table relate to the *people* table, and to do this, you will need"
" to define a foreign key constraint:"
msgstr ""

#: ../../peewee/models.rst:619
msgid "You can also implement ``CHECK`` constraints at the table level:"
msgstr ""

#: ../../peewee/models.rst:633
msgid "Non-integer Primary Keys, Composite Keys and other Tricks"
msgstr "非整数主キー、複合キーおよびその他のトリック"

#: ../../peewee/models.rst:636
msgid "Non-integer primary keys"
msgstr ""

#: ../../peewee/models.rst:638
msgid ""
"If you would like use a non-integer primary key (which I generally don't "
"recommend), you can specify ``primary_key=True`` when creating a field. "
"When you wish to create a new instance for a model using a non-"
"autoincrementing primary key, you need to be sure you "
":py:meth:`~Model.save` specifying ``force_insert=True``."
msgstr ""

#: ../../peewee/models.rst:647
msgid ""
"Auto-incrementing IDs are, as their name says, automatically generated "
"for you when you insert a new row into the database. When you call "
":py:meth:`~Model.save`, peewee determines whether to do an *INSERT* "
"versus an *UPDATE* based on the presence of a primary key value. Since, "
"with our uuid example, the database driver won't generate a new ID, we "
"need to specify it manually. When we call save() for the first time, pass"
" in ``force_insert = True``:"
msgstr ""

#: ../../peewee/models.rst:664
msgid ""
"Any foreign keys to a model with a non-integer primary key will have a "
"``ForeignKeyField`` use the same underlying storage type as the primary "
"key they are related to."
msgstr ""

#: ../../peewee/models.rst:669
msgid "Composite primary keys"
msgstr ""

#: ../../peewee/models.rst:671
msgid ""
"Peewee has very basic support for composite keys.  In order to use a "
"composite key, you must set the ``primary_key`` attribute of the model "
"options to a :py:class:`CompositeKey` instance:"
msgstr ""

#: ../../peewee/models.rst:684
msgid "Manually specifying primary keys"
msgstr ""

#: ../../peewee/models.rst:686
msgid ""
"Sometimes you do not want the database to automatically generate a value "
"for the primary key, for instance when bulk loading relational data. To "
"handle this on a *one-off* basis, you can simply tell peewee to turn off "
"``auto_increment`` during the import:"
msgstr ""

#: ../../peewee/models.rst:700
msgid ""
"If you *always* want to have control over the primary key, simply do not "
"use the :py:class:`PrimaryKeyField` field type, but use a normal "
":py:class:`IntegerField` (or other column type):"
msgstr ""

#: ../../peewee/models.rst:715
msgid "Models without a Primary Key"
msgstr ""

#: ../../peewee/models.rst:717
msgid ""
"If you wish to create a model with no primary key, you can specify "
"``primary_key = False`` in the inner ``Meta`` class:"
msgstr ""

#: ../../peewee/models.rst:728
msgid "This will yield the following DDL:"
msgstr ""

#: ../../peewee/models.rst:738
msgid ""
"Some model APIs may not work correctly for models without a primary key, "
"for instance :py:meth:`~Model.save` and `~Model.delete_instance` (you can"
" instead use `~Model.insert`, `~Model.update` and `~Model.delete`)."
msgstr ""

#: ../../peewee/models.rst:741
msgid "Self-referential foreign keys"
msgstr "自己参照外部キー"

#: ../../peewee/models.rst:743
msgid ""
"When creating a heirarchical structure it is necessary to create a self-"
"referential foreign key which links a child object to its parent.  "
"Because the model class is not defined at the time you instantiate the "
"self-referential foreign key, use the special string ``'self'`` to "
"indicate a self-referential foreign key:"
msgstr ""

#: ../../peewee/models.rst:751
msgid ""
"As you can see, the foreign key points *upward* to the parent object and "
"the back-reference is named *children*."
msgstr ""

#: ../../peewee/models.rst:753
msgid "Self-referential foreign-keys should always be ``null=True``."
msgstr ""

#: ../../peewee/models.rst:755
msgid ""
"When querying against a model that contains a self-referential foreign "
"key you may sometimes need to perform a self-join. In those cases you can"
" use :py:meth:`Model.alias` to create a table reference. Here is how you "
"might query the category and parent model using a self-join:"
msgstr ""

#: ../../peewee/models.rst:769
msgid "Circular foreign key dependencies"
msgstr "循環外部キー依存関係"

#: ../../peewee/models.rst:771
msgid ""
"Sometimes it happens that you will create a circular dependency between "
"two tables."
msgstr ""

#: ../../peewee/models.rst:774
msgid ""
"My personal opinion is that circular foreign keys are a code smell and "
"should be refactored (by adding an intermediary table, for instance)."
msgstr ""

#: ../../peewee/models.rst:776
msgid ""
"Adding circular foreign keys with peewee is a bit tricky because at the "
"time you are defining either foreign key, the model it points to will not"
" have been defined yet, causing a ``NameError``."
msgstr ""

#: ../../peewee/models.rst:788
msgid ""
"One option is to simply use an :py:class:`IntegerField` to store the raw "
"ID:"
msgstr ""

#: ../../peewee/models.rst:796
msgid ""
"By using :py:class:`DeferredRelation` we can get around the problem and "
"still use a foreign key field:"
msgstr ""

#: ../../peewee/models.rst:815
msgid ""
"After initializing the deferred relation, the foreign key fields are now "
"correctly set up. There is one more quirk to watch out for, though. When "
"you call :py:class:`~Model.create_table` we will again encounter the same"
" issue. For this reason peewee will not automatically create a foreign "
"key constraint for any *deferred* foreign keys."
msgstr ""

#: ../../peewee/models.rst:817
msgid "Here is how to create the tables:"
msgstr ""

#: ../../peewee/models.rst:834
msgid ""
"SQLite does not support adding constraints to existing tables through the"
" ``ALTER TABLE`` statement."
msgstr ""

#: ../../peewee/more-resources.rst:4
msgid "Additional Resources"
msgstr "その他のリソース"

#: ../../peewee/more-resources.rst:6
msgid ""
"I've written a number of blog posts about building applications and web-"
"services with peewee (and usually Flask). If you'd like to see some "
"\"real-life\" applications that use peewee, the following resources may "
"be useful:"
msgstr ""

#: ../../peewee/more-resources.rst:8
msgid ""
"`How to make a Flask blog in one hour or less "
"<http://charlesleifer.com/blog/how-to-make-a-flask-blog-in-one-hour-or-"
"less/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:9
msgid ""
"`Building a note-taking app with Flask and Peewee "
"<http://charlesleifer.com/blog/saturday-morning-hack-a-little-note-"
"taking-app-with-flask/>`_ as well as `Part 2 "
"<http://charlesleifer.com/blog/saturday-morning-hacks-revisiting-the-"
"notes-app/>`_ and `Part 3 <http://charlesleifer.com/blog/saturday-"
"morning-hacks-adding-full-text-search-to-the-flask-note-taking-app/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:10
msgid ""
"`Analytics web service built with Flask and Peewee "
"<http://charlesleifer.com/blog/saturday-morning-hacks-building-an-"
"analytics-app-with-flask/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:11
msgid ""
"`Personalized news digest (with a boolean query parser!) "
"<http://charlesleifer.com/blog/saturday-morning-hack-personalized-news-"
"digest-with-boolean-query-parser/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:12
msgid ""
"`Using peewee to explore CSV files <http://charlesleifer.com/blog/using-"
"peewee-to-explore-csv-files/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:13
msgid ""
"`Structuring Flask apps with Peewee <http://charlesleifer.com/blog"
"/structuring-flask-apps-a-how-to-for-those-coming-from-django/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:14
msgid ""
"`Creating a lastpass clone with Flask and Peewee "
"<http://charlesleifer.com/blog/creating-a-personal-password-manager/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:15
msgid ""
"`Building a web-based encrypted file manager with Flask, peewee and S3 "
"<http://charlesleifer.com/blog/web-based-encrypted-file-storage-using-"
"flask-and-aws/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:16
msgid ""
"`Creating a bookmarking web-service that takes screenshots of your "
"bookmarks <http://charlesleifer.com/blog/building-bookmarking-service-"
"python-and-phantomjs/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:17
msgid ""
"`Building a pastebin, wiki and a bookmarking service using Flask and "
"Peewee <http://charlesleifer.com/blog/dont-sweat-small-stuff-use-flask-"
"blueprints/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:18
msgid ""
"`Encrypted databases with Python and SQLCipher "
"<http://charlesleifer.com/blog/encrypted-sqlite-databases-with-python-"
"and-sqlcipher/>`_."
msgstr ""

#: ../../peewee/more-resources.rst:19
msgid ""
"`Dear Diary, an Encrypted Command-Line Diary "
"<http://charlesleifer.com/blog/dear-diary-an-encrypted-command-line-"
"diary-with-python/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:4
msgid "Playhouse, extensions to Peewee"
msgstr "Playhouse。Peeweeへの拡張"

#: ../../peewee/playhouse.rst:6
msgid ""
"Peewee comes with numerous extrension modules which are collected under "
"the ``playhouse`` namespace. Despite the silly name, there are some very "
"useful extensions, particularly those that expose vendor-specific "
"database features like the :ref:`sqlite_ext` and :ref:`postgres_ext` "
"extensions."
msgstr ""

#: ../../peewee/playhouse.rst:8
msgid ""
"Below you will find a loosely organized listing of the various modules "
"that make up the ``playhouse``."
msgstr ""

#: ../../peewee/playhouse.rst:10
msgid "**Database drivers / vendor-specific database functionality**"
msgstr ""

#: ../../peewee/playhouse.rst:12
msgid ":ref:`sqlite_ext`"
msgstr ""

#: ../../peewee/playhouse.rst:13
msgid ":ref:`sqlite_udf`"
msgstr ""

#: ../../peewee/playhouse.rst:14
msgid ":ref:`apsw`"
msgstr ""

#: ../../peewee/playhouse.rst:15
msgid ":ref:`berkeleydb`"
msgstr ""

#: ../../peewee/playhouse.rst:16
msgid ":ref:`sqlcipher_ext`"
msgstr ""

#: ../../peewee/playhouse.rst:17
msgid ":ref:`postgres_ext`"
msgstr ""

#: ../../peewee/playhouse.rst:19
msgid "**High-level features**"
msgstr ""

#: ../../peewee/playhouse.rst:21
msgid ":ref:`extra-fields`"
msgstr ""

#: ../../peewee/playhouse.rst:22
msgid ":ref:`shortcuts`"
msgstr ""

#: ../../peewee/playhouse.rst:23
msgid ":ref:`hybrid`"
msgstr ""

#: ../../peewee/playhouse.rst:24
msgid ":ref:`signals`"
msgstr ""

#: ../../peewee/playhouse.rst:25
msgid ":ref:`dataset`"
msgstr ""

#: ../../peewee/playhouse.rst:26
msgid ":ref:`kv`"
msgstr ""

#: ../../peewee/playhouse.rst:27
msgid ":ref:`gfk`"
msgstr ""

#: ../../peewee/playhouse.rst:28
msgid ":ref:`csv_utils`"
msgstr ""

#: ../../peewee/playhouse.rst:30
msgid "**Database management and framework integration**"
msgstr ""

#: ../../peewee/playhouse.rst:32
msgid ":ref:`pwiz`"
msgstr ""

#: ../../peewee/playhouse.rst:33
msgid ":ref:`migrate`"
msgstr ""

#: ../../peewee/playhouse.rst:34
msgid ":ref:`pool`"
msgstr ""

#: ../../peewee/playhouse.rst:35
msgid ":ref:`reflection`"
msgstr ""

#: ../../peewee/playhouse.rst:36
msgid ":ref:`db_url`"
msgstr ""

#: ../../peewee/playhouse.rst:37
msgid ":ref:`read_slaves`"
msgstr ""

#: ../../peewee/playhouse.rst:38
msgid ":ref:`test_utils`"
msgstr ""

#: ../../peewee/playhouse.rst:39
msgid ":ref:`pskel`"
msgstr ""

#: ../../peewee/playhouse.rst:40
msgid ":ref:`flask_utils`"
msgstr ""

#: ../../peewee/playhouse.rst:41
msgid ":ref:`djpeewee`"
msgstr ""

#: ../../peewee/playhouse.rst:46
msgid "Sqlite Extensions"
msgstr "Sqlite拡張"

#: ../../peewee/playhouse.rst:48
msgid ""
"The SQLite extensions module provides support for some interesting "
"sqlite-only features:"
msgstr ""

#: ../../peewee/playhouse.rst:51
msgid "Define custom aggregates, collations and functions."
msgstr ""

#: ../../peewee/playhouse.rst:52
msgid ""
"Support for FTS3/4 (sqlite full-text search) with :ref:`BM25 ranking "
"<sqlite_bm25>`."
msgstr ""

#: ../../peewee/playhouse.rst:53
msgid ""
"C extension providing fast implementations of ranking and other utility "
"functions."
msgstr ""

#: ../../peewee/playhouse.rst:54
msgid "Support for the new FTS5 search extension."
msgstr ""

#: ../../peewee/playhouse.rst:55
msgid "Specify isolation level in transactions."
msgstr ""

#: ../../peewee/playhouse.rst:56
msgid "Support for virtual tables and SQLite C extensions."
msgstr ""

#: ../../peewee/playhouse.rst:57
msgid ""
"Support for the `closure table <http://charlesleifer.com/blog/querying-"
"tree-structures-in-sqlite-using-python-and-the-transitive-closure-"
"extension/>`_ extension, which allows efficient querying of heirarchical "
"tables."
msgstr ""

#: ../../peewee/playhouse.rst:60
msgid "sqlite_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:64
msgid ""
"A list of 2-tuples containing ``PRAGMA`` settings to configure on a per-"
"connection basis."
msgstr ""

#: ../../peewee/playhouse.rst:65
msgid ""
"Boolean flag indicating whether to use the fast implementations of "
"various SQLite user-defined functions. If Cython was installed when you "
"built ``peewee``, then these functions should be available. If not, "
"Peewee will fall back to using the slower pure-Python functions."
msgstr ""

#: ../../peewee/playhouse.rst:67
msgid ""
"Subclass of the :py:class:`SqliteDatabase` that provides some advanced "
"features only offered by Sqlite."
msgstr ""

#: ../../peewee/playhouse.rst:69
msgid "Register custom aggregates, collations and functions"
msgstr ""

#: ../../peewee/playhouse.rst:70
msgid "Support for SQLite virtual tables and C extensions"
msgstr ""

#: ../../peewee/playhouse.rst:71
msgid "Specify a row factory"
msgstr ""

#: ../../peewee/playhouse.rst:72
msgid "Advanced transactions (specify isolation level)"
msgstr ""

#: ../../peewee/playhouse.rst:76
msgid "Class-decorator for registering custom aggregation functions."
msgstr ""

#: ../../peewee/playhouse.rst:78
msgid "string name for the aggregate, defaults to the name of the class."
msgstr ""

#: ../../peewee/playhouse.rst:79
msgid ""
"integer representing number of parameters the aggregate function accepts."
" The default value, ``-1``, indicates the aggregate can accept any number"
" of parameters."
msgstr ""

#: ../../peewee/playhouse.rst:102
msgid "Unregister the given aggregate function."
msgstr ""

#: ../../peewee/playhouse.rst:106
msgid "Function decorator for registering a custom collation."
msgstr ""

#: ../../peewee/playhouse.rst:108
msgid "string name to use for this collation."
msgstr ""

#: ../../peewee/playhouse.rst:119
msgid ""
"As you might have noticed, the original ``collate_reverse`` function has "
"a special attribute called ``collation`` attached to it.  This extra "
"attribute provides a shorthand way to generate the SQL necessary to use "
"our custom collation."
msgstr ""

#: ../../peewee/playhouse.rst:126
msgid "Unregister the given collation function."
msgstr ""

#: ../../peewee/playhouse.rst:130
msgid "Function decorator for registering user-defined functions."
msgstr ""

#: ../../peewee/playhouse.rst:132
msgid "name to use for this function."
msgstr ""

#: ../../peewee/playhouse.rst:133
msgid ""
"number of parameters this function accepts.  If not provided, peewee will"
" introspect the function for you."
msgstr ""

#: ../../peewee/playhouse.rst:156
msgid "Unregister the given user-defiend function."
msgstr ""

#: ../../peewee/playhouse.rst:160
msgid ""
"Load the given C extension. If a connection is currently open in the "
"calling thread, then the extension will be loaded for that connection as "
"well as all subsequent connections."
msgstr ""

#: ../../peewee/playhouse.rst:162
msgid ""
"For example, if you've compiled the closure table extension and wish to "
"use it in your application, you might write:"
msgstr ""

#: ../../peewee/playhouse.rst:171
msgid "Unload the given SQLite extension."
msgstr ""

#: ../../peewee/playhouse.rst:175
msgid ""
"With the ``granular_transaction`` helper, you can specify the isolation "
"level for an individual transaction.  The valid options are:"
msgstr ""

#: ../../peewee/playhouse.rst:178
msgid "``exclusive``"
msgstr ""

#: ../../peewee/playhouse.rst:179
msgid "``immediate``"
msgstr ""

#: ../../peewee/playhouse.rst:180
msgid "``deferred``"
msgstr ""

#: ../../peewee/playhouse.rst:182 ../../peewee/playhouse.rst:1968
#: ../../peewee/playhouse.rst:3280 ../../peewee/playhouse.rst:3844
msgid "Example usage:"
msgstr ""

#: ../../peewee/playhouse.rst:201
msgid ""
"Subclass of :py:class:`Model` that signifies the model operates using a "
"virtual table provided by a sqlite extension."
msgstr ""

#: ../../peewee/playhouse.rst:204
msgid ""
"Creating a virtual model is easy, simply subclass ``VirtualModel`` and "
"specify the extension module and any options:"
msgstr ""

#: ../../peewee/playhouse.rst:218
msgid ""
"SQLite virtual tables often support configuration via arbitrary key/value"
" options which are included in the ``CREATE TABLE`` statement. To "
"configure a virtual table, you can specify options like this:"
msgstr ""

#: ../../peewee/playhouse.rst:238
msgid ""
"Model class that provides support for Sqlite's full-text search "
"extension. Models should be defined normally, however there are a couple "
"caveats:"
msgstr ""

#: ../../peewee/playhouse.rst:241
msgid ""
"Unique constraints, not null constraints, check constraints and foreign "
"keys are not supported."
msgstr ""

#: ../../peewee/playhouse.rst:242
msgid "Indexes on fields and multi-column indexes are ignored completely"
msgstr ""

#: ../../peewee/playhouse.rst:243
msgid ""
"Sqlite will treat all column types as ``TEXT`` (although you can store "
"other data types, Sqlite will treat them as text)."
msgstr ""

#: ../../peewee/playhouse.rst:245
msgid ""
"FTS models contain a ``docid`` field which is automatically created and "
"managed by SQLite (unless you choose to explicitly set it during model "
"creation). Lookups on this column **are performant**."
msgstr ""

#: ../../peewee/playhouse.rst:247
msgid ""
"``sqlite_ext`` provides a :py:class:`SearchField` field class which "
"should be used on ``FTSModel`` implementations instead of the regular "
"peewee field types. This will help prevent you accidentally creating "
"invalid column constraints."
msgstr ""

#: ../../peewee/playhouse.rst:249
msgid ""
"Because of the lack of secondary indexes, it usually makes sense to use "
"the ``docid`` primary key as a pointer to a row in a regular table. For "
"example:"
msgstr ""

#: ../../peewee/playhouse.rst:272
msgid ""
"To store a document in the document index, we will ``INSERT`` a row into "
"the ``DocumentIndex`` table, manually setting the ``docid``:"
msgstr ""

#: ../../peewee/playhouse.rst:282
msgid ""
"To perform a search and return ranked results, we can query the "
"``Document`` table and join on the ``DocumentIndex``:"
msgstr ""

#: ../../peewee/playhouse.rst:297
msgid ""
"All SQL queries on ``FTSModel`` classes will be slow **except** full-text"
" searches and ``docid`` lookups."
msgstr ""

#: ../../peewee/playhouse.rst:299
msgid "Continued examples:"
msgstr ""

#: ../../peewee/playhouse.rst:325
msgid "Examples using the BM25 ranking algorithm:"
msgstr ""

#: ../../peewee/playhouse.rst:346
msgid ""
"If the primary source of the content you are indexing exists in a "
"separate table, you can save some disk space by instructing SQLite to not"
" store an additional copy of the search index content. SQLite will still "
"create the metadata and data-structures needed to perform searches on the"
" content, but the content itself will not be stored in the search index."
msgstr ""

#: ../../peewee/playhouse.rst:348
msgid ""
"To accomplish this, you can specify a table or column using the "
"``content`` option. The `FTS4 documentation "
"<http://sqlite.org/fts3.html#section_6_2>`_ has more information."
msgstr ""

#: ../../peewee/playhouse.rst:350
msgid ""
"Here is a short code snippet illustrating how to implement this with "
"peewee:"
msgstr ""

#: ../../peewee/playhouse.rst:378
msgid ""
"The ``content`` option accepts either a single :py:class:`Field` or a "
":py:class:`Model` and can reduce the amount of storage used.  However, "
"content will need to be manually moved to/from the associated "
"``FTSModel``."
msgstr ""

#: ../../peewee/playhouse.rst:382
msgid "**FTSModel API methods:**"
msgstr ""

#: ../../peewee/playhouse.rst:386
msgid "do not re-create if table already exists."
msgstr ""

#: ../../peewee/playhouse.rst:387
msgid "options passed along when creating the table, e.g. ``content``."
msgstr ""

#: ../../peewee/playhouse.rst:391
msgid "Shorthand for generating a ``MATCH`` expression for the given term(s)."
msgstr ""

#: ../../peewee/playhouse.rst:403
msgid ""
"Shorthand way of searching for a term and sorting results by the quality "
"of the match. This is equivalent to the :py:meth:`~FTSModel.rank` example"
" code presented below."
msgstr ""

#: ../../peewee/playhouse.rst:407 ../../peewee/playhouse.rst:454
#: ../../peewee/playhouse.rst:710
msgid "Search term to use."
msgstr ""

#: ../../peewee/playhouse.rst:408 ../../peewee/playhouse.rst:455
#: ../../peewee/playhouse.rst:711
msgid ""
"A list of weights for the columns, ordered with respect to the column's "
"position in the table. **Or**, a dictionary keyed by the field or field "
"name and mapped to a value."
msgstr ""

#: ../../peewee/playhouse.rst:409 ../../peewee/playhouse.rst:456
#: ../../peewee/playhouse.rst:712
msgid "Whether the score should be returned as part of the ``SELECT`` statement."
msgstr ""

#: ../../peewee/playhouse.rst:410 ../../peewee/playhouse.rst:457
#: ../../peewee/playhouse.rst:713
msgid ""
"Alias to use for the calculated rank score. This is the attribute you "
"will use to access the score if ``with_score=True``."
msgstr ""

#: ../../peewee/playhouse.rst:430
msgid ""
"Generate an expression that will calculate and return the quality of the "
"search match. This ``rank`` can be used to sort the search results. The "
"lower the ``rank``, the better the match."
msgstr ""

#: ../../peewee/playhouse.rst:432
msgid ""
"The ``rank`` function accepts optional parameters that allow you to "
"specify weights for the various columns. If no weights are specified, all"
" columns are considered of equal importance."
msgstr ""

#: ../../peewee/playhouse.rst:450
msgid ""
"Shorthand way of searching for a term and sorting results by the quality "
"of the match, as determined by the BM25 algorithm. This is equivalent to "
"the :py:meth:`~FTSModel.bm25` example code presented below."
msgstr ""

#: ../../peewee/playhouse.rst:477
msgid ""
"Generate an expression that will calculate and return the quality of the "
"search match using the `BM25 algorithm "
"<https://en.wikipedia.org/wiki/Okapi_BM25>`_. This value can be used to "
"sort the search results, and the lower the value the better the match."
msgstr ""

#: ../../peewee/playhouse.rst:479
msgid ""
"The ``bm25`` function accepts optional parameters that allow you to "
"specify weights for the various columns. If no weights are specified, all"
" columns are considered of equal importance."
msgstr ""

#: ../../peewee/playhouse.rst:495
msgid ""
"Rebuild the search index -- this only works when the ``content`` option "
"was specified during table creation."
msgstr ""

#: ../../peewee/playhouse.rst:500
msgid "Optimize the search index."
msgstr ""

#: ../../peewee/playhouse.rst:505
msgid ""
"Whether the contents of this field should be excluded from the full-text "
"search index."
msgstr ""

#: ../../peewee/playhouse.rst:506
msgid "Name of the underlying database column."
msgstr ""

#: ../../peewee/playhouse.rst:507
msgid ""
"Function used to convert the value from the database into the appropriate"
" Python format."
msgstr ""

#: ../../peewee/playhouse.rst:512
msgid ""
"Field class suitable for working with JSON stored and manipulated using "
"the `JSON1 extension <https://www.sqlite.org/json1.html>`_."
msgstr ""

#: ../../peewee/playhouse.rst:514
msgid ""
"Most functions that operate on JSON fields take a ``path`` argument. The "
"JSON documents specify that the path should begin with ``'$'`` followed "
"by zero or more instances of ``'.objectlabel'`` or ``'[arrayindex]'``. "
"Peewee simplifies this by allowing you to omit the ``'$'`` character and "
"just specify the path you need or ``None`` for an empty path:"
msgstr ""

#: ../../peewee/playhouse.rst:516
msgid "``path=''`` --> ``'$'``"
msgstr ""

#: ../../peewee/playhouse.rst:517
msgid "``path='tags'`` --> ``'$.tags'``"
msgstr ""

#: ../../peewee/playhouse.rst:518
msgid "``path='[0][1].bar'`` --> ``'$[0][1].bar'``"
msgstr ""

#: ../../peewee/playhouse.rst:519
msgid "``path='metadata[0]'`` --> ``'$.metadata[0]'``"
msgstr ""

#: ../../peewee/playhouse.rst:520
msgid "``path='user.data.email'`` --> ``'$.user.data.email'``"
msgstr ""

#: ../../peewee/playhouse.rst:524
msgid ""
"Return the number of items in a JSON array at the given path. If the path"
" is omitted, then return the number of items in the top-level array."
msgstr ""

#: ../../peewee/playhouse.rst:526
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jarraylen>`_."
msgstr ""

#: ../../peewee/playhouse.rst:530
msgid ""
"Return the value at the given path. If the value is a JSON object or "
"array, it will be decoded into a ``dict`` or ``list``. If the value is a "
"scalar type, string or ``null`` then it will be returned as the "
"appropriate Python type."
msgstr ""

#: ../../peewee/playhouse.rst:532
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jex>`_."
msgstr ""

#: ../../peewee/playhouse.rst:549
msgid ""
"Set values stored in the input JSON string using the given path/value "
"pairs. The ``set`` function returns a **new** JSON string formed by "
"updating the input JSON with the given path/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:551
msgid "If the path does not exist, it **will** be created."
msgstr ""

#: ../../peewee/playhouse.rst:553
msgid "Similarly, if the path does exist, it **will** be overwritten."
msgstr ""

#: ../../peewee/playhouse.rst:555
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jset>`_."
msgstr ""

#: ../../peewee/playhouse.rst:597
msgid ""
"Insert the given path/value pairs into the JSON string stored in the "
"field. The ``insert`` function returns a **new** JSON string formed by "
"updating the input JSON with the given path/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:599
msgid "If the path already exists, it will **not** be overwritten."
msgstr ""

#: ../../peewee/playhouse.rst:601
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jins>`_."
msgstr ""

#: ../../peewee/playhouse.rst:605
msgid ""
"Replace values stored in the input JSON string using the given path/value"
" pairs. The ``replace`` function returns a **new** JSON string formed by "
"updating the input JSON with the given path/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:607
msgid "If the path does not exist, it will **not** be created."
msgstr ""

#: ../../peewee/playhouse.rst:609
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jrepl>`_."
msgstr ""

#: ../../peewee/playhouse.rst:613
msgid ""
"Remove values referenced by the given path(s). The ``remove`` function "
"returns a **new** JSON string formed by removing the specified paths from"
" the input JSON string."
msgstr ""

#: ../../peewee/playhouse.rst:615
msgid ""
"The process for removing fields from a JSON column is similar to the way "
"you :py:meth:`~JSONField.set` them. For a code example, see "
":ref:`updating JSON data <updating-json>`."
msgstr ""

#: ../../peewee/playhouse.rst:617
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jrm>`_."
msgstr ""

#: ../../peewee/playhouse.rst:621
msgid ""
"Return a string indicating the type of object stored in the field. You "
"can optionally supply a path to specify a sub-item. The types of objects "
"are:"
msgstr ""

#: ../../peewee/playhouse.rst:623
msgid "object"
msgstr ""

#: ../../peewee/playhouse.rst:624
msgid "array"
msgstr ""

#: ../../peewee/playhouse.rst:627
msgid "true"
msgstr ""

#: ../../peewee/playhouse.rst:628
msgid "false"
msgstr ""

#: ../../peewee/playhouse.rst:630
msgid "null  <-- the string \"null\" means an actual NULL value"
msgstr ""

#: ../../peewee/playhouse.rst:631
msgid "NULL  <-- an actual NULL value means the path was not found"
msgstr ""

#: ../../peewee/playhouse.rst:633
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jtype>`_."
msgstr ""

#: ../../peewee/playhouse.rst:637
msgid ""
"The ``children`` function corresponds to ``json_each``, a table-valued "
"function that walks the JSON value provided and returns the immediate "
"children of the top-level array or object. If a path is specified, then "
"that path is treated as the top-most element."
msgstr ""

#: ../../peewee/playhouse.rst:639
msgid ""
"The rows returned by calls to ``children()`` have the following "
"attributes:"
msgstr ""

#: ../../peewee/playhouse.rst:641
msgid "``key``: the key of the current element relative to its parent."
msgstr ""

#: ../../peewee/playhouse.rst:642
msgid "``value``: the value of the current element."
msgstr ""

#: ../../peewee/playhouse.rst:643
msgid "``type``: one of the data-types (see :py:meth:`~JSONField.json_type`)."
msgstr ""

#: ../../peewee/playhouse.rst:644
msgid ""
"``atom``: the scalar value for primitive types, ``NULL`` for arrays and "
"objects."
msgstr ""

#: ../../peewee/playhouse.rst:645
msgid "``id``: a unique ID referencing the current node in the tree."
msgstr ""

#: ../../peewee/playhouse.rst:646
msgid "``parent``: the ID of the containing node."
msgstr ""

#: ../../peewee/playhouse.rst:647
msgid "``fullkey``: the full path describing the current element."
msgstr ""

#: ../../peewee/playhouse.rst:648
msgid "``path``: the path to the container of the current row."
msgstr ""

#: ../../peewee/playhouse.rst:650 ../../peewee/playhouse.rst:660
msgid ""
"For examples, see `my blog post on JSON1 <http://charlesleifer.com/blog"
"/using-the-sqlite-json1-and-fts5-extensions-with-python/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:652
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jeach>`_."
msgstr ""

#: ../../peewee/playhouse.rst:656
msgid ""
"The ``tree`` function corresponds to ``json_tree``, a table-valued "
"function that walks the JSON value provided and recursively returns all "
"descendants of the given root node. If a path is specified, then that "
"path is treated as the root node element."
msgstr ""

#: ../../peewee/playhouse.rst:658
msgid ""
"The rows returned by calls to ``tree()`` have the same attributes as rows"
" returned by calls to :py:meth:`~JSONField.children`."
msgstr ""

#: ../../peewee/playhouse.rst:662
msgid "`SQLite documentation <https://www.sqlite.org/json1.html#jtree>`_."
msgstr ""

#: ../../peewee/playhouse.rst:667
msgid ""
"Subclass of :py:class:`PrimaryKeyField` that uses a monotonically-"
"increasing value for the primary key. This differs from the default "
"SQLite primary key, which simply uses the \"max + 1\" approach to "
"determining the next ID."
msgstr ""

#: ../../peewee/playhouse.rst:672
msgid ""
"Subclass of :py:class:`PrimaryKeyField` that provides access to the "
"underlying ``rowid`` field used internally by SQLite."
msgstr ""

#: ../../peewee/playhouse.rst:674
msgid ""
"When added to a Model, this field will act as the primary key. However, "
"this field will not be included by default when selecting rows from the "
"table."
msgstr ""

#: ../../peewee/playhouse.rst:679
msgid ""
"Subclass of :py:class:`PrimaryKeyField` that provides access to the "
"underlying ``docid`` field used internally by SQLite's FTS3/4 virtual "
"tables."
msgstr ""

#: ../../peewee/playhouse.rst:681
msgid ""
"This field should not be created manually, as it is only needed on "
"``FTSModel`` classes, which include it already."
msgstr ""

#: ../../peewee/playhouse.rst:686
msgid "Generate a SQLite `MATCH` expression for use in full-text searches."
msgstr ""

#: ../../peewee/playhouse.rst:695
msgid ""
"Model class that should be used to implement virtual tables using the "
"FTS5 extension. Documentation on the FTS5 extension `can be found here "
"<http://sqlite.org/fts5.html>`_. This extension behaves very similarly to"
" the FTS3 and FTS4 extensions, and the ``FTS5Model`` supports many of the"
" same APIs as :py:class:`FTSModel`."
msgstr ""

#: ../../peewee/playhouse.rst:697
msgid ""
"The ``FTS5`` extension is more strict in enforcing that no column define "
"any type or constraints. For this reason, only :py:class:`SearchField` "
"objects can be used with ``FTS5Model`` implementations."
msgstr ""

#: ../../peewee/playhouse.rst:699
msgid ""
"Additionally, ``FTS5`` comes with a built-in implementation of the BM25 "
"ranking function. Therefore, the ``search`` and ``search_bm25`` methods "
"have been overridden to use the builtin ranking functions rather than "
"user-defined functions."
msgstr ""

#: ../../peewee/playhouse.rst:703
msgid ""
"Return a boolean indicating whether the FTS5 extension is installed. If "
"it is not installed, an attempt will be made to load the extension."
msgstr ""

#: ../../peewee/playhouse.rst:707
msgid ""
"Shorthand way of searching for a term and sorting results by the quality "
"of the match. This is equivalent to the built-in ``rank`` value provided "
"by the ``FTS5`` extension."
msgstr ""

#: ../../peewee/playhouse.rst:733
msgid ""
"With FTS5, the ``search_bm25`` method is the same as the "
":py:meth:`FTS5Model.search` method."
msgstr ""

#: ../../peewee/playhouse.rst:737
msgid "Either ``'row'`` or ``'col'``."
msgstr ""

#: ../../peewee/playhouse.rst:738
msgid "Name for the vocab table. If not specified, will be \"fts5tablename_v\"."
msgstr ""

#: ../../peewee/playhouse.rst:745
msgid ""
"Factory function for creating a model class suitable for working with a "
"`transitive closure "
"<http://www.sqlite.org/cgi/src/artifact/636024302cde41b2bf0c542f81c40c624cfb7012>`_"
" table. Closure tables are :py:class:`VirtualModel` subclasses that work "
"with the transitive closure SQLite extension. These special tables are "
"designed to make it easy to efficiently query heirarchical data. The "
"SQLite extension manages an AVL tree behind-the-scenes, transparently "
"updating the tree when your table changes and making it easy to perform "
"common queries on heirarchical data."
msgstr ""

#: ../../peewee/playhouse.rst:747
msgid "To use the closure table extension in your project, you need:"
msgstr ""

#: ../../peewee/playhouse.rst:749
msgid ""
"A copy of the SQLite extension. The source code can be found in the "
"`SQLite code repository "
"<http://www.sqlite.org/cgi/src/artifact/636024302cde41b2bf0c542f81c40c624cfb7012>`_"
" or by cloning `this gist "
"<https://gist.github.com/coleifer/7f3593c5c2a645913b92>`_:"
msgstr ""

#: ../../peewee/playhouse.rst:756
msgid "Compile the extension as a shared library, e.g."
msgstr ""

#: ../../peewee/playhouse.rst:762
msgid ""
"Create a model for your heirarchical data. The only requirement here is "
"that the model have an integer primary key and a self-referential foreign"
" key. Any additional fields are fine."
msgstr ""

#: ../../peewee/playhouse.rst:774
msgid ""
"In your application code, make sure you load the extension when you "
"instantiate your :py:class:`Database` object. This is done by passing the"
" path to the shared library to the "
":py:meth:`~SqliteExtDatabase.load_extension` method."
msgstr ""

#: ../../peewee/playhouse.rst:781
msgid "The model class containing the nodes in the tree."
msgstr ""

#: ../../peewee/playhouse.rst:782
msgid ""
"The self-referential parent-node field on the model class. If not "
"provided, peewee will introspect the model to find a suitable key."
msgstr ""

#: ../../peewee/playhouse.rst:783
msgid "Returns a :py:class:`VirtualModel` for working with a closure table."
msgstr ""

#: ../../peewee/playhouse.rst:785
msgid ""
"There are two caveats you should be aware of when using the "
"``transitive_closure`` extension. First, it requires that your *source "
"model* have an integer primary key. Second, it is strongly recommended "
"that you create an index on the self-referential foreign key."
msgstr ""

#: ../../peewee/playhouse.rst:806
msgid ""
"It is now possible to perform interesting queries using the data from the"
" closure table:"
msgstr ""

#: ../../peewee/playhouse.rst:833
msgid ""
"The :py:class:`VirtualTable` returned by this function contains a handful"
" of interesting methods. The model will be a subclass of "
":py:class:`BaseClosureTable`."
msgstr ""

#: ../../peewee/playhouse.rst:839
msgid "A field for the primary key of the given node."
msgstr ""

#: ../../peewee/playhouse.rst:843
msgid "A field representing the relative depth of the given node."
msgstr ""

#: ../../peewee/playhouse.rst:847
msgid "A field representing the relative root node."
msgstr ""

#: ../../peewee/playhouse.rst:851
msgid ""
"Retrieve all descendants of the given node. If a depth is specified, only"
" nodes at that depth (relative to the given node) will be returned."
msgstr ""

#: ../../peewee/playhouse.rst:869
msgid ""
"Retrieve all ancestors of the given node. If a depth is specified, only "
"nodes at that depth (relative to the given node) will be returned."
msgstr ""

#: ../../peewee/playhouse.rst:883
msgid "Retrieve all nodes that are children of the specified node's parent."
msgstr ""

#: ../../peewee/playhouse.rst:885
msgid ""
"For an in-depth discussion of the SQLite transitive closure extension, "
"check out this blog post, `Querying Tree Structures in SQLite using "
"Python and the Transitive Closure Extension "
"<http://charlesleifer.com/blog/querying-tree-structures-in-sqlite-using-"
"python-and-the-transitive-closure-extension/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:890
msgid "Sqlite User-Defined Functions"
msgstr "Sqliteユーザー定義関数"

#: ../../peewee/playhouse.rst:892
msgid ""
"The ``sqlite_udf`` playhouse module contains a number of user-defined "
"functions, aggregates, and table-valued functions, which you may find "
"useful. The functions are grouped in collections and you can register "
"these user-defined extensions individually, by collection, or register "
"everything."
msgstr ""

#: ../../peewee/playhouse.rst:894
msgid ""
"Scalar functions are functions which take a number of parameters and "
"return a single value. For example, converting a string to upper-case, or"
" calculating the MD5 hex digest."
msgstr ""

#: ../../peewee/playhouse.rst:896
msgid ""
"Aggregate functions are like scalar functions that operate on multiple "
"rows of data, producing a single result. For example, calculating the sum"
" of a list of integers, or finding the smallest value in a particular "
"column."
msgstr ""

#: ../../peewee/playhouse.rst:898
msgid ""
"Table-valued functions are simply functions that can return multiple rows"
" of data. For example, a regular-expression search function that returns "
"all the matches in a given string, or a function that accepts two dates "
"and generates all the intervening days."
msgstr ""

#: ../../peewee/playhouse.rst:900
msgid ""
"To use table-valued functions, you will need to install the ``vtfunc`` "
"module. The ``vtfunc`` module is available `on GitHub "
"<https://github.com/coleifer/sqlite-vtfunc>`_ or can be installed using "
"``pip``."
msgstr ""

#: ../../peewee/playhouse.rst:903
msgid "Functions, listed by collection name"
msgstr ""

#: ../../peewee/playhouse.rst:905
msgid ""
"Scalar functions are indicated by ``(f)``, aggregate functions by "
"``(a)``, and table-valued functions by ``(t)``."
msgstr ""

#: ../../peewee/playhouse.rst:907
msgid "``CONTROL_FLOW`` * :py:func:`if_then_else` (f)"
msgstr ""

#: ../../peewee/playhouse.rst:909
msgid ""
"``DATE`` * :py:func:`strip_tz` (f) * :py:func:`human_delta` (f) * "
":py:func:`mintdiff` (a) * :py:func:`avgtdiff` (a) * :py:func:`duration` "
"(a) * :py:func:`date_series` (t)"
msgstr ""

#: ../../peewee/playhouse.rst:916
msgid "``FILE`` * :py:func:`file_ext` (f) * :py:func:`file_read` (f)"
msgstr ""

#: ../../peewee/playhouse.rst:919
msgid ""
"``HELPER`` * :py:func:`gzip` (f) * :py:func:`gunzip` (f) * "
":py:func:`hostname` (f) * :py:func:`toggle` (f) * :py:func:`setting` (f) "
"* :py:func:`clear_toggles` (f) * :py:func:`clear_settings` (f)"
msgstr ""

#: ../../peewee/playhouse.rst:927
msgid ""
"``MATH`` * :py:func:`randomrange` (f) * :py:func:`gauss_distribution` (f)"
" * :py:func:`sqrt` (f) * :py:func:`tonumber` (f) * :py:func:`mode` (a) * "
":py:func:`minrange` (a) * :py:func:`avgrange` (a) * :py:func:`range` (a) "
"* :py:func:`median` (a) (requires cython)"
msgstr ""

#: ../../peewee/playhouse.rst:937
msgid ""
"``STRING`` * :py:func:`substr_count` (f) * :py:func:`strip_chars` (f) * "
":py:func:`md5` (f) * :py:func:`sha1` (f) * :py:func:`sha256` (f) * "
":py:func:`sha512` (f) * :py:func:`adler32` (f) * :py:func:`crc32` (f) * "
":py:func:`damerau_levenshtein_dist` (f) (requires cython) * "
":py:func:`levenshtein_dist` (f) (requires cython) * :py:func:`str_dist` "
"(f) (requires cython) * :py:func:`regex_search` (t)"
msgstr ""

#: ../../peewee/playhouse.rst:954
msgid "apsw, an advanced sqlite driver"
msgstr "apsw、高度なsqliteドライバ"

#: ../../peewee/playhouse.rst:956
msgid ""
"The ``apsw_ext`` module contains a database class suitable for use with "
"the apsw sqlite driver."
msgstr ""

#: ../../peewee/playhouse.rst:959
msgid "APSW Project page: https://github.com/rogerbinns/apsw"
msgstr ""

#: ../../peewee/playhouse.rst:961
msgid ""
"APSW is a really neat library that provides a thin wrapper on top of "
"SQLite's C interface, making it possible to use all of SQLite's advanced "
"features."
msgstr ""

#: ../../peewee/playhouse.rst:964
msgid "Here are just a few reasons to use APSW, taken from the documentation:"
msgstr ""

#: ../../peewee/playhouse.rst:966
msgid ""
"APSW gives all functionality of SQLite, including virtual tables, virtual"
" file system, blob i/o, backups and file control."
msgstr ""

#: ../../peewee/playhouse.rst:970
msgid "APSW can handle nested transactions."
msgstr ""

#: ../../peewee/playhouse.rst:971
msgid "Unicode is handled correctly."
msgstr ""

#: ../../peewee/playhouse.rst:972
msgid "APSW is faster."
msgstr ""

#: ../../peewee/playhouse.rst:974
msgid ""
"For more information on the differences between apsw and pysqlite, check "
"`the apsw docs <http://rogerbinns.github.io/apsw/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:978
msgid "How to use the APSWDatabase"
msgstr ""

#: ../../peewee/playhouse.rst:996
msgid "apsw_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:998
msgid ""
":py:class:`APSWDatabase` extends the :py:class:`SqliteExtDatabase` and "
"inherits its advanced features."
msgstr ""

#: ../../peewee/playhouse.rst:1002
msgid "filename of sqlite database"
msgstr ""

#: ../../peewee/playhouse.rst:1003
msgid "keyword arguments passed to apsw when opening a connection"
msgstr ""

#: ../../peewee/playhouse.rst:1007
msgid ""
"Functions just like the :py:meth:`Database.transaction` context manager, "
"but accepts an additional parameter specifying the type of lock to use."
msgstr ""

#: ../../peewee/playhouse.rst:1010
msgid "type of lock to use when opening a new transaction"
msgstr ""

#: ../../peewee/playhouse.rst:1014
msgid ""
"Provides a way of globally registering a module.  For more information, "
"see the `documentation on virtual tables "
"<http://rogerbinns.github.io/apsw/vtable.html>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1017 ../../peewee/playhouse.rst:1024
msgid "name to use for module"
msgstr ""

#: ../../peewee/playhouse.rst:1018
msgid ""
"an object implementing the `Virtual Table "
"<http://rogerbinns.github.io/apsw/vtable.html#vttable-class>`_ interface"
msgstr ""

#: ../../peewee/playhouse.rst:1022
msgid "Unregister a module."
msgstr ""

#: ../../peewee/playhouse.rst:1027
msgid ""
"Be sure to use the ``Field`` subclasses defined in the ``apsw_ext`` "
"module, as they will properly handle adapting the data types for storage."
msgstr ""

#: ../../peewee/playhouse.rst:1030
msgid ""
"For example, instead of using ``peewee.DateTimeField``, be sure you are "
"importing and using ``playhouse.apsw_ext.DateTimeField``."
msgstr ""

#: ../../peewee/playhouse.rst:1036
msgid "BerkeleyDB backend"
msgstr "BerkeleyDBバックエンド"

#: ../../peewee/playhouse.rst:1038
msgid ""
"BerkeleyDB provides a `SQLite-compatible API "
"<http://www.oracle.com/technetwork/database/database-"
"technologies/berkeleydb/overview/sql-160887.html>`_. BerkeleyDB's SQL API"
" has many advantages over SQLite:"
msgstr ""

#: ../../peewee/playhouse.rst:1040
msgid "Higher transactions-per-second in multi-threaded environments."
msgstr ""

#: ../../peewee/playhouse.rst:1041
msgid "Built-in replication and hot backup."
msgstr ""

#: ../../peewee/playhouse.rst:1042
msgid "Fewer system calls, less resource utilization."
msgstr ""

#: ../../peewee/playhouse.rst:1043
msgid "Multi-version concurrency control."
msgstr ""

#: ../../peewee/playhouse.rst:1045
msgid ""
"For more details, Oracle has published a short `technical overview "
"<http://www.oracle.com/technetwork/database/berkeleydb/learnmore"
"/bdbvssqlite-wp-186779.pdf>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1047
msgid ""
"In order to use peewee with BerkeleyDB, you need to compile BerkeleyDB "
"with the SQL API enabled. Then compile the Python SQLite driver against "
"BerkeleyDB's sqlite replacement."
msgstr ""

#: ../../peewee/playhouse.rst:1049
msgid "Begin by downloading and compiling BerkeleyDB:"
msgstr ""

#: ../../peewee/playhouse.rst:1061
msgid ""
"Then get a copy of the standard library SQLite driver and build it "
"against BerkeleyDB:"
msgstr ""

#: ../../peewee/playhouse.rst:1071
msgid ""
"You can also find up-to-date `step by step instructions "
"<http://charlesleifer.com/blog/building-the-python-sqlite-driver-for-use-"
"with-berkeleydb/>`_ on my blog."
msgstr ""

#: ../../peewee/playhouse.rst:1075
msgid "Enable multiversion concurrency control. Default is ``False``."
msgstr ""

#: ../../peewee/playhouse.rst:1076
msgid "Set the page size ``PRAGMA``. This option only works on new databases."
msgstr ""

#: ../../peewee/playhouse.rst:1077
msgid "Set the cache size ``PRAGMA``."
msgstr ""

#: ../../peewee/playhouse.rst:1079
msgid ""
"Subclass of the :py:class:`SqliteExtDatabase` that supports connecting to"
" BerkeleyDB-backed version of SQLite."
msgstr ""

#: ../../peewee/playhouse.rst:1083
msgid ""
"Check whether ``pysqlite2`` was compiled against the BerkeleyDB SQLite. "
"Returns ``True`` or ``False``."
msgstr ""

#: ../../peewee/playhouse.rst:1087
msgid ""
"Check whether ``libsqlite3`` is the BerkeleyDB SQLite implementation. "
"Returns ``True`` or ``False``."
msgstr ""

#: ../../peewee/playhouse.rst:1093
msgid "Sqlcipher backend"
msgstr "Sqlcipherバックエンド"

#: ../../peewee/playhouse.rst:1095
msgid ""
"Although this extention's code is short, it has not been properly peer-"
"reviewed yet and may have introduced vulnerabilities."
msgstr ""

#: ../../peewee/playhouse.rst:1097
msgid ""
"The code contains minimum values for `passphrase` length and `kdf_iter`, "
"as well as a default value for the later. **Do not** regard these numbers"
" as advice. Consult the docs at http://sqlcipher.net/sqlcipher-api/ and "
"security experts."
msgstr ""

#: ../../peewee/playhouse.rst:1102
msgid ""
"Also note that this code relies on pysqlcipher_ and sqlcipher_, and the "
"code there might have vulnerabilities as well, but since these are widely"
" used crypto modules, we can expect \"short zero days\" there."
msgstr ""

#: ../../peewee/playhouse.rst:1110
msgid "sqlcipher_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:1114
msgid ""
"Subclass of :py:class:`SqliteDatabase` that stores the database "
"encrypted. Instead of the standard ``sqlite3`` backend, it uses "
"pysqlcipher_: a python wrapper for sqlcipher_, which -- in turn -- is an "
"encrypted wrapper around ``sqlite3``, so the API is *identical* to "
":py:class:`SqliteDatabase`'s, except for object construction parameters:"
msgstr ""

#: ../../peewee/playhouse.rst:1120
msgid "Path to encrypted database filename to open [or create]."
msgstr ""

#: ../../peewee/playhouse.rst:1121
msgid ""
"Database encryption passphrase: should be at least 8 character long (or "
"an error is raised), but it is *strongly advised* to enforce better "
"`passphrase strength`_ criteria in your implementation."
msgstr ""

#: ../../peewee/playhouse.rst:1124
msgid "[Optional] number of PBKDF2_ iterations."
msgstr ""

#: ../../peewee/playhouse.rst:1126
msgid ""
"If the ``database`` file doesn't exist, it will be *created* with "
"encryption by a key derived from ``passhprase`` with ``kdf_iter`` PBKDF2_"
" iterations."
msgstr ""

#: ../../peewee/playhouse.rst:1129
msgid ""
"When trying to open an existing database, ``passhprase`` and ``kdf_iter``"
" should be *identical* to the ones used when it was created."
msgstr ""

#: ../../peewee/playhouse.rst:1135
msgid "Notes:"
msgstr ""

#: ../../peewee/playhouse.rst:1137
msgid ""
"[Hopefully] there's no way to tell whether the passphrase is wrong or the"
" file is corrupt. In both cases -- *the first time we try to acces the "
"database* -- a :py:class:`DatabaseError` error is raised, with the "
"*exact* message: ``\"file is encrypted or is not a database\"``."
msgstr ""

#: ../../peewee/playhouse.rst:1143
msgid ""
"As mentioned above, this only happens when you *access* the databse, so "
"if you need to know *right away* whether the passphrase was correct, you "
"can trigger this check by calling [e.g.] "
":py:meth:`~Database.get_tables()` (see example below)."
msgstr ""

#: ../../peewee/playhouse.rst:1148
msgid ""
"Most applications can expect failed attempts to open the database (common"
" case: prompting the user for ``passphrase``), so the database can't be "
"hardwired into the :py:class:`Meta` of model classes. To defer "
"initialization, pass `None` in to the database."
msgstr ""

#: ../../peewee/playhouse.rst:1189
msgid ""
"See also: a slightly more elaborate `example "
"<https://gist.github.com/thedod/11048875#file-testpeeweesqlcipher-py>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1195
msgid "Postgresql Extensions"
msgstr "PostgreSQLの拡張機能"

#: ../../peewee/playhouse.rst:1197
msgid ""
"The postgresql extensions module provides a number of \"postgres-only\" "
"functions, currently:"
msgstr ""

#: ../../peewee/playhouse.rst:1200
msgid ":ref:`hstore support <hstore>`"
msgstr ""

#: ../../peewee/playhouse.rst:1201
msgid ":ref:`json support <pgjson>`, including ``jsonb`` for Postgres 9.4."
msgstr ""

#: ../../peewee/playhouse.rst:1202
msgid ":ref:`server-side cursors <server_side_cursors>`"
msgstr ""

#: ../../peewee/playhouse.rst:1203
msgid ":ref:`full-text search <pg_fts>`"
msgstr ""

#: ../../peewee/playhouse.rst:1204
msgid ":py:class:`ArrayField` field type, for storing arrays."
msgstr ""

#: ../../peewee/playhouse.rst:1205
msgid ":py:class:`HStoreField` field type, for storing key/value pairs."
msgstr ""

#: ../../peewee/playhouse.rst:1206
msgid ":py:class:`JSONField` field type, for storing JSON data."
msgstr ""

#: ../../peewee/playhouse.rst:1207
msgid ":py:class:`BinaryJSONField` field type for the ``jsonb`` JSON data type."
msgstr ""

#: ../../peewee/playhouse.rst:1208
msgid ":py:class:`TSVectorField` field type, for storing full-text search data."
msgstr ""

#: ../../peewee/playhouse.rst:1209
msgid ":py:class:`DateTimeTZ` field type, a timezone-aware datetime field."
msgstr ""

#: ../../peewee/playhouse.rst:1211
msgid ""
"In the future I would like to add support for more of postgresql's "
"features. If there is a particular feature you would like to see added, "
"please `open a Github issue "
"<https://github.com/coleifer/peewee/issues>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1215
msgid ""
"In order to start using the features described below, you will need to "
"use the extension :py:class:`PostgresqlExtDatabase` class instead of "
":py:class:`PostgresqlDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:1217
msgid ""
"The code below will assume you are using the following database and base "
"model:"
msgstr ""

#: ../../peewee/playhouse.rst:1232
msgid "hstore support"
msgstr ""

#: ../../peewee/playhouse.rst:1234
msgid ""
"`Postgresql hstore "
"<http://www.postgresql.org/docs/current/static/hstore.html>`_ is an "
"embedded key/value store.  With hstore, you can store arbitrary key/value"
" pairs in your database alongside structured relational data."
msgstr ""

#: ../../peewee/playhouse.rst:1238
msgid "Currently the ``postgres_ext`` module supports the following operations:"
msgstr ""

#: ../../peewee/playhouse.rst:1240
msgid "Store and retrieve arbitrary dictionaries"
msgstr ""

#: ../../peewee/playhouse.rst:1241
msgid "Filter by key(s) or partial dictionary"
msgstr ""

#: ../../peewee/playhouse.rst:1242
msgid "Update/add one or more keys to an existing dictionary"
msgstr ""

#: ../../peewee/playhouse.rst:1243
msgid "Delete one or more keys from an existing dictionary"
msgstr ""

#: ../../peewee/playhouse.rst:1244
msgid "Select keys, values, or zip keys and values"
msgstr ""

#: ../../peewee/playhouse.rst:1245
msgid "Retrieve a slice of keys/values"
msgstr ""

#: ../../peewee/playhouse.rst:1246
msgid "Test for the existence of a key"
msgstr ""

#: ../../peewee/playhouse.rst:1247
msgid "Test that a key has a non-NULL value"
msgstr ""

#: ../../peewee/playhouse.rst:1251
msgid "Using hstore"
msgstr ""

#: ../../peewee/playhouse.rst:1253
msgid ""
"To start with, you will need to import the custom database class and the "
"hstore functions from ``playhouse.postgres_ext`` (see above code "
"snippet).  Then, it is as simple as adding a :py:class:`HStoreField` to "
"your model:"
msgstr ""

#: ../../peewee/playhouse.rst:1264
msgid "You can now store arbitrary key/value pairs on ``House`` instances:"
msgstr ""

#: ../../peewee/playhouse.rst:1274
msgid "You can filter by keys or partial dictionary:"
msgstr ""

#: ../../peewee/playhouse.rst:1283
msgid "Suppose you want to do an atomic update to the house:"
msgstr ""

#: ../../peewee/playhouse.rst:1297
msgid "Or, alternatively an atomic delete:"
msgstr ""

#: ../../peewee/playhouse.rst:1309
msgid "Multiple keys can be deleted at the same time:"
msgstr ""

#: ../../peewee/playhouse.rst:1315
msgid "You can select just keys, just values, or zip the two:"
msgstr ""

#: ../../peewee/playhouse.rst:1335
msgid "You can retrieve a slice of data, for example, all the garage data:"
msgstr ""

#: ../../peewee/playhouse.rst:1345
msgid "You can check for the existence of a key and filter rows accordingly:"
msgstr ""

#: ../../peewee/playhouse.rst:1362
msgid "JSON Support"
msgstr ""

#: ../../peewee/playhouse.rst:1364
msgid ""
"peewee has basic support for Postgres' native JSON data type, in the form"
" of :py:class:`JSONField`. As of version 2.4.7, peewee also supports the "
"Postgres 9.4 binary json ``jsonb`` type, via :py:class:`BinaryJSONField`."
msgstr ""

#: ../../peewee/playhouse.rst:1368
msgid ""
"Postgres supports a JSON data type natively as of 9.2 (full support in "
"9.3). In order to use this functionality you must be using the correct "
"version of Postgres with `psycopg2` version 2.5 or greater."
msgstr ""

#: ../../peewee/playhouse.rst:1372
msgid ""
"To use :py:class:`BinaryJSONField`, which has many performance and "
"querying advantages, you must have Postgres 9.4 or later."
msgstr ""

#: ../../peewee/playhouse.rst:1375
msgid ""
"You must be sure your database is an instance of "
":py:class:`PostgresqlExtDatabase` in order to use the `JSONField`."
msgstr ""

#: ../../peewee/playhouse.rst:1378
msgid "Here is an example of how you might declare a model with a JSON field:"
msgstr ""

#: ../../peewee/playhouse.rst:1422
msgid ""
"The :py:class:`BinaryJSONField` works the same and supports the same "
"operations as the regular :py:class:`JSONField`, but provides several "
"additional operations for testing *containment*. Using the binary json "
"field, you can test whether your JSON data contains other partial JSON "
"structures (:py:meth:`~BinaryJSONField.contains`, "
":py:meth:`~BinaryJSONField.contains_any`, "
":py:meth:`~BinaryJSONField.contains_all`), or whether it is a subset of a"
" larger JSON document (:py:meth:`~BinaryJSONField.contained_by`)."
msgstr ""

#: ../../peewee/playhouse.rst:1424
msgid ""
"For more examples, see the :py:class:`JSONField` and "
":py:class:`BinaryJSONField` API documents below."
msgstr ""

#: ../../peewee/playhouse.rst:1429
msgid "Server-side cursors"
msgstr ""

#: ../../peewee/playhouse.rst:1431
msgid ""
"When psycopg2 executes a query, normally all results are fetched and "
"returned to the client by the backend.  This can cause your application "
"to use a lot of memory when making large queries.  Using server-side "
"cursors, results are returned a little at a time (by default 2000 "
"records).  For the definitive reference, please see the `psycopg2 "
"documentation <http://initd.org/psycopg/docs/usage.html#server-side-"
"cursors>`_."
msgstr ""

#: ../../peewee/playhouse.rst:1436
msgid ""
"To use server-side (or named) cursors, you must be using "
":py:class:`PostgresqlExtDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:1438
msgid ""
"To execute a query using a server-side cursor, simply wrap your select "
"query using the :py:func:`ServerSide` helper:"
msgstr ""

#: ../../peewee/playhouse.rst:1452
msgid ""
"If you would like all ``SELECT`` queries to automatically use a server-"
"side cursor, you can specify this when creating your "
":py:class:`PostgresqlExtDatabase`:"
msgstr ""

#: ../../peewee/playhouse.rst:1462
msgid ""
"Server-side cursors live only as long as the transaction, so for this "
"reason peewee will not automatically call ``commit()`` after executing a "
"``SELECT`` query.  If you do not ``commit`` after you are done iterating,"
" you will not release the server-side resources until the connection is "
"closed (or the transaction is committed later).  Furthermore, since "
"peewee will by default cache rows returned by the cursor, you should "
"always call ``.iterator()`` when iterating over a large query."
msgstr ""

#: ../../peewee/playhouse.rst:1470
msgid ""
"If you are using the :py:func:`ServerSide` helper, the transaction and "
"call to ``iterator()`` will be handled transparently."
msgstr ""

#: ../../peewee/playhouse.rst:1477
msgid "Full-text search"
msgstr ""

#: ../../peewee/playhouse.rst:1479
msgid ""
"Postgresql provides `sophisticated full-text search "
"<http://www.postgresql.org/docs/9.3/static/textsearch.html>`_ using "
"special data-types (``tsvector`` and ``tsquery``). Documents should be "
"stored or converted to the ``tsvector`` type, and search queries should "
"be converted to ``tsquery``."
msgstr ""

#: ../../peewee/playhouse.rst:1481
msgid ""
"For simple cases, you can simply use the :py:func:`Match` function, which"
" will automatically perform the appropriate conversions, and requires no "
"schema changes:"
msgstr ""

#: ../../peewee/playhouse.rst:1490
msgid ""
"The :py:func:`Match` function will automatically convert the left-hand "
"operand to a ``tsvector``, and the right-hand operand to a ``tsquery``. "
"For better performance, it is recommended you create a ``GIN`` index on "
"the column you plan to search:"
msgstr ""

#: ../../peewee/playhouse.rst:1496
msgid ""
"Alternatively, you can use the :py:class:`TSVectorField` to maintain a "
"dedicated column for storing ``tsvector`` data:"
msgstr ""

#: ../../peewee/playhouse.rst:1504
msgid ""
"You will need to explicitly convert the incoming text data to "
"``tsvector`` when inserting or updating the ``search_content`` field:"
msgstr ""

#: ../../peewee/playhouse.rst:1513
msgid ""
"If you are using the :py:class:`TSVectorField`, it will automatically be "
"created with a GIN index."
msgstr ""

#: ../../peewee/playhouse.rst:1517
msgid "postgres_ext API notes"
msgstr ""

#: ../../peewee/playhouse.rst:1521
msgid ""
"Identical to :py:class:`PostgresqlDatabase` but required in order to "
"support:"
msgstr ""

#: ../../peewee/playhouse.rst:1523
msgid ":ref:`server_side_cursors`"
msgstr ""

#: ../../peewee/playhouse.rst:1524
msgid ":py:class:`ArrayField`"
msgstr ""

#: ../../peewee/playhouse.rst:1525
msgid ":py:class:`DateTimeTZField`"
msgstr ""

#: ../../peewee/playhouse.rst:1526
msgid ":py:class:`JSONField`"
msgstr ""

#: ../../peewee/playhouse.rst:1527
msgid ":py:class:`BinaryJSONField`"
msgstr ""

#: ../../peewee/playhouse.rst:1528
msgid ":py:class:`HStoreField`"
msgstr ""

#: ../../peewee/playhouse.rst:1529
msgid ":py:class:`TSVectorField`"
msgstr ""

#: ../../peewee/playhouse.rst:1531
msgid "Name of database to connect to."
msgstr ""

#: ../../peewee/playhouse.rst:1532
msgid "Whether ``SELECT`` queries should utilize server-side cursors."
msgstr ""

#: ../../peewee/playhouse.rst:1534
msgid "Register the HStore extension with the connection."
msgstr ""

#: ../../peewee/playhouse.rst:1536
msgid ""
"If using ``server_side_cursors``, also be sure to wrap your queries with "
":py:func:`ServerSide`."
msgstr ""

#: ../../peewee/playhouse.rst:1539
msgid ""
"If you do not wish to use the HStore extension, you can specify "
"``register_hstore=False``."
msgstr ""

#: ../../peewee/playhouse.rst:1542
msgid ""
"The :py:class:`PostgresqlExtDatabase` by default will attempt to register"
" the ``HSTORE`` extension. Most distributions and recent versions include"
" this, but in some cases the extension may not be available. If you **do "
"not** plan to use the :ref:`HStore features of peewee <hstore>`, you can "
"pass ``register_hstore=False`` when initializing your "
":py:class:`PostgresqlExtDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:1546
msgid ""
"Wrap the given select query in a transaction, and call it's "
":py:meth:`~SelectQuery.iterator` method to avoid caching row instances.  "
"In order for the server-side resources to be released, be sure to exhaust"
" the generator (iterate over all the rows)."
msgstr ""

#: ../../peewee/playhouse.rst:1550
msgid "a :py:class:`SelectQuery` instance."
msgstr ""

#: ../../peewee/playhouse.rst:1551
msgid "``generator``"
msgstr ""

#: ../../peewee/playhouse.rst:1568
msgid "Field capable of storing arrays of the provided `field_class`."
msgstr ""

#: ../../peewee/playhouse.rst:1570
msgid "a subclass of :py:class:`Field`, e.g. :py:class:`IntegerField`."
msgstr ""

#: ../../peewee/playhouse.rst:1571
msgid "dimensions of array."
msgstr ""

#: ../../peewee/playhouse.rst:1573
msgid "You can store and retrieve lists (or lists-of-lists):"
msgstr ""

#: ../../peewee/playhouse.rst:1584
msgid ""
"Additionally, you can use the ``__getitem__`` API to query values or "
"slices in the database:"
msgstr ""

#: ../../peewee/playhouse.rst:1598
msgid "Get a slice of values:"
msgstr ""

#: ../../peewee/playhouse.rst:1611
msgid "One or more items that must be in the given array field."
msgstr ""

#: ../../peewee/playhouse.rst:1620
msgid "One or more items to search for in the given array field."
msgstr ""

#: ../../peewee/playhouse.rst:1622
msgid ""
"Like :py:meth:`~ArrayField.contains`, except will match rows where the "
"array contains *any* of the given items."
msgstr ""

#: ../../peewee/playhouse.rst:1632
msgid "A timezone-aware subclass of :py:class:`DateTimeField`."
msgstr ""

#: ../../peewee/playhouse.rst:1636
msgid ""
"A field for storing and retrieving arbitrary key/value pairs.  For "
"details on usage, see :ref:`hstore`."
msgstr ""

#: ../../peewee/playhouse.rst:1641
msgid "Returns the keys for a given row."
msgstr ""

#: ../../peewee/playhouse.rst:1653
msgid "Return the values for a given row."
msgstr ""

#: ../../peewee/playhouse.rst:1664
msgid "Like python's ``dict``, return the keys and values in a list-of-lists:"
msgstr ""

#: ../../peewee/playhouse.rst:1675
msgid "Return a slice of data given a list of keys."
msgstr ""

#: ../../peewee/playhouse.rst:1687
msgid "Query for whether the given key exists."
msgstr ""

#: ../../peewee/playhouse.rst:1703
msgid "Query for whether the given key has a value associated with it."
msgstr ""

#: ../../peewee/playhouse.rst:1707
msgid "Perform an atomic update to the keys/values for a given row or rows."
msgstr ""

#: ../../peewee/playhouse.rst:1718
msgid "Delete the provided keys for a given row or rows."
msgstr ""

#: ../../peewee/playhouse.rst:1720
msgid "We will use an ``UPDATE`` query."
msgstr ""

#: ../../peewee/playhouse.rst:1730
msgid "Either a ``dict``, a ``list`` of keys, or a single key."
msgstr ""

#: ../../peewee/playhouse.rst:1732
msgid "Query rows for the existence of either:"
msgstr ""

#: ../../peewee/playhouse.rst:1734
msgid "a partial dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:1735
msgid "a list of keys."
msgstr ""

#: ../../peewee/playhouse.rst:1736
msgid "a single key."
msgstr ""

#: ../../peewee/playhouse.rst:1747
msgid "One or more keys to search for."
msgstr ""

#: ../../peewee/playhouse.rst:1749
msgid "Query rows for the existince of *any* key."
msgstr ""

#: ../../peewee/playhouse.rst:1753
msgid ""
"Field class suitable for storing and querying arbitrary JSON.  When using"
" this on a model, set the field's value to a Python object (either a "
"``dict`` or a ``list``).  When you retrieve your value from the database "
"it will be returned as a Python data structure."
msgstr ""

#: ../../peewee/playhouse.rst:1758 ../../peewee/playhouse.rst:1857
msgid ""
"The default is to call json.dumps() or the dumps function. You can "
"override this method to create a customized JSON wrapper."
msgstr ""

#: ../../peewee/playhouse.rst:1760
msgid "You must be using Postgres 9.2 / psycopg2 2.5 or greater."
msgstr ""

#: ../../peewee/playhouse.rst:1762
msgid ""
"If you are using Postgres 9.4, strongly consider using the "
":py:class:`BinaryJSONField` instead as it offers better performance and "
"more powerful querying options."
msgstr ""

#: ../../peewee/playhouse.rst:1764
msgid "Example model declaration:"
msgstr ""

#: ../../peewee/playhouse.rst:1777
msgid "Example of storing JSON data:"
msgstr ""

#: ../../peewee/playhouse.rst:1787
msgid ""
"To query, use Python's ``[]`` operators to specify nested key or array "
"lookups:"
msgstr ""

#: ../../peewee/playhouse.rst:1794
msgid ""
"To illustrate the use of the ``[]`` operators, imagine we have the "
"following data stored in an ``APIResponse``:"
msgstr ""

#: ../../peewee/playhouse.rst:1808
msgid "Here are the results of a few queries:"
msgstr ""

#: ../../peewee/playhouse.rst:1853
msgid ""
"Store and query arbitrary JSON documents. Data should be stored using "
"normal Python ``dict`` and ``list`` objects, and when data is returned "
"from the database, it will be returned using ``dict`` and ``list`` as "
"well."
msgstr ""

#: ../../peewee/playhouse.rst:1855
msgid ""
"For examples of basic query operations, see the above code samples for "
":py:class:`JSONField`. The example queries below will use the same "
"``APIResponse`` model described above."
msgstr ""

#: ../../peewee/playhouse.rst:1859
msgid ""
"You must be using Postgres 9.4 / psycopg2 2.5 or newer. If you are using "
"Postgres 9.2 or 9.3, you can use the regular :py:class:`JSONField` "
"instead."
msgstr ""

#: ../../peewee/playhouse.rst:1863
msgid "Test whether the given JSON data contains the given JSON fragment or key."
msgstr ""

#: ../../peewee/playhouse.rst:1883
msgid ""
"We can pass in simple keys as well. To find APIResponses that contain the"
" key ``foo`` at the top-level:"
msgstr ""

#: ../../peewee/playhouse.rst:1889
msgid "We can also search sub-keys using square-brackets:"
msgstr ""

#: ../../peewee/playhouse.rst:1898
msgid "Search for the presence of one or more of the given items."
msgstr ""

#: ../../peewee/playhouse.rst:1905
msgid "Like :py:meth:`~BinaryJSONField.contains`, we can also search sub-keys:"
msgstr ""

#: ../../peewee/playhouse.rst:1914
msgid "Search for the presence of all of the given items."
msgstr ""

#: ../../peewee/playhouse.rst:1921
msgid ""
"Like :py:meth:`~BinaryJSONField.contains_any`, we can also search sub-"
"keys:"
msgstr ""

#: ../../peewee/playhouse.rst:1930
msgid ""
"Test whether the given JSON document is contained by (is a subset of) the"
" given JSON document. This method is the inverse of "
":py:meth:`~BinaryJSONField.contains`."
msgstr ""

#: ../../peewee/playhouse.rst:1950
msgid ""
"Generate a full-text search expression, automatically converting the "
"left-hand operand to a ``tsvector``, and the right-hand operand to a "
"``tsquery``."
msgstr ""

#: ../../peewee/playhouse.rst:1963
msgid ""
"Field type suitable for storing ``tsvector`` data. This field will "
"automatically be created with a ``GIN`` index for improved search "
"performance."
msgstr ""

#: ../../peewee/playhouse.rst:1966
msgid ""
"Data stored in this field will still need to be manually converted to the"
" ``tsvector`` type."
msgstr ""

#: ../../peewee/playhouse.rst:1985
msgid "DataSet"
msgstr "データセット"

#: ../../peewee/playhouse.rst:1987
msgid ""
"The *dataset* module contains a high-level API for working with databases"
" modeled after the popular `project of the same name "
"<https://dataset.readthedocs.io/en/latest/index.html>`_. The aims of the "
"*dataset* module are to provide:"
msgstr ""

#: ../../peewee/playhouse.rst:1989
msgid ""
"A simplified API for working with relational data, along the lines of "
"working with JSON."
msgstr ""

#: ../../peewee/playhouse.rst:1990
msgid "An easy way to export relational data as JSON or CSV."
msgstr ""

#: ../../peewee/playhouse.rst:1991
msgid "An easy way to import JSON or CSV data into a relational database."
msgstr ""

#: ../../peewee/playhouse.rst:1993
msgid "A minimal data-loading script might look like this:"
msgstr ""

#: ../../peewee/playhouse.rst:2014
msgid ""
"You can export or import data using :py:meth:`~DataSet.freeze` and "
":py:meth:`~DataSet.thaw`:"
msgstr ""

#: ../../peewee/playhouse.rst:2027
msgid "Getting started"
msgstr ""

#: ../../peewee/playhouse.rst:2029
msgid ""
":py:class:`DataSet` objects are initialized by passing in a database URL "
"of the format ``dialect://user:password@host/dbname``. See the "
":ref:`db_url` section for examples of connecting to various databases."
msgstr ""

#: ../../peewee/playhouse.rst:2037 ../../peewee/quickstart.rst:82
msgid "Storing data"
msgstr "データの保存"

#: ../../peewee/playhouse.rst:2039
msgid ""
"To store data, we must first obtain a reference to a table. If the table "
"does not exist, it will be created automatically:"
msgstr ""

#: ../../peewee/playhouse.rst:2046
msgid ""
"We can now :py:meth:`~Table.insert` new rows into the table. If the "
"columns do not exist, they will be created automatically:"
msgstr ""

#: ../../peewee/playhouse.rst:2053
msgid ""
"To update existing entries in the table, pass in a dictionary containing "
"the new values and filter conditions. The list of columns to use as "
"filters is specified in the *columns* argument. If no filter columns are "
"specified, then all rows will be updated."
msgstr ""

#: ../../peewee/playhouse.rst:2064
msgid "Importing data"
msgstr ""

#: ../../peewee/playhouse.rst:2066
msgid ""
"To import data from an external source, such as a JSON or CSV file, you "
"can use the :py:meth:`~Table.thaw` method. By default, new columns will "
"be created for any attributes encountered. If you wish to only populate "
"columns that are already defined on a table, you can pass in "
"``strict=True``."
msgstr ""

#: ../../peewee/playhouse.rst:2082
msgid "Using transactions"
msgstr ""

#: ../../peewee/playhouse.rst:2084
msgid "DataSet supports nesting transactions using a simple context manager."
msgstr ""

#: ../../peewee/playhouse.rst:2100
msgid "Inspecting the database"
msgstr ""

#: ../../peewee/playhouse.rst:2102
msgid ""
"You can use the :py:meth:`tables` method to list the tables in the "
"current database:"
msgstr ""

#: ../../peewee/playhouse.rst:2109
msgid "And for a given table, you can print the columns:"
msgstr ""

#: ../../peewee/playhouse.rst:2117
msgid "We can also find out how many rows are in a table:"
msgstr ""

#: ../../peewee/playhouse.rst:2125
msgid "Reading data"
msgstr ""

#: ../../peewee/playhouse.rst:2127
msgid "To retrieve all rows, you can use the :py:meth:`~Table.all` method:"
msgstr ""

#: ../../peewee/playhouse.rst:2138
msgid ""
"Specific objects can be retrieved using :py:meth:`~Table.find` and "
":py:meth:`~Table.find_one`."
msgstr ""

#: ../../peewee/playhouse.rst:2149
msgid "Exporting data"
msgstr ""

#: ../../peewee/playhouse.rst:2151
msgid ""
"To export data, use the :py:meth:`~DataSet.freeze` method, passing in the"
" query you wish to export:"
msgstr ""

#: ../../peewee/playhouse.rst:2159
msgid "API"
msgstr ""

#: ../../peewee/playhouse.rst:2163
msgid ""
"The *DataSet* class provides a high-level API for working with relational"
" databases."
msgstr ""

#: ../../peewee/playhouse.rst:2165
msgid "A database URL. See :ref:`db_url` for examples."
msgstr ""

#: ../../peewee/playhouse.rst:2169
msgid ""
"Return a list of tables stored in the database. This list is computed "
"dynamically each time it is accessed."
msgstr ""

#: ../../peewee/playhouse.rst:2173
msgid ""
"Provide a :py:class:`Table` reference to the specified table. If the "
"table does not exist, it will be created."
msgstr ""

#: ../../peewee/playhouse.rst:2177
msgid "A SQL query."
msgstr ""

#: ../../peewee/playhouse.rst:2178
msgid "Optional parameters for the query."
msgstr ""

#: ../../peewee/playhouse.rst:2179
msgid "Whether the query should be committed upon execution."
msgstr ""

#: ../../peewee/playhouse.rst:2180
msgid "A database cursor."
msgstr ""

#: ../../peewee/playhouse.rst:2182
msgid "Execute the provided query against the database."
msgstr ""

#: ../../peewee/playhouse.rst:2186
msgid "Create a context manager representing a new transaction (or savepoint)."
msgstr ""

#: ../../peewee/playhouse.rst:2190
msgid ""
"A :py:class:`SelectQuery`, generated using :py:meth:`~Table.all` or "
"`~Table.find`."
msgstr ""

#: ../../peewee/playhouse.rst:2191 ../../peewee/playhouse.rst:2284
msgid "Output format. By default, *csv* and *json* are supported."
msgstr ""

#: ../../peewee/playhouse.rst:2192 ../../peewee/playhouse.rst:2285
msgid "Filename to write output to."
msgstr ""

#: ../../peewee/playhouse.rst:2193 ../../peewee/playhouse.rst:2286
msgid "File-like object to write output to."
msgstr ""

#: ../../peewee/playhouse.rst:2194 ../../peewee/playhouse.rst:2287
msgid "Arbitrary parameters for export-specific functionality."
msgstr ""

#: ../../peewee/playhouse.rst:2198
msgid "The name of the table to load data into."
msgstr ""

#: ../../peewee/playhouse.rst:2199 ../../peewee/playhouse.rst:2291
msgid "Input format. By default, *csv* and *json* are supported."
msgstr ""

#: ../../peewee/playhouse.rst:2200 ../../peewee/playhouse.rst:2292
msgid "Filename to read data from."
msgstr ""

#: ../../peewee/playhouse.rst:2201 ../../peewee/playhouse.rst:2293
msgid "File-like object to read data from."
msgstr ""

#: ../../peewee/playhouse.rst:2202 ../../peewee/playhouse.rst:2294
msgid ""
"Whether to store values for columns that do not already exist on the "
"table."
msgstr ""

#: ../../peewee/playhouse.rst:2203 ../../peewee/playhouse.rst:2295
msgid "Arbitrary parameters for import-specific functionality."
msgstr ""

#: ../../peewee/playhouse.rst:2207
msgid ""
"Open a connection to the underlying database. If a connection is not "
"opened explicitly, one will be opened the first time a query is executed."
msgstr ""

#: ../../peewee/playhouse.rst:2211
msgid "Close the connection to the underlying database."
msgstr ""

#: ../../peewee/playhouse.rst:2215
msgid ""
"The *Table* class provides a high-level API for working with rows in a "
"given table."
msgstr ""

#: ../../peewee/playhouse.rst:2219
msgid "Return a list of columns in the given table."
msgstr ""

#: ../../peewee/playhouse.rst:2223
msgid "A dynamically-created :py:class:`Model` class."
msgstr ""

#: ../../peewee/playhouse.rst:2227
msgid "Create an index on the given columns:"
msgstr ""

#: ../../peewee/playhouse.rst:2236
msgid ""
"Insert the given data dictionary into the table, creating new columns as "
"needed."
msgstr ""

#: ../../peewee/playhouse.rst:2240
msgid ""
"Update the table using the provided data. If one or more columns are "
"specified in the *columns* parameter, then those columns' values in the "
"*data* dictionary will be used to determine which rows to update."
msgstr ""

#: ../../peewee/playhouse.rst:2252
msgid ""
"Query the table for rows matching the specified equality conditions. If "
"no query is specified, then all rows are returned."
msgstr ""

#: ../../peewee/playhouse.rst:2260
msgid ""
"Return a single row matching the specified equality conditions. If no "
"matching row is found then ``None`` will be returned."
msgstr ""

#: ../../peewee/playhouse.rst:2268
msgid "Return all rows in the given table."
msgstr ""

#: ../../peewee/playhouse.rst:2272
msgid ""
"Delete all rows matching the given equality conditions. If no query is "
"provided, then all rows will be deleted."
msgstr ""

#: ../../peewee/playhouse.rst:2301
msgid "Django Integration"
msgstr "Djangoの統合"

#: ../../peewee/playhouse.rst:2303
msgid ""
"The Django ORM provides a very high-level abstraction over SQL and as a "
"consequence is in some ways `limited in terms of flexibility or "
"expressiveness <http://charlesleifer.com/blog/shortcomings-in-the-django-"
"orm-and-a-look-at-peewee-a-lightweight-alternative/>`_. I wrote a `blog "
"post <http://charlesleifer.com/blog/the-search-for-the-missing-link-what-"
"lies-between-sql-and-django-s-orm-/>`_ describing my search for a "
"\"missing link\" between Django's ORM and the SQL it generates, "
"concluding that no such layer exists.  The ``djpeewee`` module attempts "
"to provide an easy-to-use, structured layer for generating SQL queries "
"for use with Django's ORM."
msgstr ""

#: ../../peewee/playhouse.rst:2311
msgid "A couple use-cases might be:"
msgstr ""

#: ../../peewee/playhouse.rst:2313
msgid ""
"Joining on fields that are not related by foreign key (for example UUID "
"fields)."
msgstr ""

#: ../../peewee/playhouse.rst:2314
msgid "Performing aggregate queries on calculated values."
msgstr ""

#: ../../peewee/playhouse.rst:2315
msgid "Features that Django does not support such as ``CASE`` statements."
msgstr ""

#: ../../peewee/playhouse.rst:2316
msgid "Utilizing SQL functions that Django does not support, such as ``SUBSTR``."
msgstr ""

#: ../../peewee/playhouse.rst:2317
msgid ""
"Replacing nearly-identical SQL queries with reusable, composable data-"
"structures."
msgstr ""

#: ../../peewee/playhouse.rst:2319
msgid "Below is an example of how you might use this:"
msgstr ""

#: ../../peewee/playhouse.rst:2343
msgid "Foreign keys and Many-to-many relationships"
msgstr ""

#: ../../peewee/playhouse.rst:2345
msgid ""
"The :py:func:`translate` function will recursively traverse the graph of "
"models and return a dictionary populated with everything it finds.  Back-"
"references are not searched by default, but can be included by specifying"
" ``backrefs=True``."
msgstr ""

#: ../../peewee/playhouse.rst:2364
msgid ""
"As you can see in the example above, although only `User` and `Group` "
"were passed in to :py:func:`translate`, several other models which are "
"related by foreign key were also created. Additionally, the many-to-many "
"\"through\" tables were created as separate models since peewee does not "
"abstract away these types of relationships."
msgstr ""

#: ../../peewee/playhouse.rst:2369
msgid ""
"Using the above models it is possible to construct joins.  The following "
"example will get all users who belong to a group that starts with the "
"letter \"A\":"
msgstr ""

#: ../../peewee/playhouse.rst:2386
msgid "djpeewee API"
msgstr ""

#: ../../peewee/playhouse.rst:2390
msgid ""
"Translate the given Django models into roughly equivalent peewee models "
"suitable for use constructing queries. Foreign keys and many-to-many "
"relationships will be followed and models generated, although back "
"references are not traversed."
msgstr ""

#: ../../peewee/playhouse.rst:2394
msgid "One or more Django model classes."
msgstr ""

#: ../../peewee/playhouse.rst:2395
msgid "A dictionary of options, see note below."
msgstr ""

#: ../../peewee/playhouse.rst:2396
msgid ""
"A dict-like object containing the generated models, but which supports "
"dotted-name style lookups."
msgstr ""

#: ../../peewee/playhouse.rst:2399
msgid "The following are valid options:"
msgstr ""

#: ../../peewee/playhouse.rst:2401
msgid "``recurse``: Follow foreign keys and many to many (default: ``True``)."
msgstr ""

#: ../../peewee/playhouse.rst:2402
msgid "``max_depth``: Maximum depth to recurse (default: ``None``, unlimited)."
msgstr ""

#: ../../peewee/playhouse.rst:2403
msgid "``backrefs``: Follow backrefs (default: ``False``)."
msgstr ""

#: ../../peewee/playhouse.rst:2404
msgid "``exclude``: A list of models to exclude."
msgstr ""

#: ../../peewee/playhouse.rst:2412
msgid ""
"This module also contains several field classes that implement additional"
" logic like encryption and compression. There is also a "
":py:class:`ManyToManyField` that makes it easy to work with simple many-"
"to-many relationships."
msgstr ""

#: ../../peewee/playhouse.rst:2414
msgid "These fields can be found in the ``playhouse.fields`` module."
msgstr ""

#: ../../peewee/playhouse.rst:2419
msgid ""
"Name for the automatically-created backref. If not provided, the "
"pluralized version of the model will be used."
msgstr ""

#: ../../peewee/playhouse.rst:2421
msgid ""
":py:class:`Model` to use for the intermediary table. If not provided, a "
"simple through table will be automatically created."
msgstr ""

#: ../../peewee/playhouse.rst:2424
msgid ""
"The :py:class:`ManyToManyField` provides a simple interface for working "
"with many-to-many relationships, inspired by Django. A many-to-many "
"relationship is typically implemented by creating a junction table with "
"foreign keys to the two models being related. For instance, if you were "
"building a syllabus manager for college students, the relationship "
"between students and courses would be many-to-many. Here is the schema "
"using standard APIs:"
msgstr ""

#: ../../peewee/playhouse.rst:2438
msgid ""
"To query the courses for a particular student, you would join through the"
" junction table:"
msgstr ""

#: ../../peewee/playhouse.rst:2451
msgid ""
"The :py:class:`ManyToManyField` is designed to simplify this use-case by "
"providing a *field-like* API for querying and modifying data in the "
"junction table. Here is how our code looks using "
":py:class:`ManyToManyField`:"
msgstr ""

#: ../../peewee/playhouse.rst:2462
msgid ""
"It does not matter from Peewee's perspective which model the "
":py:class:`ManyToManyField` goes on, since the back-reference is just the"
" mirror image. In order to write valid Python, though, you will need to "
"add the ``ManyToManyField`` on the second model so that the name of the "
"first model is in the scope."
msgstr ""

#: ../../peewee/playhouse.rst:2464
msgid ""
"We still need a junction table to store the relationships between "
"students and courses. This model can be accessed by calling the "
":py:meth:`~ManyToManyField.get_through_model` method. This is useful when"
" creating tables."
msgstr ""

#: ../../peewee/playhouse.rst:2475
msgid ""
"When accessed from a model instance, the :py:class:`ManyToManyField` "
"exposes a :py:class:`SelectQuery` representing the set of related "
"objects. Let's use the interactive shell to see how all this works:"
msgstr ""

#: ../../peewee/playhouse.rst:2487
msgid ""
"To add new relationships between objects, you can either assign the "
"objects directly to the ``ManyToManyField`` attribute, or call the "
":py:meth:`~ManyToManyField.add` method. The difference between the two is"
" that simply assigning will clear out any existing relationships, whereas"
" ``add()`` can preserve existing relationships."
msgstr ""

#: ../../peewee/playhouse.rst:2506
msgid ""
"This is quite a few courses, so let's remove the 200-level english "
"courses. To remove objects, use the :py:meth:`~ManyToManyField.remove` "
"method."
msgstr ""

#: ../../peewee/playhouse.rst:2515
msgid ""
"To remove all relationships from a collection, you can use the "
":py:meth:`~SelectQuery.clear` method. Let's say that English 101 is "
"canceled, so we need to remove all the students from it:"
msgstr ""

#: ../../peewee/playhouse.rst:2522
msgid ""
"For an overview of implementing many-to-many relationships using standard"
" Peewee APIs, check out the :ref:`manytomany` section. For all but the "
"most simple cases, you will be better off implementing many-to-many using"
" the standard APIs."
msgstr ""

#: ../../peewee/playhouse.rst:2526 ../../peewee/playhouse.rst:2551
msgid ""
"Either a :py:class:`Model` instance, a list of model instances, or a "
":py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:2527
msgid "Whether to remove existing relationships first."
msgstr ""

#: ../../peewee/playhouse.rst:2529
msgid ""
"Associate ``value`` with the current instance. You can pass in a single "
"model instance, a list of model instances, or even a "
":py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:2553
msgid ""
"Disassociate ``value`` from the current instance. Like "
":py:meth:`~ManyToManyField.add`, you can pass in a model instance, a list"
" of model instances, or even a :py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:2573
msgid "Remove all associated objects."
msgstr ""

#: ../../peewee/playhouse.rst:2586
msgid ""
"Return the :py:class:`Model` representing the many-to-many junction "
"table. This can be specified manually when the field is being "
"instantiated using the ``through_model`` parameter. If a "
"``through_model`` is not specified, one will automatically be created."
msgstr ""

#: ../../peewee/playhouse.rst:2588
msgid ""
"When creating tables for an application that uses "
":py:class:`ManyToManyField`, **you must create the through table "
"expicitly**."
msgstr ""

#: ../../peewee/playhouse.rst:2603
msgid ""
"In some instances, you may need to obtain a reference to a through model "
"before that model is actually defined. In order to avoid weird circular "
"logic, you can use the ``DeferredThroughModel`` as a placeholder, then "
"\"fill it in\" when you're ready."
msgstr ""

#: ../../peewee/playhouse.rst:2629
msgid "Initialize the deferred placeholder with the appropriate model class."
msgstr ""

#: ../../peewee/playhouse.rst:2633
msgid ""
"``CompressedField`` stores compressed data using the specified algorithm."
" This field extends :py:class:`BlobField`, transparently storing a "
"compressed representation of the data in the database."
msgstr ""

#: ../../peewee/playhouse.rst:2635
msgid "A value from 0 to 9."
msgstr ""

#: ../../peewee/playhouse.rst:2636
msgid "Either ``'zlib'`` or ``'bz2'``."
msgstr ""

#: ../../peewee/playhouse.rst:2640
msgid ""
"``PasswordField`` stores a password hash and lets you verify it. The "
"password is hashed when it is saved to the database and after reading it "
"from the database you can call ``check_password (password) -> bool`` on "
"it."
msgstr ""

#: ../../peewee/playhouse.rst:2642
msgid "Indicates the work factor, it does 2^n iterations."
msgstr ""

#: ../../peewee/playhouse.rst:2644
msgid ""
"This field requires `bcrypt <https://github.com/pyca/bcrypt/>`_, which "
"can be installed by running ``pip install bcrypt``."
msgstr ""

#: ../../peewee/playhouse.rst:2648
msgid ""
"``AESEncryptedField`` encrypts its contents before storing them in the "
"database."
msgstr ""

#: ../../peewee/playhouse.rst:2650
msgid "Encryption key."
msgstr ""

#: ../../peewee/playhouse.rst:2652
msgid ""
"This field requires `pycrypto "
"<https://www.dlitz.net/software/pycrypto/>`_, which can be installed by "
"running ``pip install pycrypto``."
msgstr ""

#: ../../peewee/playhouse.rst:2657
msgid "A field capable of storing arbitrary Python objects."
msgstr ""

#: ../../peewee/playhouse.rst:2659
msgid "If the ``cPickle`` module is available, it will be used."
msgstr ""

#: ../../peewee/playhouse.rst:2664
msgid "Generic foreign keys"
msgstr "一般的な外部キー"

#: ../../peewee/playhouse.rst:2666
msgid ""
"The ``gfk`` module provides a Generic ForeignKey (GFK), similar to "
"Django.  A GFK is composed of two columns: an object ID and an object "
"type identifier.  The object types are collected in a global registry "
"(``all_models``)."
msgstr ""

#: ../../peewee/playhouse.rst:2670
msgid "How a :py:class:`GFKField` is resolved:"
msgstr ""

#: ../../peewee/playhouse.rst:2672
msgid "Look up the object type in the global registry (returns a model class)"
msgstr ""

#: ../../peewee/playhouse.rst:2673
msgid "Look up the model instance by object ID"
msgstr ""

#: ../../peewee/playhouse.rst:2675
msgid ""
"In order to use Generic ForeignKeys, your application's models *must* "
"subclass ``playhouse.gfk.Model``.  This ensures that the model class will"
" be added to the global registry."
msgstr ""

#: ../../peewee/playhouse.rst:2679
msgid ""
"GFKs themselves are not actually a field and will not add a column to "
"your table."
msgstr ""

#: ../../peewee/playhouse.rst:2682
msgid ""
"Like regular ForeignKeys, GFKs support a \"back-reference\" via the "
":py:class:`ReverseGFK` descriptor."
msgstr ""

#: ../../peewee/playhouse.rst:2686
msgid "How to use GFKs"
msgstr ""

#: ../../peewee/playhouse.rst:2688
msgid "Be sure your model subclasses ``playhouse.gfk.Model``"
msgstr ""

#: ../../peewee/playhouse.rst:2689
msgid "Add a :py:class:`CharField` to store the ``object_type``"
msgstr ""

#: ../../peewee/playhouse.rst:2690
msgid ""
"Add a field to store the ``object_id`` (usually a "
":py:class:`IntegerField`)"
msgstr ""

#: ../../peewee/playhouse.rst:2691
msgid ""
"Add a :py:class:`GFKField` and instantiate it with the names of the "
"``object_type`` and ``object_id`` fields."
msgstr ""

#: ../../peewee/playhouse.rst:2693
msgid "(optional) On any other models, add a :py:class:`ReverseGFK` descriptor"
msgstr ""

#: ../../peewee/playhouse.rst:2713
msgid "How you use these is pretty straightforward hopefully:"
msgstr ""

#: ../../peewee/playhouse.rst:2749
msgid "GFK API"
msgstr ""

#: ../../peewee/playhouse.rst:2753
msgid ""
"Provide a clean API for storing \"generic\" foreign keys.  Generic "
"foreign keys are comprised of an object type, which maps to a model "
"class, and an object id, which maps to the primary key of the related "
"model class."
msgstr ""

#: ../../peewee/playhouse.rst:2757
msgid ""
"Setting the GFKField on a model will automatically populate the "
"``model_type_field`` and ``model_id_field``.  Similarly, getting the "
"GFKField on a model instance will \"resolve\" the two fields, first "
"looking up the model class, then looking up the instance by ID."
msgstr ""

#: ../../peewee/playhouse.rst:2764
msgid "Back-reference support for :py:class:`GFKField`."
msgstr ""

#: ../../peewee/playhouse.rst:2769
msgid "Hybrid Attributes"
msgstr "ハイブリッド属性"

#: ../../peewee/playhouse.rst:2771
msgid ""
"Hybrid attributes encapsulate functionality that operates at both the "
"Python *and* SQL levels. The idea for hybrid attributes comes from a "
"feature of the `same name in SQLAlchemy "
"<http://docs.sqlalchemy.org/en/improve_toc/orm/extensions/hybrid.html>`_."
" Consider the following example:"
msgstr ""

#: ../../peewee/playhouse.rst:2787
msgid ""
"The *hybrid attribute* gets its name from the fact that the ``length`` "
"attribute will behave differently depending on whether it is accessed via"
" the ``Interval`` class or an ``Interval`` instance."
msgstr ""

#: ../../peewee/playhouse.rst:2789
msgid "If accessed via an instance, then it behaves just as you would expect."
msgstr ""

#: ../../peewee/playhouse.rst:2791
msgid ""
"If accessed via the ``Interval.length`` class attribute, however, the "
"length calculation will be expressed as a SQL expression. For example:"
msgstr ""

#: ../../peewee/playhouse.rst:2797
msgid "This query will be equivalent to the following SQL:"
msgstr ""

#: ../../peewee/playhouse.rst:2805
msgid ""
"The ``hybrid`` module also contains a decorator for implementing hybrid "
"methods which can accept parameters. As with hybrid properties, when "
"accessed via a model instance, then the function executes normally as-"
"written. When the hybrid method is called on the class, however, it will "
"generate a SQL expression."
msgstr ""

#: ../../peewee/playhouse.rst:2813 ../../peewee/playhouse.rst:2849
#: ../../peewee/querying.rst:666
msgid "This query is equivalent to the following SQL:"
msgstr ""

#: ../../peewee/playhouse.rst:2821
msgid ""
"There is an additional API for situations where the python implementation"
" differs slightly from the SQL implementation. Let's add a ``radius`` "
"method to the ``Interval`` model. Because this method calculates an "
"absolute value, we will use the Python ``abs()`` function for the "
"instance portion and the ``fn.ABS()`` SQL function for the class portion."
msgstr ""

#: ../../peewee/playhouse.rst:2841
msgid ""
"What is neat is that both the ``radius`` implementations refer to the "
"``length`` hybrid attribute! When accessed via an ``Interval`` instance, "
"the radius calculation will be executed in Python. When invoked via an "
"``Interval`` class, we will get the appropriate SQL."
msgstr ""

#: ../../peewee/playhouse.rst:2857
msgid "Pretty neat, right? Thanks for the cool idea, SQLAlchemy!"
msgstr ""

#: ../../peewee/playhouse.rst:2860
msgid "Hybrid API"
msgstr ""

#: ../../peewee/playhouse.rst:2864
msgid ""
"Method decorator that allows the definition of a Python object method "
"with both instance-level and class-level behavior."
msgstr ""

#: ../../peewee/playhouse.rst:2878
msgid ""
"When called with an ``Interval`` instance, the ``contains`` method will "
"behave as you would expect. When called as a classmethod, though, a SQL "
"expression will be generated:"
msgstr ""

#: ../../peewee/playhouse.rst:2884 ../../peewee/playhouse.rst:2930
msgid "Would generate the following SQL:"
msgstr ""

#: ../../peewee/playhouse.rst:2894
msgid "Method decorator for specifying the SQL-expression producing method."
msgstr ""

#: ../../peewee/playhouse.rst:2898
msgid ""
"Method decorator that allows the definition of a Python object property "
"with both instance-level and class-level behavior."
msgstr ""

#: ../../peewee/playhouse.rst:2920
msgid ""
"When accessed on an ``Interval`` instance, the ``length`` and ``radius`` "
"properties will behave as you would expect. When accessed as class "
"attributes, though, a SQL expression will be generated instead:"
msgstr ""

#: ../../peewee/playhouse.rst:2944
msgid "Key/Value Store"
msgstr "キーバリューストア"

#: ../../peewee/playhouse.rst:2946
msgid ""
"Provides a simple key/value store, using a dictionary API.  By default "
"the the :py:class:`KeyStore` will use an in-memory sqlite database, but "
"any database will work."
msgstr ""

#: ../../peewee/playhouse.rst:2950
msgid ""
"To start using the key-store, create an instance and pass it a field to "
"use for the values."
msgstr ""

#: ../../peewee/playhouse.rst:2961
msgid ""
"To store arbitrary python objects, use the :py:class:`PickledKeyStore`, "
"which stores values in a pickled :py:class:`BlobField`."
msgstr ""

#: ../../peewee/playhouse.rst:2964
msgid ""
"If your objects are JSON-serializable, you can also use the "
":py:class:`JSONKeyStore`, which stores the values as JSON-encoded "
"strings."
msgstr ""

#: ../../peewee/playhouse.rst:2966
msgid ""
"Using the :py:class:`KeyStore` it is possible to use \"expressions\" to "
"retrieve values from the dictionary.  For instance, imagine you want to "
"get all keys which contain a certain substring:"
msgstr ""

#: ../../peewee/playhouse.rst:2976
msgid "KeyStore API"
msgstr ""

#: ../../peewee/playhouse.rst:2980
msgid ""
"Lightweight dictionary interface to a model containing a key and value. "
"Implements common dictionary methods, such as ``__getitem__``, "
"``__setitem__``, ``get``, ``pop``, ``items``, ``keys``, and ``values``."
msgstr ""

#: ../../peewee/playhouse.rst:2984
msgid ""
"Field instance to use as value field, e.g. an instance of "
":py:class:`TextField`."
msgstr ""

#: ../../peewee/playhouse.rst:2986
msgid "Whether the keys should be returned in sorted order"
msgstr ""

#: ../../peewee/playhouse.rst:2987
msgid ""
":py:class:`Database` class to use for the storage backend.  If none is "
"supplied, an in-memory Sqlite DB will be used."
msgstr ""

#: ../../peewee/playhouse.rst:3008
msgid ""
"Identical to the :py:class:`KeyStore` except the values are stored as "
"JSON-encoded strings, so you can store complex data-types like "
"dictionaries and lists."
msgstr ""

#: ../../peewee/playhouse.rst:3023
msgid ""
"Identical to the :py:class:`KeyStore` except *anything* can be stored as "
"a value in the dictionary.  The storage for the value will be a pickled "
":py:class:`BlobField`."
msgstr ""

#: ../../peewee/playhouse.rst:3041
msgid "Shortcuts"
msgstr "ショートカット"

#: ../../peewee/playhouse.rst:3043
msgid ""
"This module contains helper functions for expressing things that would "
"otherwise be somewhat verbose or cumbersome using peewee's APIs. There "
"are also helpers for serializing models to dictionaries and vice-versa."
msgstr ""

#: ../../peewee/playhouse.rst:3047
msgid "A SQL expression or can be ``None``."
msgstr ""

#: ../../peewee/playhouse.rst:3048
msgid ""
"An iterable containing one or more 2-tuples comprised of an expression "
"and return value."
msgstr ""

#: ../../peewee/playhouse.rst:3050
msgid "default if none of the cases match."
msgstr ""

#: ../../peewee/playhouse.rst:3052
msgid "Example SQL case statements:"
msgstr ""

#: ../../peewee/playhouse.rst:3074
msgid "Equivalent function invocations:"
msgstr ""

#: ../../peewee/playhouse.rst:3086
msgid ""
"You can specify a value for the CASE expression using the ``alias()`` "
"method:"
msgstr ""

#: ../../peewee/playhouse.rst:3098
msgid ""
"A peewee :py:class:`Node`, for instance a :py:class:`Field` or an "
":py:class:`Expression`."
msgstr ""

#: ../../peewee/playhouse.rst:3099
msgid "The type name to cast to, e.g. ``'int'``."
msgstr ""

#: ../../peewee/playhouse.rst:3100
msgid "a function call to cast the node as the given type."
msgstr ""

#: ../../peewee/playhouse.rst:3118
msgid ""
"Convert a model instance (and optionally any related instances) to a "
"dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3121
msgid "Whether foreign-keys should be recursed."
msgstr ""

#: ../../peewee/playhouse.rst:3122
msgid "Whether lists of related objects should be recursed."
msgstr ""

#: ../../peewee/playhouse.rst:3123
msgid ""
"A list (or set) of field instances which should be included in the result"
" dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3124
msgid ""
"A list (or set) of field instances which should be excluded from the "
"result dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3125
msgid ""
"A list of attribute or method names on the instance which should be "
"included in the dictionary."
msgstr ""

#: ../../peewee/playhouse.rst:3126
msgid ""
"The :py:class:`SelectQuery` that created this model instance. Only the "
"fields and values explicitly selected by the query will be serialized."
msgstr ""

#: ../../peewee/playhouse.rst:3166
msgid ""
"Convert a dictionary of data to a model instance, creating related "
"instances where appropriate."
msgstr ""

#: ../../peewee/playhouse.rst:3169
msgid "The model class to construct."
msgstr ""

#: ../../peewee/playhouse.rst:3170
msgid ""
"A dictionary of data. Foreign keys can be included as nested "
"dictionaries, and back-references as lists of dictionaries."
msgstr ""

#: ../../peewee/playhouse.rst:3171
msgid "Whether to allow unrecognized (non-field) attributes."
msgstr ""

#: ../../peewee/playhouse.rst:3204
msgid ""
"When mixed-in with a vendor-specific :py:class:`Database` subclass, this "
"class overrides the :py:meth:`~Database.execute_sql` method to "
"automatically reconnect and retry queries that fail due to an "
"``OperationalError``. The query that failed will be retried only once, "
"and if it fails twice an exception will be raised."
msgstr ""

#: ../../peewee/playhouse.rst:3223
msgid "Signal support"
msgstr "シグナルサポート"

#: ../../peewee/playhouse.rst:3225
msgid ""
"Models with hooks for signals (a-la django) are provided in "
"``playhouse.signals``. To use the signals, you will need all of your "
"project's models to be a subclass of ``playhouse.signals.Model``, which "
"overrides the necessary methods to provide support for the various "
"signals."
msgstr ""

#: ../../peewee/playhouse.rst:3241
msgid ""
"For what I hope are obvious reasons, Peewee signals do not work when you "
"use the :py:meth:`Model.insert`, :py:meth:`Model.update`, or "
":py:meth:`Model.delete` methods. These methods generate queries that "
"execute beyond the scope of the ORM, and the ORM does not know about "
"which model instances might or might not be affected when the query "
"executes."
msgstr ""

#: ../../peewee/playhouse.rst:3243
msgid ""
"Signals work by hooking into the higher-level peewee APIs like "
":py:meth:`Model.save` and :py:meth:`Model.delete_instance`, where the "
"affected model instance is known ahead of time."
msgstr ""

#: ../../peewee/playhouse.rst:3245
msgid "The following signals are provided:"
msgstr ""

#: ../../peewee/playhouse.rst:3249
msgid "``pre_save``"
msgstr ""

#: ../../peewee/playhouse.rst:3248
msgid ""
"Called immediately before an object is saved to the database.  Provides "
"an additional keyword argument ``created``, indicating whether the model "
"is being saved for the first time or updated."
msgstr ""

#: ../../peewee/playhouse.rst:3253
msgid "``post_save``"
msgstr ""

#: ../../peewee/playhouse.rst:3252
msgid ""
"Called immediately after an object is saved to the database.  Provides an"
" additional keyword argument ``created``, indicating whether the model is"
" being saved for the first time or updated."
msgstr ""

#: ../../peewee/playhouse.rst:3256
msgid "``pre_delete``"
msgstr ""

#: ../../peewee/playhouse.rst:3256
msgid ""
"Called immediately before an object is deleted from the database when "
":py:meth:`Model.delete_instance` is used."
msgstr ""

#: ../../peewee/playhouse.rst:3259
msgid "``post_delete``"
msgstr ""

#: ../../peewee/playhouse.rst:3259
msgid ""
"Called immediately after an object is deleted from the database when "
":py:meth:`Model.delete_instance` is used."
msgstr ""

#: ../../peewee/playhouse.rst:3261
msgid "``pre_init``"
msgstr ""

#: ../../peewee/playhouse.rst:3262
msgid "Called when a model class is first instantiated"
msgstr ""

#: ../../peewee/playhouse.rst:3266
msgid "``post_init``"
msgstr ""

#: ../../peewee/playhouse.rst:3264
msgid ""
"Called after a model class has been instantiated and the fields have been"
" populated, for example when being selected as part of a database query."
msgstr ""

#: ../../peewee/playhouse.rst:3269
msgid "Connecting handlers"
msgstr ""

#: ../../peewee/playhouse.rst:3271
msgid ""
"Whenever a signal is dispatched, it will call any handlers that have been"
" registered. This allows totally separate code to respond to events like "
"model save and delete."
msgstr ""

#: ../../peewee/playhouse.rst:3274
msgid ""
"The :py:class:`Signal` class provides a :py:meth:`~Signal.connect` "
"method, which takes a callback function and two optional parameters for "
"\"sender\" and \"name\".  If specified, the \"sender\" parameter should "
"be a single model class and allows your callback to only receive signals "
"from that one model class.  The \"name\" parameter is used as a "
"convenient alias in the event you wish to unregister your signal handler."
msgstr ""

#: ../../peewee/playhouse.rst:3292
msgid ""
"All signal handlers accept as their first two arguments ``sender`` and "
"``instance``, where ``sender`` is the model class and ``instance`` is the"
" actual model being acted upon."
msgstr ""

#: ../../peewee/playhouse.rst:3296
msgid ""
"If you'd like, you can also use a decorator to connect signal handlers.  "
"This is functionally equivalent to the above example:"
msgstr ""

#: ../../peewee/playhouse.rst:3307
msgid "Signal API"
msgstr ""

#: ../../peewee/playhouse.rst:3311
msgid ""
"Stores a list of receivers (callbacks) and calls them when the \"send\" "
"method is invoked."
msgstr ""

#: ../../peewee/playhouse.rst:3315
msgid ""
"Add the receiver to the internal list of receivers, which will be called "
"whenever the signal is sent."
msgstr ""

#: ../../peewee/playhouse.rst:3318
msgid ""
"a callable that takes at least two parameters, a \"sender\", which is the"
" Model subclass that triggered the signal, and an \"instance\", which is "
"the actual model instance."
msgstr ""

#: ../../peewee/playhouse.rst:3321
msgid ""
"if specified, only instances of this model class will trigger the "
"receiver callback."
msgstr ""

#: ../../peewee/playhouse.rst:3323 ../../peewee/playhouse.rst:3339
msgid "a short alias"
msgstr ""

#: ../../peewee/playhouse.rst:3334
msgid ""
"Disconnect the given receiver (or the receiver with the given name alias)"
" so that it no longer is called.  Either the receiver or the name must be"
" provided."
msgstr ""

#: ../../peewee/playhouse.rst:3338
msgid "the callback to disconnect"
msgstr ""

#: ../../peewee/playhouse.rst:3347
msgid ""
"Iterates over the receivers and will call them in the order in which they"
" were connected.  If the receiver specified a sender, it will only be "
"called if the instance is an instance of the sender."
msgstr ""

#: ../../peewee/playhouse.rst:3351
msgid "a model instance"
msgstr ""

#: ../../peewee/playhouse.rst:3370
msgid "pwiz, a model generator"
msgstr "pwiz、モデルジェネレータ"

#: ../../peewee/playhouse.rst:3372
msgid ""
"``pwiz`` is a little script that ships with peewee and is capable of "
"introspecting an existing database and generating model code suitable for"
" interacting with the underlying data.  If you have a database already, "
"pwiz can give you a nice boost by generating skeleton code with correct "
"column affinities and foreign keys."
msgstr ""

#: ../../peewee/playhouse.rst:3377
msgid ""
"If you install peewee using ``setup.py install``, pwiz will be installed "
"as a \"script\" and you can just run:"
msgstr ""

#: ../../peewee/playhouse.rst:3385
msgid "This will print a bunch of models to standard output.  So you can do this:"
msgstr ""

#: ../../peewee/playhouse.rst:3401 ../../peewee/querying.rst:908
msgid "Example"
msgstr ""

#: ../../peewee/playhouse.rst:3403
msgid "-h"
msgstr ""

#: ../../peewee/playhouse.rst:3403
msgid "show help"
msgstr ""

#: ../../peewee/playhouse.rst:3404
msgid "-e"
msgstr ""

#: ../../peewee/playhouse.rst:3404
msgid "database backend"
msgstr ""

#: ../../peewee/playhouse.rst:3404
msgid "-e mysql"
msgstr ""

#: ../../peewee/playhouse.rst:3405
msgid "-H"
msgstr ""

#: ../../peewee/playhouse.rst:3405
msgid "host to connect to"
msgstr ""

#: ../../peewee/playhouse.rst:3405
msgid "-H remote.db.server"
msgstr ""

#: ../../peewee/playhouse.rst:3406
msgid "-p"
msgstr ""

#: ../../peewee/playhouse.rst:3406
msgid "port to connect on"
msgstr ""

#: ../../peewee/playhouse.rst:3406
msgid "-p 9001"
msgstr ""

#: ../../peewee/playhouse.rst:3407
msgid "-u"
msgstr ""

#: ../../peewee/playhouse.rst:3407
msgid "database user"
msgstr ""

#: ../../peewee/playhouse.rst:3407
msgid "-u postgres"
msgstr ""

#: ../../peewee/playhouse.rst:3408
msgid "-P"
msgstr ""

#: ../../peewee/playhouse.rst:3408
msgid "database password"
msgstr ""

#: ../../peewee/playhouse.rst:3408
msgid "-P secret"
msgstr ""

#: ../../peewee/playhouse.rst:3409
msgid "-s"
msgstr ""

#: ../../peewee/playhouse.rst:3409
msgid "postgres schema"
msgstr ""

#: ../../peewee/playhouse.rst:3409
msgid "-s public"
msgstr ""

#: ../../peewee/playhouse.rst:3412
msgid "The following are valid parameters for the engine:"
msgstr ""

#: ../../peewee/playhouse.rst:3414 ../../peewee/playhouse.rst:4110
msgid "sqlite"
msgstr ""

#: ../../peewee/playhouse.rst:3415
msgid "mysql"
msgstr ""

#: ../../peewee/playhouse.rst:3416
msgid "postgresql"
msgstr ""

#: ../../peewee/playhouse.rst:3421
msgid "Schema Migrations"
msgstr "スキーママイグレーション"

#: ../../peewee/playhouse.rst:3423
msgid ""
"Peewee now supports schema migrations, with well-tested support for "
"Postgresql, SQLite and MySQL. Unlike other schema migration tools, "
"peewee's migrations do not handle introspection and database "
"\"versioning\". Rather, peewee provides a number of helper functions for "
"generating and running schema-altering statements. This engine provides "
"the basis on which a more sophisticated tool could some day be built."
msgstr ""

#: ../../peewee/playhouse.rst:3429
msgid ""
"Migrations can be written as simple python scripts and executed from the "
"command-line. Since the migrations only depend on your applications "
":py:class:`Database` object, it should be easy to manage changing your "
"model definitions and maintaining a set of migration scripts without "
"introducing dependencies."
msgstr ""

#: ../../peewee/playhouse.rst:3435
msgid "Example usage"
msgstr ""

#: ../../peewee/playhouse.rst:3437
msgid "Begin by importing the helpers from the `migrate` module:"
msgstr ""

#: ../../peewee/playhouse.rst:3443
msgid ""
"Instantiate a ``migrator``. The :py:class:`SchemaMigrator` class is "
"responsible for generating schema altering operations, which can then be "
"run sequentially by the :py:func:`migrate` helper."
msgstr ""

#: ../../peewee/playhouse.rst:3457
msgid "Use :py:func:`migrate` to execute one or more operations:"
msgstr ""

#: ../../peewee/playhouse.rst:3471
msgid ""
"Migrations are not run inside a transaction. If you wish the migration to"
" run in a transaction you will need to wrap the call to `migrate` in a "
"transaction block, e.g."
msgstr ""

#: ../../peewee/playhouse.rst:3481
msgid "Supported Operations"
msgstr ""

#: ../../peewee/playhouse.rst:3483
msgid "Add new field(s) to an existing model:"
msgstr ""

#: ../../peewee/playhouse.rst:3498
msgid "Renaming a field:"
msgstr ""

#: ../../peewee/playhouse.rst:3508
msgid "Dropping a field:"
msgstr ""

#: ../../peewee/playhouse.rst:3516
msgid "Making a field nullable or not nullable:"
msgstr ""

#: ../../peewee/playhouse.rst:3530
msgid "Renaming a table:"
msgstr ""

#: ../../peewee/playhouse.rst:3538
msgid "Adding an index:"
msgstr ""

#: ../../peewee/playhouse.rst:3555
msgid "Dropping an index:"
msgstr ""

#: ../../peewee/playhouse.rst:3564
msgid "Migrations API"
msgstr ""

#: ../../peewee/playhouse.rst:3568
msgid "Execute one or more schema altering operations."
msgstr ""

#: ../../peewee/playhouse.rst:3583
msgid ""
"The :py:class:`SchemaMigrator` is responsible for generating schema-"
"altering statements."
msgstr ""

#: ../../peewee/playhouse.rst:3588
msgid "Name of the table to add column to."
msgstr ""

#: ../../peewee/playhouse.rst:3589
msgid "Name of the new column."
msgstr ""

#: ../../peewee/playhouse.rst:3590
msgid "A :py:class:`Field` instance."
msgstr ""

#: ../../peewee/playhouse.rst:3592
msgid ""
"Add a new column to the provided table. The ``field`` provided will be "
"used to generate the appropriate column definition."
msgstr ""

#: ../../peewee/playhouse.rst:3595
msgid "If the field is not nullable it must specify a default value."
msgstr ""

#: ../../peewee/playhouse.rst:3598
msgid ""
"For non-null fields, the field will initially be added as a null field, "
"then an ``UPDATE`` statement will be executed to populate the column with"
" the default value. Finally, the column will be marked as not null."
msgstr ""

#: ../../peewee/playhouse.rst:3604
msgid "Name of the table to drop column from."
msgstr ""

#: ../../peewee/playhouse.rst:3605
msgid "Name of the column to drop."
msgstr ""

#: ../../peewee/playhouse.rst:3606
msgid "Whether the column should be dropped with `CASCADE`."
msgstr ""

#: ../../peewee/playhouse.rst:3610
msgid "Name of the table containing column to rename."
msgstr ""

#: ../../peewee/playhouse.rst:3611
msgid "Current name of the column."
msgstr ""

#: ../../peewee/playhouse.rst:3612
msgid "New name for the column."
msgstr ""

#: ../../peewee/playhouse.rst:3616 ../../peewee/playhouse.rst:3621
msgid "Name of table containing column."
msgstr ""

#: ../../peewee/playhouse.rst:3617
msgid "Name of the column to make not nullable."
msgstr ""

#: ../../peewee/playhouse.rst:3622
msgid "Name of the column to make nullable."
msgstr ""

#: ../../peewee/playhouse.rst:3626
msgid "Current name of the table."
msgstr ""

#: ../../peewee/playhouse.rst:3627
msgid "New name for the table."
msgstr ""

#: ../../peewee/playhouse.rst:3631
msgid "Name of table on which to create the index."
msgstr ""

#: ../../peewee/playhouse.rst:3632
msgid "List of columns which should be indexed."
msgstr ""

#: ../../peewee/playhouse.rst:3633
msgid "Whether the new index should specify a unique constraint."
msgstr ""

#: ../../peewee/playhouse.rst:3637
msgid ""
":param str table Name of the table containing the index to be dropped. "
":param str index_name: Name of the index to be dropped."
msgstr ""

#: ../../peewee/playhouse.rst:3642
msgid "Generate migrations for Postgresql databases."
msgstr ""

#: ../../peewee/playhouse.rst:3646
msgid "Generate migrations for SQLite databases."
msgstr ""

#: ../../peewee/playhouse.rst:3650
msgid "Generate migrations for MySQL databases."
msgstr ""

#: ../../peewee/playhouse.rst:3656
msgid "Reflection"
msgstr "リフレクション"

#: ../../peewee/playhouse.rst:3658
msgid ""
"The reflection module contains helpers for introspecting existing "
"databases. This module is used internally by several other modules in the"
" playhouse, including :ref:`dataset` and :ref:`pwiz`."
msgstr ""

#: ../../peewee/playhouse.rst:3662
msgid ""
"Metadata can be extracted from a database by instantiating an "
":py:class:`Introspector`. Rather than instantiating this class directly, "
"it is recommended to use the factory method "
":py:meth:`~Introspector.from_database`."
msgstr ""

#: ../../peewee/playhouse.rst:3666
msgid ""
"Creates an :py:class:`Introspector` instance suitable for use with the "
"given database."
msgstr ""

#: ../../peewee/playhouse.rst:3669
msgid "an optional schema (supported by some databases)."
msgstr ""

#: ../../peewee/playhouse.rst:3686
msgid ""
"Introspect the database, reading in the tables, columns, and foreign key "
"constraints, then generate a dictionary mapping each database table to a "
"dynamically-generated :py:class:`Model` class."
msgstr ""

#: ../../peewee/playhouse.rst:3688
msgid "A dictionary mapping table-names to model classes."
msgstr ""

#: ../../peewee/playhouse.rst:3694
msgid "Database URL"
msgstr "データベースのURL"

#: ../../peewee/playhouse.rst:3696
msgid ""
"This module contains a helper function to generate a database connection "
"from a URL connection string."
msgstr ""

#: ../../peewee/playhouse.rst:3700
msgid "Create a :py:class:`Database` instance from the given connection URL."
msgstr ""

#: ../../peewee/playhouse.rst:3708
msgid ""
"*mysql+pool://user:passwd@ip:port/my_db?max_connections=20&stale_timeout=300*"
" will create a :py:class:`PooledMySQLDatabase` instance for the local "
"MySQL database *my_db* with max_connections set to 20 and a stale_timeout"
" setting of 300 seconds."
msgstr ""

#: ../../peewee/playhouse.rst:3710
msgid "Supported schemes:"
msgstr ""

#: ../../peewee/playhouse.rst:3712
msgid "``apsw``: :py:class:`APSWDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3713
msgid "``mysql``: :py:class:`MySQLDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3714
msgid "``mysql+pool``: :py:class:`PooledMySQLDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3715
msgid "``postgres``: :py:class:`PostgresqlDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3716
msgid "``postgres+pool``: :py:class:`PooledPostgresqlDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3717
msgid "``postgresext``: :py:class:`PostgresqlExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3718
msgid "``postgresext+pool``: :py:class:`PooledPostgresqlExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3719
msgid "``sqlite``: :py:class:`SqliteDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3720
msgid "``sqliteext``: :py:class:`SqliteExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3721
msgid "``sqlite+pool``: :py:class:`PooledSqliteDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3722
msgid "``sqliteext+pool``: :py:class:`PooledSqliteExtDatabase`"
msgstr ""

#: ../../peewee/playhouse.rst:3737
msgid ""
"Parse the information in the given URL into a dictionary containing "
"``database``, ``host``, ``port``, ``user`` and/or ``password``. "
"Additional connection arguments can be passed in the URL query string."
msgstr ""

#: ../../peewee/playhouse.rst:3739
msgid ""
"If you are using a custom database class, you can use the ``parse()`` "
"function to extract information from a URL which can then be passed in to"
" your database object."
msgstr ""

#: ../../peewee/playhouse.rst:3743
msgid "A subclass of :py:class:`Database`."
msgstr ""

#: ../../peewee/playhouse.rst:3744
msgid ""
"A list of names to use as the scheme in the URL, e.g. 'sqlite' or "
"'firebird'"
msgstr ""

#: ../../peewee/playhouse.rst:3746
msgid ""
"Register additional database class under the specified names. This "
"function can be used to extend the ``connect()`` function to support "
"additional schemes. Suppose you have a custom database class for "
"``Firebird`` named ``FirebirdDatabase``."
msgstr ""

#: ../../peewee/playhouse.rst:3758
msgid "CSV Utils"
msgstr ""

#: ../../peewee/playhouse.rst:3760
msgid ""
"This module contains helpers for dumping queries into CSV, and for "
"loading CSV data into a database.  CSV files can be introspected to "
"generate an appropriate model class for working with the data. This makes"
" it really easy to explore the data in a CSV file using Peewee and SQL."
msgstr ""

#: ../../peewee/playhouse.rst:3762
msgid ""
"Here is how you would load a CSV file into an in-memory SQLite database."
"  The call to :py:func:`load_csv` returns a :py:class:`Model` instance "
"suitable for working with the CSV data:"
msgstr ""

#: ../../peewee/playhouse.rst:3771
msgid "Now we can run queries using the new model."
msgstr ""

#: ../../peewee/playhouse.rst:3784
msgid ""
"For more information and examples check out this `blog post "
"<http://charlesleifer.com/blog/using-peewee-to-explore-csv-files/>`_."
msgstr ""

#: ../../peewee/playhouse.rst:3787
msgid "CSV Loader API"
msgstr ""

#: ../../peewee/playhouse.rst:3791
msgid ""
"Load a CSV file into the provided database or model class, returning a "
":py:class:`Model` suitable for working with the CSV data."
msgstr ""

#: ../../peewee/playhouse.rst:3794
msgid ""
"Either a :py:class:`Database` instance or a :py:class:`Model` class.  If "
"a model is not provided, one will be automatically generated for you."
msgstr ""

#: ../../peewee/playhouse.rst:3795
msgid "Path of CSV file to load."
msgstr ""

#: ../../peewee/playhouse.rst:3796
msgid ""
"A list of :py:class:`Field` instances mapping to each column in the CSV."
"  This allows you to manually specify the column types.  If not provided,"
" and a model is not provided, the field types will be determined "
"automatically."
msgstr ""

#: ../../peewee/playhouse.rst:3797
msgid ""
"A list of strings to use as field names for each column in the CSV.  If "
"not provided, and a model is not provided, the field names will be "
"determined by looking at the header row of the file.  If no header "
"exists, then the fields will be given generic names."
msgstr ""

#: ../../peewee/playhouse.rst:3798
msgid "Whether the first row is a header."
msgstr ""

#: ../../peewee/playhouse.rst:3799
msgid ""
"Number of rows to look at when introspecting data types.  If set to "
"``0``, then a generic field type will be used for all fields."
msgstr ""

#: ../../peewee/playhouse.rst:3800
msgid ""
"a :py:class:`RowConverter` instance to use for introspecting the CSV.  If"
" not provided, one will be created."
msgstr ""

#: ../../peewee/playhouse.rst:3801
msgid ""
"The name of the database table to load data into.  If this value is not "
"provided, it will be determined using the filename of the CSV file.  If a"
" model is provided, this value is ignored."
msgstr ""

#: ../../peewee/playhouse.rst:3802
msgid ""
"Arbitrary keyword arguments to pass to the ``csv.reader`` object, such as"
" the dialect, separator, etc."
msgstr ""

#: ../../peewee/playhouse.rst:3803
msgid "A :py:class:`Model` suitable for querying the CSV data."
msgstr ""

#: ../../peewee/playhouse.rst:3805
msgid "Basic example -- field names and types will be introspected:"
msgstr ""

#: ../../peewee/playhouse.rst:3814
msgid "Using a pre-defined model:"
msgstr ""

#: ../../peewee/playhouse.rst:3824
msgid "Specifying fields:"
msgstr ""

#: ../../peewee/playhouse.rst:3833
msgid "Dumping CSV"
msgstr ""

#: ../../peewee/playhouse.rst:3837
msgid "A peewee :py:class:`SelectQuery` to dump as CSV."
msgstr ""

#: ../../peewee/playhouse.rst:3838
msgid "Either a filename or a file-like object."
msgstr ""

#: ../../peewee/playhouse.rst:3839
msgid ""
"Whether to generate a CSV header row consisting of the names of the "
"selected columns."
msgstr ""

#: ../../peewee/playhouse.rst:3840
msgid "Whether the file should be closed after writing the query data."
msgstr ""

#: ../../peewee/playhouse.rst:3841
msgid "Whether new data should be appended to the end of the file."
msgstr ""

#: ../../peewee/playhouse.rst:3842
msgid "A python ``csv.writer`` instance to use."
msgstr ""

#: ../../peewee/playhouse.rst:3856
msgid "Connection pool"
msgstr "コネクションプール"

#: ../../peewee/playhouse.rst:3858
msgid ""
"The ``pool`` module contains a number of :py:class:`Database` classes "
"that provide connection pooling for PostgreSQL and MySQL databases. The "
"pool works by overriding the methods on the :py:class:`Database` class "
"that open and close connections to the backend. The pool can specify a "
"timeout after which connections are recycled, as well as an upper bound "
"on the number of open connections."
msgstr ""

#: ../../peewee/playhouse.rst:3860
msgid ""
"In a multi-threaded application, up to `max_connections` will be opened. "
"Each thread (or, if using gevent, greenlet) will have it's own "
"connection."
msgstr ""

#: ../../peewee/playhouse.rst:3862
msgid ""
"In a single-threaded application, only one connection will be created. It"
" will be continually recycled until either it exceeds the stale timeout "
"or is closed explicitly (using `.manual_close()`)."
msgstr ""

#: ../../peewee/playhouse.rst:3864
msgid ""
"**By default, all your application needs to do is ensure that connections"
" are closed when you are finished with them, and they will be returned to"
" the pool**. For web applications, this typically means that at the "
"beginning of a request, you will open a connection, and when you return a"
" response, you will close the connection."
msgstr ""

#: ../../peewee/playhouse.rst:3866
msgid "Simple Postgres pool example code:"
msgstr ""

#: ../../peewee/playhouse.rst:3883
msgid ""
"That's it! If you would like finer-grained control over the pool of "
"connections, check out the :ref:`advanced_connection_management` section."
msgstr ""

#: ../../peewee/playhouse.rst:3886
msgid "Pool APIs"
msgstr ""

#: ../../peewee/playhouse.rst:3890
msgid "Mixin class intended to be used with a subclass of :py:class:`Database`."
msgstr ""

#: ../../peewee/playhouse.rst:3892
msgid "The name of the database or database file."
msgstr ""

#: ../../peewee/playhouse.rst:3893
msgid "Maximum number of connections. Provide ``None`` for unlimited."
msgstr ""

#: ../../peewee/playhouse.rst:3894
msgid "Number of seconds to allow connections to be used."
msgstr ""

#: ../../peewee/playhouse.rst:3895
msgid "Arbitrary keyword arguments passed to database class."
msgstr ""

#: ../../peewee/playhouse.rst:3897
msgid ""
"Connections will not be closed exactly when they exceed their "
"`stale_timeout`. Instead, stale connections are only closed when a new "
"connection is requested."
msgstr ""

#: ../../peewee/playhouse.rst:3899
msgid ""
"If the number of open connections exceeds `max_connections`, a "
"`ValueError` will be raised."
msgstr ""

#: ../../peewee/playhouse.rst:3903
msgid ""
"Request a connection from the pool. If there are no available connections"
" a new one will be opened."
msgstr ""

#: ../../peewee/playhouse.rst:3907
msgid ""
"By default `conn` will not be closed and instead will be returned to the "
"pool of available connections. If `close_conn=True`, then `conn` will be "
"closed and *not* be returned to the pool."
msgstr ""

#: ../../peewee/playhouse.rst:3911
msgid "Close the currently-open connection without returning it to the pool."
msgstr ""

#: ../../peewee/playhouse.rst:3915
msgid ""
"Subclass of :py:class:`PostgresqlDatabase` that mixes in the "
":py:class:`PooledDatabase` helper."
msgstr ""

#: ../../peewee/playhouse.rst:3919
msgid ""
"Subclass of :py:class:`PostgresqlExtDatabase` that mixes in the "
":py:class:`PooledDatabase` helper. The :py:class:`PostgresqlExtDatabase` "
"is a part of the :ref:`postgres_ext` module and provides support for many"
" Postgres-specific features."
msgstr ""

#: ../../peewee/playhouse.rst:3925
msgid ""
"Subclass of :py:class:`MySQLDatabase` that mixes in the "
":py:class:`PooledDatabase` helper."
msgstr ""

#: ../../peewee/playhouse.rst:3929
msgid "Persistent connections for SQLite apps."
msgstr ""

#: ../../peewee/playhouse.rst:3933
msgid ""
"Persistent connections for SQLite apps, using the :ref:`sqlite_ext` "
"advanced database driver :py:class:`SqliteExtDatabase`."
msgstr ""

#: ../../peewee/playhouse.rst:3941
msgid ""
"The ``read_slave`` module contains a :py:class:`Model` subclass that can "
"be used to automatically execute ``SELECT`` queries against different "
"database(s). This might be useful if you have your databases in a master "
"/ slave configuration."
msgstr ""

#: ../../peewee/playhouse.rst:3947
msgid "Model subclass that will route ``SELECT`` queries to a different database."
msgstr ""

#: ../../peewee/playhouse.rst:3949
msgid "Master and read-slaves are specified using ``Model.Meta``:"
msgstr ""

#: ../../peewee/playhouse.rst:3968
msgid ""
"When you execute writes (or deletes), they will be executed against the "
"master database:"
msgstr ""

#: ../../peewee/playhouse.rst:3975
msgid "When you execute a read query, it will run against one of the replicas:"
msgstr ""

#: ../../peewee/playhouse.rst:3982
msgid ""
"To force a ``SELECT`` query against the master database, manually create "
"the :py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:3990
msgid ""
"Queries will be dispatched among the ``read_slaves`` in round-robin "
"fashion."
msgstr ""

#: ../../peewee/playhouse.rst:3995
msgid "Test Utils"
msgstr ""

#: ../../peewee/playhouse.rst:3997
msgid "Contains utilities helpful when testing peewee projects."
msgstr ""

#: ../../peewee/playhouse.rst:4001
msgid ""
"Context manager that lets you use a different database with a set of "
"models.  Models can also be automatically created and dropped."
msgstr ""

#: ../../peewee/playhouse.rst:4004
msgid ""
"This context manager helps make it possible to test your peewee models "
"using a \"test-only\" database."
msgstr ""

#: ../../peewee/playhouse.rst:4007
msgid "Database to use with the given models"
msgstr ""

#: ../../peewee/playhouse.rst:4008
msgid "a ``list`` of :py:class:`Model` classes to use with the ``db``"
msgstr ""

#: ../../peewee/playhouse.rst:4009
msgid "Whether tables should be automatically created and dropped."
msgstr ""

#: ../../peewee/playhouse.rst:4011
msgid "Whether the table create / drop should fail silently."
msgstr ""

#: ../../peewee/playhouse.rst:4045
msgid ""
"Context manager that will count the number of queries executed within the"
" context."
msgstr ""

#: ../../peewee/playhouse.rst:4048
msgid "Only count *SELECT* queries."
msgstr ""

#: ../../peewee/playhouse.rst:4060
msgid "The number of queries executed."
msgstr ""

#: ../../peewee/playhouse.rst:4064
msgid ""
"Return a list of 2-tuples consisting of the SQL query and a list of "
"parameters."
msgstr ""

#: ../../peewee/playhouse.rst:4070
msgid ""
"Function or method decorator that will raise an ``AssertionError`` if the"
" number of queries executed in the decorated function does not equal the "
"expected number."
msgstr ""

#: ../../peewee/playhouse.rst:4084
msgid "This function can also be used as a context manager:"
msgstr ""

#: ../../peewee/playhouse.rst:4096
msgid "pskel"
msgstr ""

#: ../../peewee/playhouse.rst:4098
msgid ""
"I often find myself writing very small scripts with peewee. *pskel* will "
"generate the boilerplate code for a basic peewee script."
msgstr ""

#: ../../peewee/playhouse.rst:4100
msgid "Usage::"
msgstr ""

#: ../../peewee/playhouse.rst:4104
msgid "*pskel* accepts the following options:"
msgstr ""

#: ../../peewee/playhouse.rst:4107
msgid "Default"
msgstr ""

#: ../../peewee/playhouse.rst:4107
msgid "Description"
msgstr ""

#: ../../peewee/playhouse.rst:4109
msgid "``-l,--logging``"
msgstr ""

#: ../../peewee/playhouse.rst:4109
msgid "False"
msgstr ""

#: ../../peewee/playhouse.rst:4109
msgid "Log all queries to stdout."
msgstr ""

#: ../../peewee/playhouse.rst:4110
msgid "``-e,--engine``"
msgstr ""

#: ../../peewee/playhouse.rst:4110
msgid "Database driver to use."
msgstr ""

#: ../../peewee/playhouse.rst:4111
msgid "``-d,--database``"
msgstr ""

#: ../../peewee/playhouse.rst:4111
msgid "``:memory:``"
msgstr ""

#: ../../peewee/playhouse.rst:4111
msgid "Database to connect to."
msgstr ""

#: ../../peewee/playhouse.rst:4114
msgid "Example::"
msgstr ""

#: ../../peewee/playhouse.rst:4118
msgid ""
"This will print the following code to *stdout* (which you can redirect "
"into a file using ``>``):"
msgstr ""

#: ../../peewee/playhouse.rst:4151
msgid "Flask Utils"
msgstr ""

#: ../../peewee/playhouse.rst:4153
msgid ""
"The ``playhouse.flask_utils`` module contains several helpers for "
"integrating peewee with the `Flask <http://flask.pocoo.org/>`_ web "
"framework."
msgstr ""

#: ../../peewee/playhouse.rst:4156
msgid "Database wrapper"
msgstr ""

#: ../../peewee/playhouse.rst:4158
msgid ""
"The :py:class:`FlaskDB` class provides a convenient way to configure a "
"peewee :py:class:`Database` instance using Flask app configuration. The "
":py:class:`FlaskDB` wrapper will also automatically set up request setup "
"and teardown handlers to ensure your connections are managed correctly."
msgstr ""

#: ../../peewee/playhouse.rst:4160
msgid "Basic usage:"
msgstr ""

#: ../../peewee/playhouse.rst:4184
msgid ""
"The above code example will create and instantiate a peewee "
":py:class:`PostgresqlDatabase` specified by the given database URL. "
"Request hooks will be configured to establish a connection when a request"
" is received, and automatically close the connection when the response is"
" sent. Lastly, the :py:class:`FlaskDB` class exposes a "
":py:attr:`FlaskDB.Model` property which can be used as a base for your "
"application's models."
msgstr ""

#: ../../peewee/playhouse.rst:4186
msgid ""
"The underlying peewee database can be accessed using the "
"``FlaskDB.database`` attribute."
msgstr ""

#: ../../peewee/playhouse.rst:4188
msgid ""
"If you prefer, you can also pass the database value directly into the "
"``FlaskDB`` object:"
msgstr ""

#: ../../peewee/playhouse.rst:4195
msgid ""
"While the above examples show using a database URL, for more advanced "
"usages you can specify a dictionary of configuration options or simply "
"pass in a peewee :py:class:`Database` instance:"
msgstr ""

#: ../../peewee/playhouse.rst:4212
msgid "Using a peewee :py:class:`Database` object:"
msgstr ""

#: ../../peewee/playhouse.rst:4221
msgid "Database with Application Factory"
msgstr ""

#: ../../peewee/playhouse.rst:4223
msgid ""
"If you prefer to use the `application factory pattern "
"<http://flask.pocoo.org/docs/0.10/patterns/appfactories/>`_, the "
":py:class:`FlaskDB` class implements an ``init_app()`` method."
msgstr ""

#: ../../peewee/playhouse.rst:4225
msgid "Using as a factory:"
msgstr ""

#: ../../peewee/playhouse.rst:4244
msgid "Query utilities"
msgstr ""

#: ../../peewee/playhouse.rst:4246
msgid ""
"The ``flask_utils`` module provides several helpers for managing queries "
"in your web app. Some common patterns include:"
msgstr ""

#: ../../peewee/playhouse.rst:4250
msgid ""
"Retrieve the object matching the given query, or return a 404 not found "
"response. A common use-case might be a detail page for a weblog. You want"
" to either retrieve the post matching the given URL, or return a 404."
msgstr ""

#: ../../peewee/playhouse.rst:4252
msgid ""
"Either a :py:class:`Model` class or a pre-filtered "
":py:class:`SelectQuery`."
msgstr ""

#: ../../peewee/playhouse.rst:4253
msgid "An arbitrarily complex peewee expression."
msgstr ""

#: ../../peewee/playhouse.rst:4267
msgid ""
"Retrieve a paginated list of objects specified by the given query. The "
"paginated object list will be dropped into the context using the given "
"``context_variable``, as well as metadata about the current page and "
"total number of pages, and finally any arbitrary context data passed as "
"keyword-arguments."
msgstr ""

#: ../../peewee/playhouse.rst:4269
msgid ""
"The page is specified using the ``page`` ``GET`` argument, e.g. ``/my-"
"object-list/?page=3`` would return the third page of objects."
msgstr ""

#: ../../peewee/playhouse.rst:4271
msgid "The name of the template to render."
msgstr ""

#: ../../peewee/playhouse.rst:4272
msgid "A :py:class:`SelectQuery` instance to paginate."
msgstr ""

#: ../../peewee/playhouse.rst:4273
msgid "The context variable name to use for the paginated object list."
msgstr ""

#: ../../peewee/playhouse.rst:4274 ../../peewee/playhouse.rst:4307
msgid "Number of objects per-page."
msgstr ""

#: ../../peewee/playhouse.rst:4275 ../../peewee/playhouse.rst:4308
msgid "The name of the ``GET`` argument which contains the page."
msgstr ""

#: ../../peewee/playhouse.rst:4276 ../../peewee/playhouse.rst:4309
msgid ""
"Whether to check that the given page is a valid page. If ``check_bounds``"
" is ``True`` and an invalid page is specified, then a 404 will be "
"returned."
msgstr ""

#: ../../peewee/playhouse.rst:4277
msgid "Arbitrary key/value pairs to pass into the template context."
msgstr ""

#: ../../peewee/playhouse.rst:4296
msgid "The template will have the following context:"
msgstr ""

#: ../../peewee/playhouse.rst:4298
msgid "``post_list``, which contains a list of up to 10 posts."
msgstr ""

#: ../../peewee/playhouse.rst:4299
msgid ""
"``page``, which contains the current page based on the value of the "
"``page`` ``GET`` parameter."
msgstr ""

#: ../../peewee/playhouse.rst:4300
msgid "``pagination``, a :py:class:`PaginatedQuery` instance."
msgstr ""

#: ../../peewee/playhouse.rst:4304
msgid "Helper class to perform pagination based on ``GET`` arguments."
msgstr ""

#: ../../peewee/playhouse.rst:4306
msgid ""
"Either a :py:class:`Model` or a :py:class:`SelectQuery` instance "
"containing the collection of records you wish to paginate."
msgstr ""

#: ../../peewee/playhouse.rst:4313
msgid ""
"Return the currently selected page, as indicated by the value of the "
"``page_var`` ``GET`` parameter. If no page is explicitly selected, then "
"this method will return 1, indicating the first page."
msgstr ""

#: ../../peewee/playhouse.rst:4317
msgid "Return the total number of possible pages."
msgstr ""

#: ../../peewee/playhouse.rst:4321
msgid ""
"Using the value of :py:meth:`~PaginatedQuery.get_page`, return the page "
"of objects requested by the user. The return value is a "
":py:class:`SelectQuery` with the appropriate ``LIMIT`` and ``OFFSET`` "
"clauses."
msgstr ""

#: ../../peewee/playhouse.rst:4323
msgid ""
"If ``check_bounds`` was set to ``True`` and the requested page contains "
"no objects, then a 404 will be raised."
msgstr ""

#: ../../peewee/querying.rst:4
msgid "Querying"
msgstr "クエリ"

#: ../../peewee/querying.rst:6
msgid ""
"This section will cover the basic CRUD operations commonly performed on a"
" relational database:"
msgstr ""

#: ../../peewee/querying.rst:8
msgid ":py:meth:`Model.create`, for executing *INSERT* queries."
msgstr ""

#: ../../peewee/querying.rst:9
msgid ""
":py:meth:`Model.save` and :py:meth:`Model.update`, for executing *UPDATE*"
" queries."
msgstr ""

#: ../../peewee/querying.rst:10
msgid ""
":py:meth:`Model.delete_instance` and :py:meth:`Model.delete`, for "
"executing *DELETE* queries."
msgstr ""

#: ../../peewee/querying.rst:11
msgid ":py:meth:`Model.select`, for executing *SELECT* queries."
msgstr ""

#: ../../peewee/querying.rst:14
msgid "Creating a new record"
msgstr "新しいレコードの作成"

#: ../../peewee/querying.rst:16
msgid ""
"You can use :py:meth:`Model.create` to create a new model instance. This "
"method accepts keyword arguments, where the keys correspond to the names "
"of the model's fields. A new instance is returned and a row is added to "
"the table."
msgstr ""

#: ../../peewee/querying.rst:23
msgid ""
"This will *INSERT* a new row into the database. The primary key will "
"automatically be retrieved and stored on the model instance."
msgstr ""

#: ../../peewee/querying.rst:25
msgid ""
"Alternatively, you can build up a model instance programmatically and "
"then call :py:meth:`~Model.save`:"
msgstr ""

#: ../../peewee/querying.rst:41
msgid ""
"When a model has a foreign key, you can directly assign a model instance "
"to the foreign key field when creating a new record."
msgstr ""

#: ../../peewee/querying.rst:47
msgid "You can also use the value of the related object's primary key:"
msgstr ""

#: ../../peewee/querying.rst:53
msgid ""
"If you simply wish to insert data and do not need to create a model "
"instance, you can use :py:meth:`Model.insert`:"
msgstr ""

#: ../../peewee/querying.rst:60
msgid ""
"After executing the insert query, the primary key of the new row is "
"returned."
msgstr ""

#: ../../peewee/querying.rst:63
msgid ""
"There are several ways you can speed up bulk insert operations. Check out"
" the :ref:`bulk_inserts` recipe section for more information."
msgstr ""

#: ../../peewee/querying.rst:69
msgid "Bulk inserts"
msgstr "一括挿入"

#: ../../peewee/querying.rst:71
msgid ""
"There are a couple of ways you can load lots of data quickly. The naive "
"approach is to simply call :py:meth:`Model.create` in a loop:"
msgstr ""

#: ../../peewee/querying.rst:84
msgid "The above approach is slow for a couple of reasons:"
msgstr ""

#: ../../peewee/querying.rst:86
msgid ""
"If you are using autocommit (the default), then each call to "
":py:meth:`~Model.create` happens in its own transaction. That is going to"
" be really slow!"
msgstr ""

#: ../../peewee/querying.rst:87
msgid ""
"There is a decent amount of Python logic getting in your way, and each "
":py:class:`InsertQuery` must be generated and parsed into SQL."
msgstr ""

#: ../../peewee/querying.rst:88
msgid ""
"That's a lot of data (in terms of raw bytes of SQL) you are sending to "
"your database to parse."
msgstr ""

#: ../../peewee/querying.rst:89
msgid ""
"We are retrieving the *last insert id*, which causes an additional query "
"to be executed in some cases."
msgstr ""

#: ../../peewee/querying.rst:91
msgid ""
"You can get a **very significant speedup** by simply wrapping this in a "
":py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/querying.rst:100
msgid ""
"The above code still suffers from points 2, 3 and 4. We can get another "
"big boost by calling :py:meth:`~Model.insert_many`. This method accepts a"
" list of dictionaries to insert."
msgstr ""

#: ../../peewee/querying.rst:108
msgid ""
"Depending on the number of rows in your data source, you may need to "
"break it up into chunks:"
msgstr ""

#: ../../peewee/querying.rst:118
msgid ""
"SQLite users should be aware of some caveats when using bulk inserts. "
"Specifically, your SQLite3 version must be 3.7.11.0 or newer to take "
"advantage of the bulk insert API. Additionally, by default SQLite limits "
"the number of bound variables in a SQL query to ``999``. This value can "
"be modified by setting the ``SQLITE_MAX_VARIABLE_NUMBER`` flag."
msgstr ""

#: ../../peewee/querying.rst:124
msgid ""
"If the data you would like to bulk load is stored in another table, you "
"can also create *INSERT* queries whose source is a *SELECT* query. Use "
"the :py:meth:`Model.insert_from` method:"
msgstr ""

#: ../../peewee/querying.rst:135
msgid "Updating existing records"
msgstr "既存レコードの更新"

#: ../../peewee/querying.rst:137
msgid ""
"Once a model instance has a primary key, any subsequent call to "
":py:meth:`~Model.save` will result in an *UPDATE* rather than another "
"*INSERT*. The model's primary key will not change:"
msgstr ""

#: ../../peewee/querying.rst:153
msgid ""
"If you want to update multiple records, issue an *UPDATE* query. The "
"following example will update all ``Tweet`` objects, marking them as "
"*published*, if they were created before today. :py:meth:`Model.update` "
"accepts keyword arguments where the keys correspond to the model's field "
"names:"
msgstr ""

#: ../../peewee/querying.rst:162
msgid ""
"For more information, see the documentation on :py:meth:`Model.update` "
"and :py:class:`UpdateQuery`."
msgstr ""

#: ../../peewee/querying.rst:165
msgid ""
"If you would like more information on performing atomic updates (such as "
"incrementing the value of a column), check out the :ref:`atomic update "
"<atomic_updates>` recipes."
msgstr ""

#: ../../peewee/querying.rst:172
msgid "Atomic updates"
msgstr "アトミックアップデート"

#: ../../peewee/querying.rst:174
msgid ""
"Peewee allows you to perform atomic updates. Let's suppose we need to "
"update some counters. The naive approach would be to write something like"
" this:"
msgstr "Peeweeはアトミックアップデートが実行することができます。"
"いくつかのカウンターを更新する必要があるとしましょう。"
"素朴なアプローチだと、このように書きます:"

#: ../../peewee/querying.rst:182
msgid ""
"**Do not do this!** Not only is this slow, but it is also vulnerable to "
"race conditions if multiple processes are updating the counter at the "
"same time."
msgstr "**これをしないで！** これは遅いだけでなく、複数のプロセスが同時にカウンタを更新している場合、競合状態に対しても脆弱です。"

#: ../../peewee/querying.rst:184
msgid ""
"Instead, you can update the counters atomically using "
":py:meth:`~Model.update`:"
msgstr "代わりに :py:meth:`Model.update` を使用するとカウンターをアトミックに更新できます:"

#: ../../peewee/querying.rst:191
#, python-format
msgid ""
"You can make these update statements as complex as you like. Let's give "
"all our employees a bonus equal to their previous bonus plus 10% of their"
" salary:"
msgstr "これらの更新ステートメントを好きなだけ複雑にすることができます。"
"すべての従業員に前回のボーナスに加えて給与の10％のボーナスを加えましょう:"

#: ../../peewee/querying.rst:198
msgid ""
"We can even use a subquery to update the value of a column. Suppose we "
"had a denormalized column on the ``User`` model that stored the number of"
" tweets a user had made, and we updated this value periodically. Here is "
"how you might write such a query:"
msgstr "サブクエリを使用してカラムの値を更新することもできます。"
"ユーザが作成したツイートの数を格納した ``Userl`` モデルの非正規化カラムを持ち、この値を定期的に更新したとします。"
"このようなクエリを書く方法は次のとおりです:"

#: ../../peewee/querying.rst:207
msgid "Deleting records"
msgstr "レコードの削除"

#: ../../peewee/querying.rst:209
msgid ""
"To delete a single model instance, you can use the "
":py:meth:`Model.delete_instance` shortcut. "
":py:meth:`~Model.delete_instance` will delete the given model instance "
"and can optionally delete any dependent objects recursively (by "
"specifying `recursive=True`)."
msgstr ""

#: ../../peewee/querying.rst:222
msgid ""
"To delete an arbitrary set of rows, you can issue a *DELETE* query. The "
"following will delete all ``Tweet`` objects that are over one year old:"
msgstr ""

#: ../../peewee/querying.rst:230 ../../peewee/querying.rst:271
msgid "For more information, see the documentation on:"
msgstr ""

#: ../../peewee/querying.rst:232
msgid ":py:meth:`Model.delete_instance`"
msgstr ""

#: ../../peewee/querying.rst:233
msgid ":py:meth:`Model.delete`"
msgstr ""

#: ../../peewee/querying.rst:237
msgid "Selecting a single record"
msgstr "一つのレコードを選択"

#: ../../peewee/querying.rst:239
msgid ""
"You can use the :py:meth:`Model.get` method to retrieve a single instance"
" matching the given query."
msgstr ""

#: ../../peewee/querying.rst:241
msgid ""
"This method is a shortcut that calls :py:meth:`Model.select` with the "
"given query, but limits the result set to a single row. Additionally, if "
"no model matches the given query, a ``DoesNotExist`` exception will be "
"raised."
msgstr ""

#: ../../peewee/querying.rst:259
msgid ""
"For more advanced operations, you can use :py:meth:`SelectQuery.get`. The"
" following query retrieves the latest tweet from the user named "
"*charlie*:"
msgstr ""

#: ../../peewee/querying.rst:273
msgid ":py:meth:`Model.get`"
msgstr ""

#: ../../peewee/querying.rst:274
msgid ":py:meth:`Model.select`"
msgstr ""

#: ../../peewee/querying.rst:275
msgid ":py:meth:`SelectQuery.get`"
msgstr ""

#: ../../peewee/querying.rst:278
msgid "Create or get"
msgstr "作成するか取得する"

#: ../../peewee/querying.rst:280
msgid "Peewee has two methods for performing \"get/create\" type operations:"
msgstr ""

#: ../../peewee/querying.rst:282
msgid ""
":py:meth:`Model.create_or_get`, which will attempt to create a new row. "
"If an ``IntegrityError`` occurs indicating the violation of a constraint,"
" then Peewee will attempt to get the object instead."
msgstr ""

#: ../../peewee/querying.rst:283
msgid ""
":py:meth:`Model.get_or_create`, which first attempts to retrieve the "
"matching row. Failing that, a new row will be created."
msgstr ""

#: ../../peewee/querying.rst:285
msgid ""
"Let's say we wish to implement registering a new user account using the "
":ref:`example User model <blog-models>`. The *User* model has a *unique* "
"constraint on the username field, so we will rely on the database's "
"integrity guarantees to ensure we don't end up with duplicate usernames:"
msgstr ""

#: ../../peewee/querying.rst:297
msgid ""
"Rather than writing all this code, you can instead call either "
":py:meth:`~Model.create_or_get`:"
msgstr ""

#: ../../peewee/querying.rst:303
msgid ""
"The above example first attempts at creation, then falls back to "
"retrieval, relying on the database to enforce a unique constraint."
msgstr ""

#: ../../peewee/querying.rst:305
msgid ""
"If you prefer to attempt to retrieve the record first, you can use "
":py:meth:`~Model.get_or_create`. This method is implemented along the "
"same lines as the Django function of the same name. You can use the "
"Django-style keyword argument filters to specify your ``WHERE`` "
"conditions. The function returns a 2-tuple containing the instance and a "
"boolean value indicating if the object was created."
msgstr ""

#: ../../peewee/querying.rst:307
msgid ""
"Here is how you might implement user account creation using "
":py:meth:`~Model.get_or_create`:"
msgstr ""

#: ../../peewee/querying.rst:313
msgid ""
"Suppose we have a different model ``Person`` and would like to get or "
"create a person object. The only conditions we care about when retrieving"
" the ``Person`` are their first and last names, **but** if we end up "
"needing to create a new record, we will also specify their date-of-birth "
"and favorite color:"
msgstr ""

#: ../../peewee/querying.rst:322
msgid ""
"Any keyword argument passed to :py:meth:`~Model.get_or_create` will be "
"used in the ``get()`` portion of the logic, except for the ``defaults`` "
"dictionary, which will be used to populate values on newly-created "
"instances."
msgstr ""

#: ../../peewee/querying.rst:324
msgid ""
"For more details check out the documentation for "
":py:meth:`Model.create_or_get` and :py:meth:`Model.get_or_create`."
msgstr ""

#: ../../peewee/querying.rst:327
msgid "Selecting multiple records"
msgstr "複数のレコード選択"

#: ../../peewee/querying.rst:329
msgid ""
"We can use :py:meth:`Model.select` to retrieve rows from the table. When "
"you construct a *SELECT* query, the database will return any rows that "
"correspond to your query. Peewee allows you to iterate over these rows, "
"as well as use indexing and slicing operations."
msgstr ""

#: ../../peewee/querying.rst:331
msgid ""
"In the following example, we will simply call :py:meth:`~Model.select` "
"and iterate over the return value, which is an instance of "
":py:class:`SelectQuery`. This will return all the rows in the *User* "
"table:"
msgstr ""

#: ../../peewee/querying.rst:343
msgid ""
"Subsequent iterations of the same query will not hit the database as the "
"results are cached. To disable this behavior (to reduce memory usage), "
"call :py:meth:`SelectQuery.iterator` when iterating."
msgstr ""

#: ../../peewee/querying.rst:345
msgid ""
"When iterating over a model that contains a foreign key, be careful with "
"the way you access values on related models. Accidentally resolving a "
"foreign key or iterating over a back-reference can cause :ref:`N+1 query "
"behavior <nplusone>`."
msgstr ""

#: ../../peewee/querying.rst:347
msgid ""
"When you create a foreign key, such as ``Tweet.user``, you can use the "
"*related_name* to create a back-reference (``User.tweets``). Back-"
"references are exposed as :py:class:`SelectQuery` instances:"
msgstr ""

#: ../../peewee/querying.rst:359
msgid ""
"You can iterate over the ``user.tweets`` back-reference just like any "
"other :py:class:`SelectQuery`:"
msgstr ""

#: ../../peewee/querying.rst:371
msgid "Filtering records"
msgstr "レコードのフィルタリング"

#: ../../peewee/querying.rst:373
msgid ""
"You can filter for particular records using normal python operators. "
"Peewee supports a wide variety of :ref:`query operators <query-"
"operators>`."
msgstr ""

#: ../../peewee/querying.rst:389
msgid "You can also filter across joins:"
msgstr ""

#: ../../peewee/querying.rst:399
msgid ""
"If you want to express a complex query, use parentheses and python's "
"bitwise *or* and *and* operators:"
msgstr ""

#: ../../peewee/querying.rst:408
msgid ""
"Check out :ref:`the table of query operations <query-operators>` to see "
"what types of queries are possible."
msgstr ""

#: ../../peewee/querying.rst:412
msgid "A lot of fun things can go in the where clause of a query, such as:"
msgstr ""

#: ../../peewee/querying.rst:414
msgid "A field expression, e.g. ``User.username == 'Charlie'``"
msgstr ""

#: ../../peewee/querying.rst:415
msgid ""
"A function expression, e.g. ``fn.Lower(fn.Substr(User.username, 1, 1)) =="
" 'a'``"
msgstr ""

#: ../../peewee/querying.rst:416
msgid ""
"A comparison of one column to another, e.g. ``Employee.salary < "
"(Employee.tenure * 1000) + 40000``"
msgstr ""

#: ../../peewee/querying.rst:418
msgid ""
"You can also nest queries, for example tweets by users whose username "
"starts with \"a\":"
msgstr ""

#: ../../peewee/querying.rst:429
msgid "More query examples"
msgstr ""

#: ../../peewee/querying.rst:431
msgid "Get active users:"
msgstr ""

#: ../../peewee/querying.rst:437
msgid "Get users who are either staff or superusers:"
msgstr ""

#: ../../peewee/querying.rst:444
msgid "Get tweets by user named \"charlie\":"
msgstr ""

#: ../../peewee/querying.rst:450
msgid "Get tweets by staff or superusers (assumes FK relationship):"
msgstr ""

#: ../../peewee/querying.rst:457
msgid "Get tweets by staff or superusers using a subquery:"
msgstr ""

#: ../../peewee/querying.rst:466
msgid "Sorting records"
msgstr "レコードのソート"

#: ../../peewee/querying.rst:468
msgid "To return rows in order, use the :py:meth:`~SelectQuery.order_by` method:"
msgstr ""

#: ../../peewee/querying.rst:486
msgid "You can also use ``+`` and ``-`` prefix operators to indicate ordering:"
msgstr ""

#: ../../peewee/querying.rst:498
msgid ""
"You can also order across joins. Assuming you want to order tweets by the"
" username of the author, then by created_date:"
msgstr ""

#: ../../peewee/querying.rst:512
msgid ""
"When sorting on a calculated value, you can either include the necessary "
"SQL expressions, or reference the alias assigned to the value. Here are "
"two examples illustrating these methods:"
msgstr ""

#: ../../peewee/querying.rst:524
msgid ""
"You can order using the same COUNT expression used in the ``select`` "
"clause. In the example below we are ordering by the ``COUNT()`` of tweet "
"ids descending:"
msgstr ""

#: ../../peewee/querying.rst:534
msgid ""
"Alternatively, you can reference the alias assigned to the calculated "
"value in the ``select`` clause. This method has the benefit of being a "
"bit easier to read. Note that we are not referring to the named alias "
"directly, but are wrapping it using the :py:class:`SQL` helper:"
msgstr ""

#: ../../peewee/querying.rst:545
msgid "Getting random records"
msgstr "ランダムにレコードを取得"

#: ../../peewee/querying.rst:547
msgid ""
"Occasionally you may want to pull a random record from the database. You "
"can accomplish this by ordering by the *random* or *rand* function "
"(depending on your database):"
msgstr ""

#: ../../peewee/querying.rst:549
msgid "Postgresql and Sqlite use the *Random* function:"
msgstr ""

#: ../../peewee/querying.rst:556
msgid "MySQL uses *Rand*:"
msgstr ""

#: ../../peewee/querying.rst:564
msgid "Paginating records"
msgstr "レコードのページネーション"

#: ../../peewee/querying.rst:566
msgid ""
"The :py:meth:`~SelectQuery.paginate` method makes it easy to grab a "
"*page* or records. :py:meth:`~SelectQuery.paginate` takes two parameters,"
" ``page_number``, and ``items_per_page``."
msgstr ""

#: ../../peewee/querying.rst:569
msgid "Page numbers are 1-based, so the first page of results will be page 1."
msgstr ""

#: ../../peewee/querying.rst:587
msgid ""
"If you would like more granular control, you can always use "
":py:meth:`~SelectQuery.limit` and :py:meth:`~SelectQuery.offset`."
msgstr ""

#: ../../peewee/querying.rst:590
msgid "Counting records"
msgstr "レコードのカウント"

#: ../../peewee/querying.rst:592
msgid "You can count the number of rows in any select query:"
msgstr ""

#: ../../peewee/querying.rst:601
msgid ""
"In some cases it may be necessary to wrap your query and apply a count to"
" the rows of the inner query (such as when using *DISTINCT* or *GROUP "
"BY*). Peewee will usually do this automatically, but in some cases you "
"may need to manually call :py:meth:`~SelectQuery.wrapped_count` instead."
msgstr ""

#: ../../peewee/querying.rst:604
msgid "Aggregating records"
msgstr "レコードの集計"

#: ../../peewee/querying.rst:606
msgid ""
"Suppose you have some users and want to get a list of them along with the"
" count of tweets in each. The :py:meth:`~SelectQuery.annotate` method "
"provides a short-hand for creating these types of queries:"
msgstr ""

#: ../../peewee/querying.rst:612
msgid "The above query is equivalent to:"
msgstr ""

#: ../../peewee/querying.rst:621
msgid ""
"The resulting query will return *User* objects with all their normal "
"attributes plus an additional attribute *count* which will contain the "
"count of tweets for each user. By default it uses an inner join if the "
"foreign key is not nullable, which means users without tweets won't "
"appear in the list. To remedy this, manually specify the type of join to "
"include users with 0 tweets:"
msgstr ""

#: ../../peewee/querying.rst:631
msgid "You can also specify a custom aggregator, such as *MIN* or *MAX*:"
msgstr ""

#: ../../peewee/querying.rst:641
msgid ""
"Let's assume you have a tagging application and want to find tags that "
"have a certain number of related objects. For this example we'll use some"
" different models in a :ref:`many-to-many <manytomany>` configuration:"
msgstr ""

#: ../../peewee/querying.rst:655
msgid ""
"Now say we want to find tags that have at least 5 photos associated with "
"them:"
msgstr ""

#: ../../peewee/querying.rst:677
msgid "Suppose we want to grab the associated count and store it on the tag:"
msgstr ""

#: ../../peewee/querying.rst:689
msgid "Retrieving Scalar Values"
msgstr "スカラー値の取得"

#: ../../peewee/querying.rst:691
msgid ""
"You can retrieve scalar values by calling :py:meth:`Query.scalar`. For "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:698
msgid "You can retrieve multiple scalar values by passing ``as_tuple=True``:"
msgstr ""

#: ../../peewee/querying.rst:708
msgid "SQL Functions, Subqueries and \"Raw expressions\""
msgstr "SQL関数、サブクエリ、および \"生の式\""

#: ../../peewee/querying.rst:710
msgid ""
"Suppose you need to want to get a list of all users whose username begins"
" with *a*. There are a couple ways to do this, but one method might be to"
" use some SQL functions like *LOWER* and *SUBSTR*. To use arbitrary SQL "
"functions, use the special :py:func:`fn` object to construct queries:"
msgstr ""

#: ../../peewee/querying.rst:723
msgid ""
"There are times when you may want to simply pass in some arbitrary sql. "
"You can do this using the special :py:class:`SQL` class. One use-case is "
"when referencing an alias:"
msgstr ""

#: ../../peewee/querying.rst:734
msgid "There are two ways to execute hand-crafted SQL statements with peewee:"
msgstr ""

#: ../../peewee/querying.rst:736
msgid ":py:meth:`Database.execute_sql` for executing any type of query"
msgstr ""

#: ../../peewee/querying.rst:737
msgid ""
":py:class:`RawQuery` for executing ``SELECT`` queries and *returning "
"model instances*."
msgstr ""

#: ../../peewee/querying.rst:760
msgid "Security and SQL Injection"
msgstr "セキュリティとSQLインジェクション"

#: ../../peewee/querying.rst:762
msgid ""
"By default peewee will parameterize queries, so any parameters passed in "
"by the user will be escaped. The only exception to this rule is if you "
"are writing a raw SQL query or are passing in a ``SQL`` object which may "
"contain untrusted data. To mitigate this, ensure that any user-defined "
"data is passed in as a query parameter and not part of the actual SQL "
"query:"
msgstr ""

#: ../../peewee/querying.rst:779
#, python-format
msgid ""
"MySQL and Postgresql use ``'%s'`` to denote parameters. SQLite, on the "
"other hand, uses ``'?'``. Be sure to use the character appropriate to "
"your database. You can also find this parameter by checking "
":py:attr:`Database.interpolation`."
msgstr ""

#: ../../peewee/querying.rst:786
msgid ""
"peewee comes with basic support for SQL window functions, which can be "
"created by calling :py:meth:`fn.over` and passing in your partitioning or"
" ordering parameters."
msgstr ""

#: ../../peewee/querying.rst:808
msgid ""
"For general information on window functions, check out the `postgresql "
"docs <http://www.postgresql.org/docs/9.1/static/tutorial-window.html>`_."
msgstr ""

#: ../../peewee/querying.rst:811
msgid "Retrieving raw tuples / dictionaries"
msgstr "生のタプル/辞書の取得"

#: ../../peewee/querying.rst:813
msgid ""
"Sometimes you do not need the overhead of creating model instances and "
"simply want to iterate over the row tuples. To do this, call "
":py:meth:`SelectQuery.tuples` or :py:meth:`RawQuery.tuples`:"
msgstr ""

#: ../../peewee/querying.rst:823
msgid ""
"Similarly, you can return the rows from the cursor as dictionaries using "
":py:meth:`SelectQuery.dicts` or :py:meth:`RawQuery.dicts`:"
msgstr ""

#: ../../peewee/querying.rst:836
msgid "Returning Clause"
msgstr "Returing句"

#: ../../peewee/querying.rst:838
msgid ""
":py:class:`PostgresqlDatabase` supports a ``RETURNING`` clause on "
"``UPDATE``, ``INSERT`` and ``DELETE`` queries. Specifying a ``RETURNING``"
" clause allows you to iterate over the rows accessed by the query."
msgstr ""

#: ../../peewee/querying.rst:840
msgid ""
"For example, let's say you have an :py:class:`UpdateQuery` that "
"deactivates all user accounts whose registration has expired. After "
"deactivating them, you want to send each user an email letting them know "
"their account was deactivated. Rather than writing two queries, a "
"``SELECT`` and an ``UPDATE``, you can do this in a single ``UPDATE`` "
"query with a ``RETURNING`` clause:"
msgstr ""

#: ../../peewee/querying.rst:853
msgid ""
"The ``RETURNING`` clause is also available on :py:class:`InsertQuery` and"
" :py:class:`DeleteQuery`. When used with ``INSERT``, the newly-created "
"rows will be returned. When used with ``DELETE``, the deleted rows will "
"be returned."
msgstr ""

#: ../../peewee/querying.rst:855
msgid ""
"The only limitation of the ``RETURNING`` clause is that it can only "
"consist of columns from tables listed in the query's ``FROM`` clause. To "
"select all columns from a particular table, you can simply pass in the "
":py:class:`Model` class."
msgstr ""

#: ../../peewee/querying.rst:857
msgid "For more information, see:"
msgstr ""

#: ../../peewee/querying.rst:867
msgid "Query operators"
msgstr "クエリ演算子"

#: ../../peewee/querying.rst:869
msgid "The following types of comparisons are supported by peewee:"
msgstr ""

#: ../../peewee/querying.rst:872
msgid "Comparison"
msgstr ""

#: ../../peewee/querying.rst:874
msgid "``==``"
msgstr ""

#: ../../peewee/querying.rst:874
msgid "x equals y"
msgstr ""

#: ../../peewee/querying.rst:875
msgid "``<``"
msgstr ""

#: ../../peewee/querying.rst:875
msgid "x is less than y"
msgstr ""

#: ../../peewee/querying.rst:876
msgid "``<=``"
msgstr ""

#: ../../peewee/querying.rst:876
msgid "x is less than or equal to y"
msgstr ""

#: ../../peewee/querying.rst:877
msgid "``>``"
msgstr ""

#: ../../peewee/querying.rst:877
msgid "x is greater than y"
msgstr ""

#: ../../peewee/querying.rst:878
msgid "``>=``"
msgstr ""

#: ../../peewee/querying.rst:878
msgid "x is greater than or equal to y"
msgstr ""

#: ../../peewee/querying.rst:879
msgid "``!=``"
msgstr ""

#: ../../peewee/querying.rst:879
msgid "x is not equal to y"
msgstr ""

#: ../../peewee/querying.rst:880
msgid "``<<``"
msgstr ""

#: ../../peewee/querying.rst:880
msgid "x IN y, where y is a list or query"
msgstr ""

#: ../../peewee/querying.rst:881
msgid "``>>``"
msgstr ""

#: ../../peewee/querying.rst:881
msgid "x IS y, where y is None/NULL"
msgstr ""

#: ../../peewee/querying.rst:882
msgid "``%``"
msgstr ""

#: ../../peewee/querying.rst:882
msgid "x LIKE y where y may contain wildcards"
msgstr ""

#: ../../peewee/querying.rst:883
msgid "``**``"
msgstr ""

#: ../../peewee/querying.rst:883
msgid "x ILIKE y where y may contain wildcards"
msgstr ""

#: ../../peewee/querying.rst:884 ../../peewee/querying.rst:912
msgid "``~``"
msgstr ""

#: ../../peewee/querying.rst:884
msgid "Negation"
msgstr ""

#: ../../peewee/querying.rst:887
msgid ""
"Because I ran out of operators to override, there are some additional "
"query operations available as methods:"
msgstr ""

#: ../../peewee/querying.rst:890
msgid "Method"
msgstr ""

#: ../../peewee/querying.rst:892
msgid "``.contains(substr)``"
msgstr ""

#: ../../peewee/querying.rst:892
msgid "Wild-card search for substring."
msgstr ""

#: ../../peewee/querying.rst:893
msgid "``.startswith(prefix)``"
msgstr ""

#: ../../peewee/querying.rst:893
msgid "Search for values beginning with ``prefix``."
msgstr ""

#: ../../peewee/querying.rst:894
msgid "``.endswith(suffix)``"
msgstr ""

#: ../../peewee/querying.rst:894
msgid "Search for values ending with ``suffix``."
msgstr ""

#: ../../peewee/querying.rst:895
msgid "``.between(low, high)``"
msgstr ""

#: ../../peewee/querying.rst:895
msgid "Search for values between ``low`` and ``high``."
msgstr ""

#: ../../peewee/querying.rst:896
msgid "``.regexp(exp)``"
msgstr ""

#: ../../peewee/querying.rst:896
msgid "Regular expression match."
msgstr ""

#: ../../peewee/querying.rst:897
msgid "``.bin_and(value)``"
msgstr ""

#: ../../peewee/querying.rst:897
msgid "Binary AND."
msgstr ""

#: ../../peewee/querying.rst:898
msgid "``.bin_or(value)``"
msgstr ""

#: ../../peewee/querying.rst:898
msgid "Binary OR."
msgstr ""

#: ../../peewee/querying.rst:899
msgid "``.in_(value)``"
msgstr ""

#: ../../peewee/querying.rst:899
msgid "IN lookup (identical to ``<<``)."
msgstr ""

#: ../../peewee/querying.rst:900
msgid "``.not_in(value)``"
msgstr ""

#: ../../peewee/querying.rst:900
msgid "NOT IN lookup."
msgstr ""

#: ../../peewee/querying.rst:901
msgid "``.is_null(is_null)``"
msgstr ""

#: ../../peewee/querying.rst:901
msgid "IS NULL or IS NOT NULL. Accepts boolean param."
msgstr ""

#: ../../peewee/querying.rst:902
msgid "``.concat(other)``"
msgstr ""

#: ../../peewee/querying.rst:902
msgid "Concatenate two strings using ``||``."
msgstr ""

#: ../../peewee/querying.rst:905
msgid "To combine clauses using logical operators, use:"
msgstr ""

#: ../../peewee/querying.rst:908
msgid "Operator"
msgstr ""

#: ../../peewee/querying.rst:910
msgid "``&``"
msgstr ""

#: ../../peewee/querying.rst:910
msgid "AND"
msgstr ""

#: ../../peewee/querying.rst:910
msgid "``(User.is_active == True) & (User.is_admin == True)``"
msgstr ""

#: ../../peewee/querying.rst:911
msgid "``|`` (pipe)"
msgstr ""

#: ../../peewee/querying.rst:911
msgid "OR"
msgstr ""

#: ../../peewee/querying.rst:911
msgid "``(User.is_admin) | (User.is_superuser)``"
msgstr ""

#: ../../peewee/querying.rst:912
msgid "NOT (unary negation)"
msgstr ""

#: ../../peewee/querying.rst:912
msgid "``~(User.username << ['foo', 'bar', 'baz'])``"
msgstr ""

#: ../../peewee/querying.rst:915
msgid "Here is how you might use some of these query operators:"
msgstr ""

#: ../../peewee/querying.rst:931
msgid ""
"Here is how you might combine expressions. Comparisons can be arbitrarily"
" complex."
msgstr ""

#: ../../peewee/querying.rst:935
msgid ""
"Note that the actual comparisons are wrapped in parentheses. Python's "
"operator precedence necessitates that comparisons be wrapped in "
"parentheses."
msgstr ""

#: ../../peewee/querying.rst:961
msgid ""
"Although you may be tempted to use python's ``in``, ``and``, ``or`` and "
"``not`` operators in your query expressions, these **will not work.** The"
" return value of an ``in`` expression is always coerced to a boolean "
"value. Similarly, ``and``, ``or`` and ``not`` all treat their arguments "
"as boolean values and cannot be overloaded."
msgstr ""

#: ../../peewee/querying.rst:967
msgid "So just remember:"
msgstr ""

#: ../../peewee/querying.rst:969
msgid "Use ``<<`` instead of ``in``"
msgstr ""

#: ../../peewee/querying.rst:970
msgid "Use ``&`` instead of ``and``"
msgstr ""

#: ../../peewee/querying.rst:971
msgid "Use ``|`` instead of ``or``"
msgstr ""

#: ../../peewee/querying.rst:972
msgid "Use ``~`` instead of ``not``"
msgstr ""

#: ../../peewee/querying.rst:973
msgid ""
"Don't forget to wrap your comparisons in parentheses when using logical "
"operators."
msgstr ""

#: ../../peewee/querying.rst:976
msgid "For more examples, see the :ref:`expressions` section."
msgstr ""

#: ../../peewee/querying.rst:979
msgid "**LIKE and ILIKE with SQLite**"
msgstr ""

#: ../../peewee/querying.rst:981
msgid ""
"Because SQLite's ``LIKE`` operation is case-insensitive by default, "
"peewee will use the SQLite ``GLOB`` operation for case-sensitive "
"searches. The glob operation uses asterisks for wildcards as opposed to "
"the usual percent-sign. If you are using SQLite and want case-sensitive "
"partial string matching, remember to use asterisks for the wildcard."
msgstr ""

#: ../../peewee/querying.rst:988
msgid "Three valued logic"
msgstr "3つの論理"

#: ../../peewee/querying.rst:990
msgid ""
"Because of the way SQL handles ``NULL``, there are some special "
"operations available for expressing:"
msgstr ""

#: ../../peewee/querying.rst:992
msgid "``IS NULL``"
msgstr ""

#: ../../peewee/querying.rst:993
msgid "``IS NOT NULL``"
msgstr ""

#: ../../peewee/querying.rst:994
msgid "``IN``"
msgstr ""

#: ../../peewee/querying.rst:995
msgid "``NOT IN``"
msgstr ""

#: ../../peewee/querying.rst:997
msgid ""
"While it would be possible to use the ``IS NULL`` and ``IN`` operators "
"with the negation operator (``~``), sometimes to get the correct "
"semantics you will need to explicitly use ``IS NOT NULL`` and ``NOT IN``."
msgstr ""

#: ../../peewee/querying.rst:999
msgid ""
"The simplest way to use ``IS NULL`` and ``IN`` is to use the operator "
"overloads:"
msgstr ""

#: ../../peewee/querying.rst:1010
msgid ""
"If you don't like operator overloads, you can call the Field methods "
"instead:"
msgstr ""

#: ../../peewee/querying.rst:1021
msgid ""
"To negate the above queries, you can use unary negation, but for the "
"correct semantics you may need to use the special ``IS NOT`` and ``NOT "
"IN`` operators:"
msgstr ""

#: ../../peewee/querying.rst:1042
msgid "Adding user-defined operators"
msgstr "ユーザー定義演算子の追加"

#: ../../peewee/querying.rst:1044
msgid ""
"Because I ran out of python operators to overload, there are some missing"
" operators in peewee, for instance `modulo "
"<https://github.com/coleifer/peewee/issues/177>`_. If you find that you "
"need to support an operator that is not in the table above, it is very "
"easy to add your own."
msgstr ""

#: ../../peewee/querying.rst:1046
msgid "Here is how you might add support for ``modulo`` in SQLite:"
msgstr ""

#: ../../peewee/querying.rst:1060
msgid "Now you can use these custom operators to build richer queries:"
msgstr ""

#: ../../peewee/querying.rst:1067
msgid ""
"For more examples check out the source to the "
"``playhouse.postgresql_ext`` module, as it contains numerous operators "
"specific to postgresql's hstore."
msgstr ""

#: ../../peewee/querying.rst:1072
msgid "Expressions"
msgstr "式"

#: ../../peewee/querying.rst:1074
msgid ""
"Peewee is designed to provide a simple, expressive, and pythonic way of "
"constructing SQL queries. This section will provide a quick overview of "
"some common types of expressions."
msgstr ""

#: ../../peewee/querying.rst:1076
msgid ""
"There are two primary types of objects that can be composed to create "
"expressions:"
msgstr ""

#: ../../peewee/querying.rst:1078
msgid ":py:class:`Field` instances"
msgstr ""

#: ../../peewee/querying.rst:1079
msgid "SQL aggregations and functions using :py:class:`fn`"
msgstr ""

#: ../../peewee/querying.rst:1081
msgid ""
"We will assume a simple \"User\" model with fields for username and other"
" things. It looks like this:"
msgstr ""

#: ../../peewee/querying.rst:1095
msgid "Comparisons use the :ref:`query-operators`:"
msgstr ""

#: ../../peewee/querying.rst:1105
msgid ""
"Comparisons can be combined using bitwise *and* and *or*.  Operator "
"precedence is controlled by python and comparisons can be nested to an "
"arbitrary depth:"
msgstr ""

#: ../../peewee/querying.rst:1115
msgid "Comparisons can be used with functions as well:"
msgstr ""

#: ../../peewee/querying.rst:1122
msgid ""
"We can do some fairly interesting things, as expressions can be compared "
"against other expressions.  Expressions also support arithmetic "
"operations:"
msgstr ""

#: ../../peewee/querying.rst:1131
msgid "Expressions allow us to do atomic updates:"
msgstr ""

#: ../../peewee/querying.rst:1138
msgid "Expressions can be used in all parts of a query, so experiment!"
msgstr ""

#: ../../peewee/querying.rst:1141
msgid "Foreign Keys"
msgstr "外部キー"

#: ../../peewee/querying.rst:1143
msgid ""
"Foreign keys are created using a special field class "
":py:class:`ForeignKeyField`. Each foreign key also creates a back-"
"reference on the related model using the specified *related_name*."
msgstr ""

#: ../../peewee/querying.rst:1146
msgid "Traversing foreign keys"
msgstr "外部キーのトラバース"

#: ../../peewee/querying.rst:1148
msgid ""
"Referring back to the :ref:`User and Tweet models <blog-models>`, note "
"that there is a :py:class:`ForeignKeyField` from *Tweet* to *User*. The "
"foreign key can be traversed, allowing you access to the associated user "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:1156
msgid ""
"Unless the *User* model was explicitly selected when retrieving the "
"*Tweet*, an additional query will be required to load the *User* data. To"
" learn how to avoid the extra query, see the :ref:`N+1 query "
"documentation <nplusone>`."
msgstr ""

#: ../../peewee/querying.rst:1158
msgid ""
"The reverse is also true, and we can iterate over the tweets associated "
"with a given *User* instance:"
msgstr ""

#: ../../peewee/querying.rst:1167
msgid ""
"Under the hood, the *tweets* attribute is just a :py:class:`SelectQuery` "
"with the *WHERE* clause pre-populated to point to the given *User* "
"instance:"
msgstr ""

#: ../../peewee/querying.rst:1175
msgid "Joining tables"
msgstr "テーブルの結合"

#: ../../peewee/querying.rst:1177
msgid ""
"Use the :py:meth:`~Query.join` method to *JOIN* additional tables. When a"
" foreign key exists between the source model and the join model, you do "
"not need to specify any additional parameters:"
msgstr ""

#: ../../peewee/querying.rst:1183
msgid ""
"By default peewee will use an *INNER* join, but you can use *LEFT OUTER* "
"or *FULL* joins as well:"
msgstr ""

#: ../../peewee/querying.rst:1196
msgid "Multiple Foreign Keys to the Same Model"
msgstr ""

#: ../../peewee/querying.rst:1198
msgid ""
"When there are multiple foreign keys to the same model, it is good "
"practice to explicitly specify which field you are joining on."
msgstr ""

#: ../../peewee/querying.rst:1200
msgid ""
"Referring back to the :ref:`example app's models <example-app-models>`, "
"consider the *Relationship* model, which is used to denote when one user "
"follows another. Here is the model definition:"
msgstr ""

#: ../../peewee/querying.rst:1214
msgid ""
"Since there are two foreign keys to *User*, we should always specify "
"which field we are using in a join."
msgstr ""

#: ../../peewee/querying.rst:1216
msgid "For example, to determine which users I am following, I would write:"
msgstr ""

#: ../../peewee/querying.rst:1225
msgid ""
"On the other hand, if I wanted to determine which users are following me,"
" I would instead join on the *from_user* column and filter on the "
"relationship's *to_user*:"
msgstr ""

#: ../../peewee/querying.rst:1235
msgid "Joining on arbitrary fields"
msgstr ""

#: ../../peewee/querying.rst:1237
msgid ""
"If a foreign key does not exist between two tables you can still perform "
"a join, but you must manually specify the join predicate."
msgstr ""

#: ../../peewee/querying.rst:1239
msgid ""
"In the following example, there is no explicit foreign-key between *User*"
" and *ActivityLog*, but there is an implied relationship between the "
"*ActivityLog.object_id* field and *User.id*. Rather than joining on a "
"specific :py:class:`Field`, we will join using an :py:class:`Expression`."
msgstr ""

#: ../../peewee/querying.rst:1263
msgid ""
"By specifying an alias on the join condition, you can control the "
"attribute peewee will assign the joined instance to. In the previous "
"example, we used the following *join*:"
msgstr ""

#: ../../peewee/querying.rst:1269
msgid ""
"Then when iterating over the query, we were able to directly access the "
"joined *ActivityLog* without incurring an additional query:"
msgstr ""

#: ../../peewee/querying.rst:1277
msgid "Joining on Multiple Tables"
msgstr ""

#: ../../peewee/querying.rst:1279
msgid ""
"When calling :py:meth:`~Query.join`, peewee will use the *last joined "
"table* as the source table. For example:"
msgstr ""

#: ../../peewee/querying.rst:1285
msgid ""
"This query will result in a join from *User* to *Tweet*, and another join"
" from *Tweet* to *Comment*."
msgstr ""

#: ../../peewee/querying.rst:1287
msgid ""
"If you would like to join the same table twice, use the "
":py:meth:`~Query.switch` method:"
msgstr ""

#: ../../peewee/querying.rst:1297
msgid "Implementing Many to Many"
msgstr "多対多の実装"

#: ../../peewee/querying.rst:1299
msgid ""
"Peewee does not provide a *field* for many to many relationships the way "
"that django does -- this is because the field really is hiding an "
"intermediary table.  To implement many-to-many with peewee, you will "
"therefore create the intermediary table yourself and query through it:"
msgstr ""

#: ../../peewee/querying.rst:1313
msgid ""
"To query, let's say we want to find students who are enrolled in math "
"class:"
msgstr ""

#: ../../peewee/querying.rst:1325
msgid "To query what classes a given student is enrolled in:"
msgstr ""

#: ../../peewee/querying.rst:1338
msgid ""
"To efficiently iterate over a many-to-many relation, i.e., list all "
"students and their respective courses, we will query the *through* model "
"``StudentCourse`` and *precompute* the Student and Course:"
msgstr ""

#: ../../peewee/querying.rst:1349
msgid "To print a list of students and their courses you might do the following:"
msgstr ""

#: ../../peewee/querying.rst:1361
msgid ""
"Since we selected all fields from ``Student`` and ``Course`` in the "
"*select* clause of the query, these foreign key traversals are \"free\" "
"and we've done the whole iteration with just 1 query."
msgstr ""

#: ../../peewee/querying.rst:1364
msgid "ManyToManyField"
msgstr ""

#: ../../peewee/querying.rst:1366
msgid ""
"The :py:class:`ManyToManyField` provides a *field-like* API over many-to-"
"many fields. For all but the simplest many-to-many situations, you're "
"better off using the standard peewee APIs. But, if your models are very "
"simple and your querying needs are not very complex, you can get a big "
"boost by using :py:class:`ManyToManyField`. Check out the :ref:`extra-"
"fields` extension module for details."
msgstr ""

#: ../../peewee/querying.rst:1368
msgid "Modeling students and courses using :py:class:`ManyToManyField`:"
msgstr ""

#: ../../peewee/querying.rst:1423
msgid "For more examples, see:"
msgstr ""

#: ../../peewee/querying.rst:1425
msgid ":py:meth:`ManyToManyField.add`"
msgstr ""

#: ../../peewee/querying.rst:1426
msgid ":py:meth:`ManyToManyField.remove`"
msgstr ""

#: ../../peewee/querying.rst:1427
msgid ":py:meth:`ManyToManyField.clear`"
msgstr ""

#: ../../peewee/querying.rst:1428
msgid ":py:meth:`ManyToManyField.get_through_model`"
msgstr ""

#: ../../peewee/querying.rst:1432
msgid "Self-joins"
msgstr "自己結合"

#: ../../peewee/querying.rst:1434
msgid ""
"Peewee supports several methods for constructing queries containing a "
"self-join."
msgstr ""

#: ../../peewee/querying.rst:1437
msgid "Using model aliases"
msgstr ""

#: ../../peewee/querying.rst:1439
msgid ""
"To join on the same model (table) twice, it is necessary to create a "
"model alias to represent the second instance of the table in a query. "
"Consider the following model:"
msgstr ""

#: ../../peewee/querying.rst:1447
msgid ""
"What if we wanted to query all categories whose parent category is "
"*Electronics*. One way would be to perform a self-join:"
msgstr ""

#: ../../peewee/querying.rst:1457
msgid ""
"When performing a join that uses a :py:class:`ModelAlias`, it is "
"necessary to specify the join condition using the ``on`` keyword "
"argument. In this case we are joining the category with its parent "
"category."
msgstr ""

#: ../../peewee/querying.rst:1460
msgid "Using subqueries"
msgstr ""

#: ../../peewee/querying.rst:1462
msgid ""
"Another less common approach involves the use of subqueries. Here is "
"another way we might construct a query to get all the categories whose "
"parent category is *Electronics* using a subquery:"
msgstr ""

#: ../../peewee/querying.rst:1475
msgid "This will generate the following SQL query:"
msgstr ""

#: ../../peewee/querying.rst:1487
msgid ""
"To access the ``id`` value from the subquery, we use the ``.c`` magic "
"lookup which will generate the appropriate SQL expression:"
msgstr ""

#: ../../peewee/querying.rst:1495
msgid "Performance Techniques"
msgstr "パフォーマンステクニック"

#: ../../peewee/querying.rst:1497
msgid ""
"This section outlines some techniques for improving performance when "
"using peewee."
msgstr ""

#: ../../peewee/querying.rst:1502
msgid "Avoiding N+1 queries"
msgstr "N+1クエリを避ける"

#: ../../peewee/querying.rst:1504
msgid ""
"The term *N+1 queries* refers to a situation where an application "
"performs a query, then for each row of the result set, the application "
"performs at least one other query (another way to conceptualize this is "
"as a nested loop). In many cases, these *n* queries can be avoided "
"through the use of a SQL join or subquery. The database itself may do a "
"nested loop, but it will usually be more performant than doing *n* "
"queries in your application code, which involves latency communicating "
"with the database and may not take advantage of indices or other "
"optimizations employed by the database when joining or executing a "
"subquery."
msgstr ""

#: ../../peewee/querying.rst:1506
msgid ""
"Peewee provides several APIs for mitigating *N+1* query behavior. "
"Recollecting the models used throughout this document, *User* and "
"*Tweet*, this section will try to outline some common *N+1* scenarios, "
"and how peewee can help you avoid them."
msgstr ""

#: ../../peewee/querying.rst:1509
msgid ""
"In some cases, N+1 queries will not result in a significant or measurable"
" performance hit. It all depends on the data you are querying, the "
"database you are using, and the latency involved in executing queries and"
" retrieving results. As always when making optimizations, profile before "
"and after to ensure the changes do what you expect them to."
msgstr ""

#: ../../peewee/querying.rst:1512
msgid "List recent tweets"
msgstr ""

#: ../../peewee/querying.rst:1514
msgid ""
"The twitter timeline displays a list of tweets from multiple users. In "
"addition to the tweet's content, the username of the tweet's author is "
"also displayed. The N+1 scenario here would be:"
msgstr ""

#: ../../peewee/querying.rst:1516
msgid "Fetch the 10 most recent tweets."
msgstr ""

#: ../../peewee/querying.rst:1517
msgid "For each tweet, select the author (10 queries)."
msgstr ""

#: ../../peewee/querying.rst:1519
msgid ""
"By selecting both tables and using a *join*, peewee makes it possible to "
"accomplish this in a single query:"
msgstr ""

#: ../../peewee/querying.rst:1532
msgid ""
"Without the join, accessing ``tweet.user.username`` would trigger a query"
" to resolve the foreign key ``tweet.user`` and retrieve the associated "
"user. But since we have selected and joined on ``User``, peewee will "
"automatically resolve the foreign-key for us."
msgstr ""

#: ../../peewee/querying.rst:1535
msgid "List users and all their tweets"
msgstr ""

#: ../../peewee/querying.rst:1537
msgid ""
"Let's say you want to build a page that shows several users and all of "
"their tweets. The N+1 scenario would be:"
msgstr ""

#: ../../peewee/querying.rst:1539
msgid "Fetch some users."
msgstr ""

#: ../../peewee/querying.rst:1540
msgid "For each user, fetch their tweets."
msgstr ""

#: ../../peewee/querying.rst:1542
msgid ""
"This situation is similar to the previous example, but there is one "
"important difference: when we selected tweets, they only have a single "
"associated user, so we could directly assign the foreign key. The reverse"
" is not true, however, as one user may have any number of tweets (or none"
" at all)."
msgstr ""

#: ../../peewee/querying.rst:1544
msgid ""
"Peewee provides two approaches to avoiding *O(n)* queries in this "
"situation. We can either:"
msgstr ""

#: ../../peewee/querying.rst:1546
msgid ""
"Fetch users first, then fetch all the tweets associated with those users."
" Once peewee has the big list of tweets, it will assign them out, "
"matching them with the appropriate user. This method is usually faster "
"but will involve a query for each table being selected."
msgstr ""

#: ../../peewee/querying.rst:1547
msgid ""
"Fetch both users and tweets in a single query. User data will be "
"duplicated, so peewee will de-dupe it and aggregate the tweets as it "
"iterates through the result set. This method involves a lot of data being"
" transferred over the wire and a lot of logic in Python to de-duplicate "
"rows."
msgstr ""

#: ../../peewee/querying.rst:1549
msgid ""
"Each solution has its place and, depending on the size and shape of the "
"data you are querying, one may be more performant than the other."
msgstr ""

#: ../../peewee/querying.rst:1554
msgid "Using prefetch"
msgstr ""

#: ../../peewee/querying.rst:1556
msgid ""
"peewee supports pre-fetching related data using sub-queries. This method "
"requires the use of a special API, :py:func:`prefetch`. Pre-fetch, as its"
" name indicates, will eagerly load the appropriate tweets for the given "
"users using subqueries. This means instead of *O(n)* queries for *n* "
"rows, we will do *O(k)* queries for *k* tables."
msgstr ""

#: ../../peewee/querying.rst:1558
msgid ""
"Here is an example of how we might fetch several users and any tweets "
"they created within the past week."
msgstr ""

#: ../../peewee/querying.rst:1579
msgid ""
"Note that neither the ``User`` query, nor the ``Tweet`` query contained a"
" JOIN clause. When using :py:func:`prefetch` you do not need to specify "
"the join."
msgstr ""

#: ../../peewee/querying.rst:1583
msgid ""
":py:func:`prefetch` can be used to query an arbitrary number of tables. "
"Check the API documentation for more examples."
msgstr ""

#: ../../peewee/querying.rst:1585
msgid "Some things to consider when using :py:func:`prefetch`:"
msgstr ""

#: ../../peewee/querying.rst:1587
msgid "Foreign keys must exist between the models being prefetched."
msgstr ""

#: ../../peewee/querying.rst:1588
msgid ""
"In general it is more performant than "
":py:meth:`~SelectQuery.aggregate_rows`."
msgstr ""

#: ../../peewee/querying.rst:1589
msgid ""
"Typically a lot less data is transferred over the wire since data is not "
"duplicated."
msgstr ""

#: ../../peewee/querying.rst:1590
msgid "There is less Python overhead since we don't have to de-dupe things."
msgstr ""

#: ../../peewee/querying.rst:1591
msgid ""
"`LIMIT` works as you'd expect on the outer-most query, but may be "
"difficult to implement correctly if trying to limit the size of the sub-"
"selects."
msgstr ""

#: ../../peewee/querying.rst:1596
msgid "Using aggregate_rows"
msgstr ""

#: ../../peewee/querying.rst:1598
msgid ""
"The :py:meth:`~SelectQuery.aggregate_rows` approach selects all data in "
"one go and de-dupes things in-memory. Like :py:func:`prefetch`, it can "
"work with arbitrarily complex queries. To use this feature We will use a "
"special flag, :py:meth:`~SelectQuery.aggregate_rows`, when creating our "
"query. This method tells peewee to de-duplicate any rows that, due to the"
" structure of the JOINs, may be duplicated."
msgstr ""

#: ../../peewee/querying.rst:1601
msgid ""
"Because there is a lot of computation involved in de-duping data, it is "
"possible that for some queries :py:meth:`~SelectQuery.aggregate_rows` "
"will be **significantly less performant** than using :py:func:`prefetch` "
"(described in the previous section) or even issuing *O(n)* simple "
"queries! Profile your code if you're not sure."
msgstr ""

#: ../../peewee/querying.rst:1616
msgid ""
"Ordinarily, ``user.tweets`` would be a :py:class:`SelectQuery` and "
"iterating over it would trigger an additional query. By using "
":py:meth:`~SelectQuery.aggregate_rows`, though, ``user.tweets`` is a "
"Python ``list`` and no additional query occurs."
msgstr ""

#: ../../peewee/querying.rst:1619
msgid ""
"We used a *LEFT OUTER* join to ensure that users with zero tweets would "
"also be included in the result set."
msgstr ""

#: ../../peewee/querying.rst:1621
msgid ""
"Below is an example of how we might fetch several users and any tweets "
"they created within the past week. Because we are filtering the tweets "
"and the user may not have any tweets, we need our *WHERE* clause to allow"
" *NULL* tweet IDs."
msgstr ""

#: ../../peewee/querying.rst:1641
msgid "Some things to consider when using :py:meth:`~SelectQuery.aggregate_rows`:"
msgstr ""

#: ../../peewee/querying.rst:1643
msgid ""
"You must specify an ordering for each table that is joined on so the rows"
" can be aggregated correctly, sort of similar to `itertools.groupby "
"<https://docs.python.org/2/library/itertools.html#itertools.groupby>`_."
msgstr ""

#: ../../peewee/querying.rst:1644
msgid ""
"Do not mix calls to :py:meth:`~SelectQuery.aggregate_rows` with ``LIMIT``"
" or ``OFFSET`` clauses, or with :py:meth:`~SelectQuery.get` (which "
"applies a ``LIMIT 1`` SQL clause). Since the aggregate result set may "
"contain more than one item due to rows being duplicated, limits can lead "
"to incorrect behavior. Imagine you have three users, each of whom has 10 "
"tweets. If you run a query with a ``LIMIT 5``, then you will only receive"
" the first user and their first 5 tweets."
msgstr ""

#: ../../peewee/querying.rst:1645
msgid ""
"In general the Python overhead of de-duplicating data can make this "
"method less performant than :py:func:`prefetch`, and sometimes even less "
"performan than simply issuing *O(n)* simple queries! When in doubt "
"profile."
msgstr ""

#: ../../peewee/querying.rst:1646
msgid ""
"Because every column from every table is included in each row tuple "
"returned by the cursor, this approach can use a lot more bandwidth than "
":py:func:`prefetch`."
msgstr ""

#: ../../peewee/querying.rst:1649
msgid "Iterating over lots of rows"
msgstr "たくさんの行を繰り返す"

#: ../../peewee/querying.rst:1651
msgid ""
"By default peewee will cache the rows returned when iterating of a "
":py:class:`SelectQuery`. This is an optimization to allow multiple "
"iterations as well as indexing and slicing without causing additional "
"queries. This caching can be problematic, however, when you plan to "
"iterate over a large number of rows."
msgstr ""

#: ../../peewee/querying.rst:1653
msgid ""
"To reduce the amount of memory used by peewee when iterating over a "
"query, use the :py:meth:`~SelectQuery.iterator` method. This method "
"allows you to iterate without caching each model returned, using much "
"less memory when iterating over large result sets."
msgstr ""

#: ../../peewee/querying.rst:1667
msgid ""
"For simple queries you can see further speed improvements by using the "
":py:meth:`~SelectQuery.naive` method. This method speeds up the "
"construction of peewee model instances from raw cursor data. See the "
":py:meth:`~SelectQuery.naive` documentation for more details on this "
"optimization."
msgstr ""

#: ../../peewee/querying.rst:1674
msgid ""
"You can also see performance improvements by using the "
":py:meth:`~SelectQuery.dicts` and :py:meth:`~SelectQuery.tuples` methods."
msgstr ""

#: ../../peewee/querying.rst:1676
msgid ""
"When iterating over a large number of rows that contain columns from "
"multiple tables, peewee will reconstruct the model graph for each row "
"returned. This operation can be slow for complex graphs. To speed up "
"model creation, you can:"
msgstr ""

#: ../../peewee/querying.rst:1678
msgid ""
"Call :py:meth:`~SelectQuery.naive`, which will not construct a graph and "
"simply patch all attributes from the row directly onto a model instance."
msgstr ""

#: ../../peewee/querying.rst:1679
msgid "Use :py:meth:`~SelectQuery.dicts` or :py:meth:`~SelectQuery.tuples`."
msgstr ""

#: ../../peewee/querying.rst:1682
msgid "Speeding up Bulk Inserts"
msgstr "バルクインサートの高速化"

#: ../../peewee/querying.rst:1684
msgid ""
"See the :ref:`bulk_inserts` section for details on speeding up bulk "
"insert operations."
msgstr ""

#: ../../peewee/quickstart.rst:4
msgid "Quickstart"
msgstr "クイックスタート"

#: ../../peewee/quickstart.rst:6
msgid ""
"This document presents a brief, high-level overview of Peewee's primary "
"features. This guide will cover:"
msgstr "このドキュメントでは、Peeweeの主な機能のハイレベルな概要を簡単に説明します。"

#: ../../peewee/quickstart.rst:8
msgid ":ref:`model-definition`"
msgstr ""

#: ../../peewee/quickstart.rst:9
msgid ":ref:`storing-data`"
msgstr ""

#: ../../peewee/quickstart.rst:10
msgid ":ref:`retrieving-data`"
msgstr ""

#: ../../peewee/quickstart.rst:13
msgid ""
"If you'd like something a bit more meaty, there is a thorough tutorial on"
" :ref:`creating a \"twitter\"-style web app <example-app>` using peewee "
"and the Flask framework."
msgstr "何かもう少し欲しい方は、peeweeとFlaskフレームワークを使った”
" :ref:`creating a \"twitter\"-style web app <example-app>` というチュートリアルがあります。"

#: ../../peewee/quickstart.rst:17
msgid ""
"I **strongly** recommend opening an interactive shell session and running"
" the code. That way you can get a feel for typing in queries."
msgstr ""

#: ../../peewee/quickstart.rst:22
msgid "Model Definition"
msgstr "モデル定義"

#: ../../peewee/quickstart.rst:24
msgid "Model classes, fields and model instances all map to database concepts:"
msgstr ""

#: ../../peewee/quickstart.rst:34
msgid ""
"When starting to a project with peewee, it's typically best to begin with"
" your data model, by defining one or more :py:class:`Model` classes:"
msgstr ""

#: ../../peewee/quickstart.rst:51
msgid ""
"Note that we named our model ``Person`` instead of ``People``. This is a "
"convention you should follow -- even though the table will contain "
"multiple people, we always name the class using the singular form."
msgstr ""

#: ../../peewee/quickstart.rst:53
msgid ""
"There are lots of :ref:`field types <fields>` suitable for storing "
"various types of data. Peewee handles converting between *pythonic* "
"values those used by the database, so you can use Python types in your "
"code without having to worry."
msgstr ""

#: ../../peewee/quickstart.rst:55
msgid ""
"Things get interesting when we set up relationships between models using "
"`foreign keys (wikipedia) <http://en.wikipedia.org/wiki/Foreign_key>`_. "
"This is easy to do with peewee:"
msgstr ""

#: ../../peewee/quickstart.rst:67
msgid ""
"Now that we have our models, let's connect to the database. Although it's"
" not necessary to open the connection explicitly, it is good practice "
"since it will reveal any errors with your database connection "
"immediately, as opposed to some arbitrary time later when the first query"
" is executed. It is also good to close the connection when you are done "
"-- for instance, a web app might open a connection when it receives a "
"request, and close the connection when it sends the response."
msgstr ""

#: ../../peewee/quickstart.rst:73
msgid ""
"We'll begin by creating the tables in the database that will store our "
"data. This will create the tables with the appropriate columns, indexes, "
"sequences, and foreign key constraints:"
msgstr ""

#: ../../peewee/quickstart.rst:84
msgid ""
"Let's begin by populating the database with some people. We will use the "
":py:meth:`~Model.save` and :py:meth:`~Model.create` methods to add and "
"update people's records."
msgstr ""

#: ../../peewee/quickstart.rst:93
msgid ""
"When you call :py:meth:`~Model.save`, the number of rows modified is "
"returned."
msgstr ""

#: ../../peewee/quickstart.rst:95
msgid ""
"You can also add a person by calling the :py:meth:`~Model.create` method,"
" which returns a model instance:"
msgstr ""

#: ../../peewee/quickstart.rst:102
msgid ""
"To update a row, modify the model instance and call "
":py:meth:`~Model.save` to persist the changes. Here we will change "
"Grandma's name and then save the changes in the database:"
msgstr ""

#: ../../peewee/quickstart.rst:110
msgid ""
"Now we have stored 3 people in the database. Let's give them some pets. "
"Grandma doesn't like animals in the house, so she won't have any, but "
"Herb is an animal lover:"
msgstr ""

#: ../../peewee/quickstart.rst:119
msgid ""
"After a long full life, Mittens sickens and dies. We need to remove him "
"from the database:"
msgstr ""

#: ../../peewee/quickstart.rst:126
msgid ""
"The return value of :py:meth:`~Model.delete_instance` is the number of "
"rows removed from the database."
msgstr ""

#: ../../peewee/quickstart.rst:128
msgid ""
"Uncle Bob decides that too many animals have been dying at Herb's house, "
"so he adopts Fido:"
msgstr ""

#: ../../peewee/quickstart.rst:139
msgid "Retrieving Data"
msgstr "データの取得"

#: ../../peewee/quickstart.rst:141
msgid ""
"The real strength of our database is in how it allows us to retrieve data"
" through *queries*. Relational databases are excellent for making ad-hoc "
"queries."
msgstr ""

#: ../../peewee/quickstart.rst:144
msgid "Getting single records"
msgstr ""

#: ../../peewee/quickstart.rst:146
msgid ""
"Let's retrieve Grandma's record from the database. To get a single record"
" from the database, use :py:meth:`SelectQuery.get`:"
msgstr ""

#: ../../peewee/quickstart.rst:152
msgid "We can also use the equivalent shorthand :py:meth:`Model.get`:"
msgstr ""

#: ../../peewee/quickstart.rst:159
msgid "Lists of records"
msgstr ""

#: ../../peewee/quickstart.rst:161
msgid "Let's list all the people in the database:"
msgstr ""

#: ../../peewee/quickstart.rst:172
msgid "Let's list all the cats and their owner's name:"
msgstr ""

#: ../../peewee/quickstart.rst:183
msgid ""
"There is a big problem with the previous query: because we are accessing "
"``pet.owner.name`` and we did not select this value in our original "
"query, peewee will have to perform an additional query to retrieve the "
"pet's owner. This behavior is referred to as :ref:`N+1 <nplusone>` and it"
" should generally be avoided."
msgstr ""

#: ../../peewee/quickstart.rst:185
msgid ""
"We can avoid the extra queries by selecting both *Pet* and *Person*, and "
"adding a *join*."
msgstr ""

#: ../../peewee/quickstart.rst:199
msgid "Let's get all the pets owned by Bob:"
msgstr ""

#: ../../peewee/quickstart.rst:209
msgid ""
"We can do another cool thing here to get bob's pets. Since we already "
"have an object to represent Bob, we can do this instead:"
msgstr ""

#: ../../peewee/quickstart.rst:216
msgid ""
"Let's make sure these are sorted alphabetically by adding an "
":py:meth:`~SelectQuery.order_by` clause:"
msgstr ""

#: ../../peewee/quickstart.rst:226
msgid "Let's list all the people now, youngest to oldest:"
msgstr ""

#: ../../peewee/quickstart.rst:237
msgid "Now let's list all the people *and* some info about their pets:"
msgstr ""

#: ../../peewee/quickstart.rst:253
msgid ""
"Once again we've run into a classic example of :ref:`N+1 <nplusone>` "
"query behavior. We can avoid this by performing a *JOIN* and aggregating "
"the records:"
msgstr ""

#: ../../peewee/quickstart.rst:275
msgid ""
"Even though we created the subquery separately, **only one** query is "
"actually executed."
msgstr ""

#: ../../peewee/quickstart.rst:277
msgid ""
"Finally, let's do a complicated one. Let's get all the people whose "
"birthday was either:"
msgstr ""

#: ../../peewee/quickstart.rst:280
msgid "before 1940 (grandma)"
msgstr ""

#: ../../peewee/quickstart.rst:281
msgid "after 1959 (bob)"
msgstr ""

#: ../../peewee/quickstart.rst:297
msgid "Now let's do the opposite. People whose birthday is between 1940 and 1960:"
msgstr ""

#: ../../peewee/quickstart.rst:310
msgid ""
"One last query. This will use a SQL function to find all people whose "
"names start with either an upper or lower-case *G*:"
msgstr ""

#: ../../peewee/quickstart.rst:320
msgid "We're done with our database, let's close the connection:"
msgstr ""

#: ../../peewee/quickstart.rst:326
msgid "This is just the basics! You can make your queries as complex as you like."
msgstr ""

#: ../../peewee/quickstart.rst:328
msgid "All the other SQL clauses are available as well, such as:"
msgstr ""

#: ../../peewee/quickstart.rst:330
msgid ":py:meth:`~SelectQuery.group_by`"
msgstr ""

#: ../../peewee/quickstart.rst:331
msgid ":py:meth:`~SelectQuery.having`"
msgstr ""

#: ../../peewee/quickstart.rst:332
msgid ":py:meth:`~SelectQuery.limit` and :py:meth:`~SelectQuery.offset`"
msgstr ""

#: ../../peewee/quickstart.rst:334
msgid "Check the documentation on :ref:`querying` for more info."
msgstr ""

#: ../../peewee/quickstart.rst:337
msgid "Working with existing databases"
msgstr "既存データベースの操作"

#: ../../peewee/quickstart.rst:339
msgid ""
"If you already have a database, you can autogenerate peewee models using "
":ref:`pwiz`. For instance, if I have a postgresql database named "
"*charles_blog*, I might run:"
msgstr ""

#: ../../peewee/quickstart.rst:346
msgid "What next?"
msgstr "次は何？"

#: ../../peewee/quickstart.rst:348
msgid ""
"That's it for the quickstart. If you want to look at a full web-app, "
"check out the :ref:`example-app`."
msgstr ""

#: ../../peewee/transactions.rst:4
msgid "Transactions"
msgstr "トランザクション"

#: ../../peewee/transactions.rst:6
msgid ""
"Peewee provides several interfaces for working with transactions. The "
"most general is the :py:meth:`Database.atomic` method, which also "
"supports nested transactions. :py:meth:`~Database.atomic` blocks will be "
"run in a transaction or savepoint, depending on the level of nesting."
msgstr ""

#: ../../peewee/transactions.rst:8
msgid ""
"If an exception occurs in a wrapped block, the current "
"transaction/savepoint will be rolled back. Otherwise the statements will "
"be committed at the end of the wrapped block."
msgstr ""

#: ../../peewee/transactions.rst:10
msgid ""
":py:meth:`~Database.atomic` can be used as either a **context manager** "
"or a **decorator**."
msgstr ""

#: ../../peewee/transactions.rst:13
msgid "Context manager"
msgstr "コンテキストマネージャー"

#: ../../peewee/transactions.rst:15
msgid "Using ``atomic`` as context manager:"
msgstr ""

#: ../../peewee/transactions.rst:38
msgid ""
"You can use the ``atomic`` method to perform *get or create* operations "
"as well:"
msgstr ""

#: ../../peewee/transactions.rst:50
msgid "Decorator"
msgstr "デコレータ"

#: ../../peewee/transactions.rst:52
msgid "Using ``atomic`` as a decorator:"
msgstr ""

#: ../../peewee/transactions.rst:65
msgid "Nesting Transactions"
msgstr "トランザクションのネスト"

#: ../../peewee/transactions.rst:67
msgid ""
":py:meth:`~Database.atomic` provides transparent nesting of transactions."
" When using :py:meth:`~Database.atomic`, the outer-most call will be "
"wrapped in a transaction, and any nested calls will use savepoints."
msgstr ""

#: ../../peewee/transactions.rst:77
msgid ""
"Peewee supports nested transactions through the use of savepoints (for "
"more information, see :py:meth:`~Database.savepoint`)."
msgstr ""

#: ../../peewee/transactions.rst:80
msgid "Explicit transaction"
msgstr "明示的なトランザクション"

#: ../../peewee/transactions.rst:82
msgid ""
"If you wish to explicitly run code in a transaction, you can use "
":py:meth:`~Database.transaction`. Like :py:meth:`~Database.atomic`, "
":py:meth:`~Database.transaction` can be used as a context manager or as a"
" decorator."
msgstr ""

#: ../../peewee/transactions.rst:84
msgid ""
"If an exception occurs in a wrapped block, the transaction will be rolled"
" back. Otherwise the statements will be committed at the end of the "
"wrapped block."
msgstr ""

#: ../../peewee/transactions.rst:94
msgid ""
"Transactions can be explicitly committed or rolled-back within the "
"wrapped block. When this happens, a new transaction will be started."
msgstr ""

#: ../../peewee/transactions.rst:116
msgid ""
"If you attempt to nest transactions with peewee using the "
":py:meth:`~Database.transaction` context manager, only the outer-most "
"transaction will be used. However if an exception occurs in a nested "
"block, this can lead to unpredictable behavior, so it is strongly "
"recommended that you use :py:meth:`~Database.atomic`."
msgstr ""

#: ../../peewee/transactions.rst:119
msgid "Explicit Savepoints"
msgstr ""

#: ../../peewee/transactions.rst:121
msgid ""
"Just as you can explicitly create transactions, you can also explicitly "
"create savepoints using the :py:meth:`~Database.savepoint` method. "
"Savepoints must occur within a transaction, but can be nested arbitrarily"
" deep."
msgstr ""

#: ../../peewee/transactions.rst:133
msgid ""
"If you manually commit or roll back a savepoint, a new savepoint **will "
"not** automatically be created. This differs from the behavior of "
":py:class:`transaction`, which will automatically open a new transaction "
"after manual commit/rollback."
msgstr ""

#: ../../peewee/transactions.rst:136
msgid "Autocommit Mode"
msgstr "自動コミットモード"

#: ../../peewee/transactions.rst:138
msgid ""
"By default, databases are initialized with ``autocommit=True``, you can "
"turn this on and off at runtime if you like. If you choose to disable "
"autocommit, then you must explicitly call :py:meth:`Database.begin` to "
"begin a transaction, and commit or roll back."
msgstr ""

#: ../../peewee/transactions.rst:140
msgid ""
"The behavior below is roughly the same as the context manager and "
"decorator:"
msgstr ""

#: ../../peewee/transactions.rst:160
msgid ""
"If you would like to manually control *every* transaction, simply turn "
"autocommit off when instantiating your database:"
msgstr ""

